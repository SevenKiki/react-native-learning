class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}

const hasOwnProperty = (() => {
    /* eslint-disable-next-line @typescript-eslint/unbound-method */
    const { hasOwnProperty } = Object.prototype;
    return (obj, key) => hasOwnProperty.call(obj, key);
})();
const isNonNullObject = (arg) => typeof arg === 'object' && arg !== null;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isFunction = (arg) => typeof arg === 'function';
const delay = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const memoize = (func, resolver = (...args) => args[0]) => {
    const map = new Map();
    const weakMap = new WeakMap();
    return (...args) => {
        const id = resolver(...args);
        const store = isNonNullObject(id) ? weakMap : map;
        const value = store.get(id) ?? func(...args);
        if (!store.has(id)) {
            store.set(id, value);
        }
        return value;
    };
};

const compareVersion = (leftSemVer, rightSemVer) => {
    if (!leftSemVer || !rightSemVer) {
        return Number.NaN;
    }
    const leftVersions = leftSemVer.split('.').map(version => +version);
    const rightVersions = rightSemVer.split('.').map(version => +version);
    for (let i = 0; i < Math.min(leftVersions.length, rightVersions.length); i += 1) {
        if (Number.isNaN(leftVersions[i]) || Number.isNaN(rightVersions[i])) {
            return Number.NaN;
        }
        if (leftVersions[i] !== rightVersions[i]) {
            return leftVersions[i] - rightVersions[i];
        }
    }
    return 0;
};
const getPlatformVersion = memoize((platform) => new RegExp(`(?:${platform})\\/([\\d+.]+)`)
    .exec(typeof navigator === 'undefined' ? '' : navigator.userAgent)?.[1] ?? '');
const compareYodaVersion = (version) => compareVersion(getPlatformVersion('Yoda'), version);
const compareKwaiAppVersion = (version) => compareVersion(getPlatformVersion('Kwai|ksNebula'), version);

const system = (() => {
    if (typeof navigator === 'undefined') {
        return 'unknown';
    }
    const { userAgent, maxTouchPoints } = navigator;
    if (/android/iu.test(userAgent)) {
        return 'Android';
    }
    if (/iPhone|iPad|iPod/u.test(userAgent) || userAgent.includes('Mac') && maxTouchPoints > 1) {
        return 'iOS';
    }
    return 'unknown';
})();
const isAndroid = system === 'Android';
const isIOS = system === 'iOS';
const isYoda = () => typeof window !== 'undefined' && typeof window.__yodaBridge__?.invoke === 'function';
const isApp = (app) => !!getPlatformVersion(app);
const isKwaiApp = isApp('Kwai|ksNebula');

const SafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;
let overflow = false;
let _callbackId = 1;
let _instanceId = genInstanceId();
/**
 * Ios 客户端目前会将 callbackId 处理为 number
 * 需要尽可能的保证生成的 _instanceId 与其他页面不会重复 & 不会超出 Number.MAX_SAFE_INTEGER
 * 3位随机数 + 9位时间戳 + 4位自增 id
 */
function genInstanceId() {
    const safeIntegerStr = `${SafeInteger}`;
    // 取 3 位随机数避免同一时刻出现重复 & 避免数字溢出
    const maxRandom = Number(safeIntegerStr.slice(0, 3)) - 100;
    const random = Math.floor(Math.random() * maxRandom);
    // 取 9 位时间戳，保证1周内不会重复
    const date = `${Date.now()}`;
    const dateStr = date.slice(date.length - 9);
    // 剩下的都作为自增 id
    const zero = new Array(safeIntegerStr.length - 12).fill(0)
        .join('');
    return Number(`${random}${dateStr}${zero}`);
}
function genCallbackId(dicData) {
    const id = genNextId(dicData);
    /*
     * 如果生成的 id 溢出了，从头开始
     * 页面中应该不会有这么多的回调
     */
    if (id >= SafeInteger) {
        overflow = true;
        _callbackId = 1;
        // 重新生成 insId 尽量减少重复的概率
        _instanceId = genInstanceId();
        return genCallbackId();
    }
    return id;
}
function genNextId(dicData) {
    let callbackId = _instanceId + _callbackId++;
    // 溢出后需要判断是否已经存在对应的 id
    while (overflow || dicData && dicData[callbackId]) {
        callbackId = _instanceId + _callbackId++;
    }
    return callbackId;
}
function getUUId(dicData) {
    return genCallbackId(dicData);
}

/**
 * 节流
 * @param fn 对象函数
 * @param wait 节流时间
 */
/**
 * 防抖
 * @param func
 * @param timeout
 * @returns
 */
function debounce(func, timeout = 300) {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(this, args);
        }, timeout);
    };
}

let yodaInstance = null;
function setYoda(yoda) {
    yodaInstance = yoda;
}
function getYoda() {
    return yodaInstance;
}

async function checkCanUse(namespace, name) {
    const yoda = getYoda();
    const checkReuslt = await yoda.bridge('tool', 'canIUse', {
        namespace,
        name,
    });
    return checkReuslt.result == '1' && checkReuslt.canUse;
}

const markStr$1 = 'too_performance_';
/**
 * 获取内部调用performance传递id
 * @returns id 字符串
 */
function getPerformanceId() {
    return markStr$1 + getUUId();
}
/**
 * 判断是否是performance的id
 * @param idStr 当前掉用id
 * @returns
 */
function isPerformanceId(callbackId) {
    return callbackId.startsWith(markStr$1);
}

const markStr = 'event_';
/**
 * 获取内部调用Event传递id
 * @returns id 字符串
 */
function getEventId(dicData) {
    return markStr + getUUId(dicData);
}
/**
 * 获取纯数字的id
 * @param idStr event id 字符串
 * @returns 纯数字字符
 */
function getEventIdOnlyNumber(idStr) {
    return idStr.replace(markStr, '');
}
/**
 * 获取添加了事件前缀的id
 * @param idNumber number id
 * @returns 完整id
 */
function getEventIdByNumber(idNumber) {
    return markStr + String(idNumber);
}
/**
 * 判断是否是Event的id
 * @param idStr 当前掉用id
 * @returns
 */
function isEventId(callbackId) {
    return callbackId.startsWith(markStr);
}

/*
 * Release 1.0.3-alpha.4
 * 日志缓存池
 */
const logArrayPool = [];
/*
 * https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=152981099
 * Native 上报bridge文档 @张赛
 */
/*
 * 使用一帧的时间间隔作为最小上报区间(ms)
 * native 侧，考虑bridge 耗时，暂定1s
 */
const logSessionMinTime = 1000 * 1;
// 防抖最多次数
const maxTime = 30;
var switchEnum;
(function (switchEnum) {
    switchEnum[switchEnum["unload"] = 0] = "unload";
    switchEnum[switchEnum["open"] = 1] = "open";
    switchEnum[switchEnum["close"] = 2] = "close";
})(switchEnum || (switchEnum = {}));
const isLocalBridge = (logParams) => 
/*
 * 将原本控制getApiList只记录一次的逻辑移除
 * 默认 canIUse 、getApiList  都是本地api
 */
['canIUse', 'getApiList'].includes(logParams.name);
let isSendLog = switchEnum.unload;
let getPageLoadDataPromise = null;
// 数据上报是否已经打开
const loggerSwitch = () => {
    if (getPageLoadDataPromise) {
        return getPageLoadDataPromise;
    }
    const { promise, resolve } = new Deferred();
    getPageLoadDataPromise = promise;
    if (isSendLog == switchEnum.unload) {
        // Window中有注入flag， 直接在window下读取
        if (window.__yodaCommonDataObject__?.sampleData) {
            if (typeof window.__yodaCommonDataObject__.sampleData === 'string') {
                try {
                    window.__yodaCommonDataObject__.sampleData =
                        JSON.parse(window.__yodaCommonDataObject__
                            .sampleData);
                }
                catch (e) {
                    window.__yodaCommonDataObject__.sampleData = {};
                }
            }
            isSendLog = window.__yodaCommonDataObject__.sampleData
                ?.bridgeHit
                ? switchEnum.open
                : switchEnum.close;
            resolve(isSendLog == switchEnum.open);
        }
        else {
            const yoda = getYoda();
            yoda.bridge('webview', 'getPageLoadData', {}, ({ result, sampleData }) => {
                if (result == 1) {
                    isSendLog = sampleData?.bridgeHit
                        ? switchEnum.open
                        : switchEnum.close;
                }
                else {
                    isSendLog = switchEnum.close;
                }
                resolve(isSendLog == switchEnum.open);
            });
        }
    }
    else {
        resolve(isSendLog == switchEnum.open);
    }
    return getPageLoadDataPromise;
};
function sendLog() {
    window.__yodaBridge__.invoke('tool', 'sendPerformanceLog', JSON.stringify({
        data: logArrayPool,
    }), getPerformanceId());
    logArrayPool.length = 0;
}
/**
 * 日志上报
 */
const _logger = debounce(() => {
    // Const yoda = this;
    sendLog();
}, logSessionMinTime);
const getLog = (logParams, dataNow, dateStr) => {
    const logData = {
        key: 'bridge',
        value: {},
        dimension: {
            api: logParams.name,
            namespace: logParams.namespace,
        },
        event_client_timestamp: dataNow,
        event_trigger_source: 'H5',
        task_identifier: logParams.callbackId,
        is_task_event: true,
        task_status: '', // START 代表此为一系列事件的起点 END
    };
    switch (logParams.type) {
        case 'invoke':
            logData.value.h5_invoke_bridge_time = dataNow;
            logData.task_status = 'START';
            if (typeof window.__yodaBridge__?.invoke !== 'function'
                || typeof window.webkit?.messageHandlers?.KMYYoda?.postMessage !== 'function') {
                logData.result = 126002;
                logData.error_msg = '';
            }
            break;
        case 'callback':
            logData.value.h5_receive_callback_time = dataNow;
            logData.value.h5_invoke_bridge_time = dateStr;
            logData.dimension.result_type = logParams.resultCode;
            logData.dimension.result_type
                && (logData.dimension.result_type =
                    logData.dimension.result_type.toString());
            logData.dimension.error_msg = logParams.errorMsg;
            logData.task_status = 'END';
            break;
        case 'event':
            logData.task_status = 'SUCCESS';
            delete logData.dimension.api;
            delete logData.dimension.namespace;
            logData.dimension.event = '';
            break;
    }
    return logData;
};
const logger = (logParams, dateStr) => {
    /*
     * 当前只在 >= 9.7.40 才会生效
     * if (compareVersion(appVersion, '9.7.40') > 0) return;
     */
    /*
     * 限制特定 bridge 和 前端 bridge 的阻止上报
     * getApiList  只上报一次
     * canIUse 不上报
     */
    if (isLocalBridge(logParams)) {
        return;
    }
    const nowDate = Date.now().toString();
    loggerSwitch().then(switchFlag => {
        if (!switchFlag) {
            return;
        }
        logArrayPool.push(getLog(logParams, nowDate, dateStr));
        // 防止出现大数据提交造成的crash,强制推送
        if (logArrayPool.length >= maxTime) {
            sendLog();
        }
        else {
            _logger();
        }
    });
    return nowDate;
};

function createSingleDeferred(cb) {
    let resolve = null;
    let promise = new Promise(r => {
        resolve = r;
    });
    if (cb) {
        promise = promise.then(cb, cb);
    }
    return {
        isMulti: false,
        resolve: resolve,
        promise,
    };
}
function createMultiDeferred(cb) {
    /*
     * 多次调用模式下，promise
     * 只是兼容当前调用方式
     * TODO 文档中需要特殊说明
     */
    const promise = new Promise(() => { });
    return {
        isMulti: true,
        resolve: cb,
        promise,
    };
}
const invokeMap = {};
const deferredInvoke = {
    pushMQ(isMulti = false, callBackFn, isEvent = false) {
        const id = isEvent ? getEventId() : getUUId(invokeMap);
        const deferred = isMulti
            ? createMultiDeferred(callBackFn)
            : createSingleDeferred(callBackFn);
        deferred.traceId = String(id);
        invokeMap[id] = deferred;
        return deferred;
    },
    removeMQ(callbackId) {
        invokeMap[callbackId] = undefined;
    },
    create(namespace, name, isMulti = false, callBackFn) {
        const deferred = this.pushMQ(isMulti, callBackFn);
        deferred.namespace = namespace;
        deferred.name = name;
        // 创建
        const startTimeStr = logger({
            namespace,
            name,
            type: 'invoke',
            callbackId: deferred.traceId,
        });
        invokeMap[deferred.traceId].startTime = startTimeStr;
        return {
            id: deferred.traceId,
            promise: deferred.promise,
        };
    },
    resolve(id, data) {
        if (isPerformanceId(id)) {
            return;
        }
        const deferred = invokeMap[id];
        if (!deferred) {
            /*
             * 创建
             * return console.warn('native callback error:', data);
             */
            return;
        }
        deferred.resolve(data);
        // 设置成为undefined保证不内存泄露，不用delete是防止回退字典模式
        if (!deferred.isMulti) {
            this.removeMQ(id);
        }
        if (isEventId(id)) {
            return;
        }
        // 发送回调成功日志
        logger({
            namespace: deferred.namespace,
            name: deferred.name,
            type: 'callback',
            callbackId: deferred.traceId,
            resultCode: data.result,
        }, deferred.startTime);
    },
    reject(id, reason) {
        const deferred = invokeMap[id];
        if (!deferred) {
            /*
             * 若无对应调用，不做处理，稍后增加 log
             * return console.warn('native callback error:', reason);
             */
            return;
        }
        // 以异常信息回调正常业务也逻辑
        deferred.resolve(reason);
        // 设置成为undefined保证不内存泄露，不用delete是防止回退字典模式
        if (!deferred.isMulti) {
            this.removeMQ(id);
        }
        // 由于事件的回调result!=1,导致会使事件的回调会走到reject 中
        if (isEventId(id)) {
            return;
        }
        // 发送回调成功日志
        logger({
            namespace: deferred.namespace,
            name: deferred.name,
            type: 'callback',
            callbackId: deferred.traceId,
            resultCode: reason.result,
            errorMsg: reason.message,
        }, deferred.startTime);
    },
};

// 针对 bridge 回调做了一些分类，后续如果有其他类型的 bridge 需要特殊处理再新增分类即可
const BRIDGE_TYPE = {
    noCallbackList: ['popBack', 'exitWebView'],
    onClickList: [
        'setPhysicalBackButton',
        'setTopLeftBtn',
        'setTopLeftSecondBtn',
        'setTopRightBtn',
        'setTopRightSecondBtn',
    ],
    handlerList: ['on', 'off'],
};
const NAMESPACE_2_GLOBALVAR = {
    kwai: 'Kwai',
    kwaiAd: 'KwaiAd',
    kwaiAdThird: 'KwaiAdThird',
    kwaiMerchant: 'KwaiMerchant',
    kwaiLive: 'KwaiLive',
    // 以防使用大写 namespace 进行调用，大写的映射关系也加上
    Kwai: 'Kwai',
    KwaiAd: 'KwaiAd',
    KwaiAdThird: 'KwaiAdThird',
    KwaiMerchant: 'KwaiMerchant',
    KwaiLive: 'KwaiLive',
};

const { noCallbackList, onClickList, handlerList } = BRIDGE_TYPE;
/**
 *
 * 生成唯一的id
 * @export
 * @returns
 */
function generateUUID(rc = true) {
    // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523
    let d = new Date().getTime();
    if (typeof performance !== 'undefined'
        && typeof performance.now === 'function') {
        d += performance.now(); // Use high-precision timer if available
    }
    const pattern = rc
        ? 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
        : 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
    return pattern.replace(/[xy]/g, c => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
}
/**
 *
 * 生成临时唯一的方法挂接到window上，给客户端回调用
 * @name generateUUCallbackFunction
 * @private
 * @param {function} callback 回调函数，客户端方法执行完后会执行该方法
 * @param {boolean} notDelete 是否删除当前回调，留在当前页面的内存中
 * @param {string} bridge 的命名空间和方法名，方便后续问题排查
 * @param {string} 回调方法对应的唯一ID
 * @returns
 */
function generateUUCallbackFunction(callback, notDelete, callbackName) {
    const callbackId = generateUUID(false);
    const name = `yoda_kuaishou_plugin_callback_${callbackName}_${callbackId}`;
    window[name] = function (data) {
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            }
            catch (e) {
                console.warn(e); // eslint-disable-line
            }
        }
        if (isFunction(callback)) {
            callback.call(window, data);
        }
        else if (typeof callback === 'string'
            && isFunction(window[callback])) {
            window[callback].call(window, data);
        }
        if (!notDelete) {
            delete window[name];
        }
    };
    return name;
}
// 用于 showDialog 相关 api 中，将回调转化成接口需要的 URL
function transformFuncToURL(btn, callbackName) {
    const tmpBtn = btn;
    if (btn && Array.isArray(btn.actions)) {
        tmpBtn.actions = btn.actions.map((action) => {
            if (action && action.url && isFunction(action.url)) {
                action.url = generateUUCallbackFunction(action.url, true, callbackName);
            }
            return action;
        });
    }
    return tmpBtn;
}
const handlerCbMap = {};
// 事件相关 api 中处理 handler
function generateHandlerFunction(callback, bridge) {
    let handlerName = '';
    let cb = null;
    Object.keys(handlerCbMap).some((cbName) => {
        const handlerCb = handlerCbMap[cbName];
        if (handlerCb === callback) {
            cb = handlerCb;
            handlerName = cbName;
            return true;
        }
        return false;
    });
    // 当传递的 handler 回调之前已经挂载过，就不再重新挂载，重新生成 handler 回调名
    if (cb !== callback && callback) {
        const name = generateUUCallbackFunction(callback, true, bridge);
        handlerCbMap[name] = callback;
        handlerName = name;
    }
    return handlerName;
}
/**
 * Bridge 调用参数预处理，针对几类特定 bridge 进行处理
 * @name bridgeParamsHandler
 * @private
 * @param {string} namespace 命名空间
 * @param {string} bridge 桥名
 * @param {Object} 调用参数
 * @param {function} bridge 本身调用的回调
 */
function bridgeParamsHandler(namespace, bridgeName, params, invokeCallback) {
    let handledParams = { ...params };
    const callbackName = `${namespace}_${bridgeName}`;
    /*
     * 特殊适配 Kwai 等命名空间下 bridge 回调的传递
     * 回调为 onClick 形式的
     */
    if (onClickList.includes(bridgeName)) {
        handledParams.onClick = generateUUCallbackFunction(handledParams.onClick, true, callbackName);
        // 不允许传递任何参数给 native 的
    }
    else if (noCallbackList.includes(bridgeName)) {
        handledParams = null;
        // 事件类传 handler 的
    }
    else if (handlerList.includes(bridgeName)) {
        const callbackUUid = generateUUCallbackFunction(invokeCallback, false, callbackName);
        // 调用 off 桥不传 handler 时，则不能传再对其进行处理
        if (handledParams.handler && isFunction(handledParams.handler)) {
            handledParams.handler = generateHandlerFunction(handledParams.handler, callbackName);
        }
        handledParams.callback = callbackUUid;
        // ShowDialog
    }
    else if (bridgeName === 'showDialog') {
        const { positiveButton, negativeButton, neutralButton } = handledParams;
        if (positiveButton) {
            handledParams.positiveButton = transformFuncToURL(positiveButton, callbackName);
        }
        if (negativeButton) {
            handledParams.negativeButton = transformFuncToURL(negativeButton, callbackName);
        }
        if (neutralButton) {
            handledParams.neutralButton = transformFuncToURL(neutralButton, callbackName);
        }
        // 其他默认都是通过 callback 传给 native
    }
    else if (Object.keys(NAMESPACE_2_GLOBALVAR).includes(namespace)) {
        const callbackUUid = generateUUCallbackFunction(invokeCallback, true, callbackName);
        handledParams.callback = handledParams.callback || callbackUUid;
    }
    return handledParams;
}

const getMultiInstanceError = () => new Error('当前环境存在 Yoda 多实例问题，详细请参考 https://docs.corp.kuaishou.com/k/home/VbQx2ulc6v3M/fcADLOKqHyHpSr7hiCKKQVtVM');
const setupMultiInstanceGuard = () => {
    let { __yodaBridgeCallback__ } = window;
    if (typeof __yodaBridgeCallback__ === 'function') {
        throw getMultiInstanceError();
    }
    Object.defineProperty(window, '__yodaBridgeCallback__', {
        get() {
            return __yodaBridgeCallback__;
        },
        set(value) {
            if (__yodaBridgeCallback__) {
                throw getMultiInstanceError();
            }
            __yodaBridgeCallback__ = value;
        },
    });
};

let currentMode = 'production';
const getCurrentMode = () => currentMode;
const setCurrentMode = (mode) => {
    currentMode = mode;
};

const loggerMethods = [
    'debug',
    'info',
    'log',
    'warn',
    'error',
];
const createLogger = (implFor) => Object.fromEntries(loggerMethods.map(method => [
    method,
    implFor(method),
]));
const print = (context, method, ...data) => {
    if (getCurrentMode() === 'production') {
        return;
    }
    // eslint-disable-next-line no-console
    console[method](`[${context}]`, ...data);
};

const console$1 = createLogger(method => (...data) => print('@yoda/bridge', method, ...data));

const invoke$1 = async (invokeConfig) => {
    const { namespace, name, params, multiCallback, callback } = invokeConfig;
    const ns = NAMESPACE_2_GLOBALVAR[namespace];
    const { id, promise } = deferredInvoke.create(namespace, name, multiCallback, callback);
    // TODO 确定逻辑后处理 临时添加 活动 namespace
    // if (ns || addCbParamsBridges.includes(name) || namespace == 'sf2022') {
    // 实际调用前需要将 register 中改写的 namespace 改回来
    const originalNamespace = ns || namespace;
    const _invokeCallback = (res) => {
        invokeCallback(id, res);
    };
    invokeConfig.namespace = originalNamespace === 'Kwai'
        && typeof navigator !== 'undefined'
        && navigator.userAgent.includes('livemate/') ? 'livemate' : originalNamespace;
    // 参数预处理
    invokeConfig.params = bridgeParamsHandler(originalNamespace, name, params, _invokeCallback) ?? {};
    /*
     * 比较版本号
     * 7730 以上版本不需要做兼容处理
     * 兼容方式注册的桥，双端只关注 params.callback，yoda 方式注册的桥只关注 invoke callbackId
     * if (appVersion && compareVersion(appVersion, '7.7.30') < 0) {
     * 在 js-sdk 层将桥调用的回调方法转到 params 后，需要将 callbackId 重置下
     * 主要处理部分只回调一次的桥（回调执行一次后会被 delete），如果 params.callback 和 invokeCallback 指向一个回调
     * 可能会导致 params.callback 还未执行，回调已被 delete
     * 临时回调函数只在这个地方有声明，原sdk、plugin 并未 指定该 callback
     * const tmpCbKey = '__yoda_kuaishou_plugin_tmp_cb__';
     * yoda._callbacks[tmpCbKey] = yoda._callbacks[tmpCbKey] || noop;
     * invokeConfig.callbackId = tmpCbKey;
     * 需要额外挂到 window 上是因为 iOS 可能会去 window 上找该回调
     *     window.__yoda_kuaishou_plugin_tmp_cb__ = noop;
     * }
     */
    // }
    console$1.info(`Invoking '${invokeConfig.namespace}.${invokeConfig.name}'`, invokeConfig.params);
    if (isIOS && !window.webkit && compareYodaVersion('2.10.9.2') < 0) {
        return promise;
    }
    window.__yodaBridge__.invoke(invokeConfig.namespace, invokeConfig.name, JSON.stringify(invokeConfig.params), String(id));
    return promise;
};
const invokeCallback = (id, res) => {
    if (isIOS && compareYodaVersion('2.3.7') < 0) {
        // 以前 Yoda iOS 回调时插值表达式写错了，导致这里的 id 类型是 number
        // eslint-disable-next-line no-param-reassign
        id = `${id}`;
    }
    const data = typeof res === 'string' ? JSON.parse(res) : res;
    if (data?.result === 1) {
        deferredInvoke.resolve(id, data);
    }
    else {
        deferredInvoke.reject(id, data);
    }
};
if (typeof window !== 'undefined') {
    // 开启守卫
    setupMultiInstanceGuard();
    // 挂载接收 native 回调事件
    window.__yodaBridgeCallback__ = invokeCallback;
}

const apiSet = new Set();
const invokeAndroid9920 = async (callData) => {
    const { namespace, name, params, multiCallback, callback } = callData;
    if (!apiSet.size) {
        const apiListRes = await invoke$1({
            namespace: 'tool',
            name: 'getApiList',
            params: {},
        });
        if (apiListRes.result === 1 && Array.isArray(apiListRes.apiList)) {
            apiListRes.apiList.forEach(({ namespace, name }) => apiSet.add(`${namespace}.${name}`));
        }
    }
    const canUse = apiSet.has(`${NAMESPACE_2_GLOBALVAR[namespace] ?? namespace}.${name}`);
    return new Promise(resolve => {
        if (canUse) {
            void invoke$1({
                namespace,
                name,
                params,
                multiCallback,
                callback,
            }).then(resolve);
        }
        else {
            const result404 = { result: 125004 };
            callback?.(result404);
            resolve(result404);
        }
    });
};

let currentContainer = null;
const assertsContainer = container => {
    if ((process.env.NODE_ENV !== "production")) {
        if (!container) {
            throw new Error('[@yoda/bridge] This error is caused by a bug');
        }
    }
};
const getContainer = () => {
    assertsContainer(currentContainer);
    return currentContainer;
};
const setContainer = (container) => {
    currentContainer = container;
};

const getContext = ({ initialBridge, initialParams, }) => ({
    bridge: initialBridge,
    params: initialParams,
});
class BridgeError extends Error {
    constructor(message, code, config) {
        super(message);
        this.name = 'BridgeError';
        this.message = message;
        this.code = code;
        this.context = getContext(config);
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            context: this.context,
        };
    }
}
const isBridgeError = (err) => err instanceof BridgeError;

const getLocation = async ({ useLastLocationWhileLimited = false, ...params }) => {
    const { invoke } = getContainer();
    if (compareKwaiAppVersion('10.1.30') < 0) {
        // eslint-disable-next-line camelcase
        const { biz: biz_type, force, statKey, alertScene, updateLocationScene, ...restParams } = params;
        // eslint-disable-next-line camelcase
        const forced_permission_request = (() => {
            if (typeof force === 'undefined') {
                return 2;
            }
            return force ? 1 : 3;
        })();
        const legacyParams = {
            ...restParams,
            // eslint-disable-next-line camelcase
            biz_type,
            // eslint-disable-next-line camelcase
            forced_permission_request,
        };
        try {
            const { data: { longitude, latitude, }, } = await invoke('kwai.syncLocationWithPermissionCheck', {
                ...legacyParams,
                // eslint-disable-next-line camelcase
                forced_permission_request: 3,
            });
            return {
                longitude,
                latitude,
            };
        }
        catch { }
        await invoke('kwai.requestLocationPermissionWithPermissionCheck', legacyParams);
        const { data: { longitude, latitude, }, } = await invoke('kwai.syncLocationWithPermissionCheck', legacyParams);
        return {
            longitude,
            latitude,
        };
    }
    if (isAndroid && compareKwaiAppVersion('10.3.30') < 0) {
        const { updateLocationScene = '' } = params;
        Object.assign(params, {
            useInterval: !updateLocationScene,
        });
    }
    try {
        const { longitude, latitude } = await invoke('system.requestLocation', params);
        return {
            longitude,
            latitude,
        };
    }
    catch (err) {
        if (!isBridgeError(err)) {
            throw err;
        }
        if (err.code === 10014 && useLastLocationWhileLimited) {
            const { longitude, latitude } = await invoke('system.getLocationCityInfo', { biz: params.biz });
            if (typeof longitude === 'number' && typeof latitude === 'number') {
                return {
                    longitude,
                    latitude,
                };
            }
        }
        throw err;
    }
};

const apis = {
    getLocation,
};

const bridgeToLegacyKwaiBridge = Object.fromEntries(Object.entries({
    advertise: ['startFansTopLivePlay', 'startNeoAdVideo'],
    feed: [
        'authorizationStatusForCalendar',
        'changeEventForCalendar',
        'closeChildLock',
        'getAddressBookAccessStatus',
        'getCoronaTvChasingData',
        'getFeed',
        'openDetailPage',
        'openFansGroup',
        'setSettingEntryForCourse',
        'startPlayLongVideo',
        'updateDeviceBit',
        'updateUserRecoBit',
        'updateWeatherInfo',
        'userIncentivesUpdateTasks',
    ],
    game: [
        'addShortcutToDesktop',
        'appointGame',
        'changeAppointStatus',
        'gameSendLog',
        'gameTaskSelectImage',
        'getAppointStatus',
        'getWebViewDisplayType',
        'kgPageDidShowed',
        'openNativeGamecenter',
    ],
    growth: ['getDeviceSecretInfo', 'unionPhoneNumber'],
    im: ['setEnableIMTip'],
    live: [
        'deleteSubscribe',
        'liveReservationNotification',
        'openLiveQuizLive',
        'showSubscribeEditDialog',
        'showSubscribeSelectPhotoDialog',
        'subscribeLive',
        'unsubscribeLive',
    ],
    merchant: [
        'closeLiveMerchantFloatingWindow',
        'getLatestImage',
        'getSidToken',
        'loadUrlOnNewMerchantPage',
        'merchantSetPhotoPlayStatus',
        'onItemSelected',
        'popupToFollow',
        'querySessionIsStickyOnTop',
        'reqSessionStickyOnTopWithThread',
        'requestLocationAuthorization',
    ],
    minigame: ['publishSogameVideo'],
    pay: [
        'authThirdPartyAccount',
        'bindWithdrawType',
        'couponPay',
        'hasImportSdk',
        'nebulaStartGatewayWithdraw',
        'openKspayWebView',
        'sfBindWithdrawType',
        'startDeposit',
        'startGatewayPay',
        'startGatewayWithdraw',
        'startHalfScreenRecharge',
        'startKspayOrderPrepay',
    ],
    platform: [
        'getDarkMode',
        'openWechatMiniProgram',
        'sendSMS',
        'startFaceRecognition',
    ],
    post: [
        'cancelJsInjectUpload',
        'captureCertVideo',
        'deleteCacheVideoByPhotoId',
        'editAtlas',
        'editDraft',
        'editSmartAlbum',
        'getEditDraftData',
        'getSmartAlbumData',
        'getVideoUploadStatus',
        'intownShare',
        'postAtlas',
        'postVideo',
        'preloadMagicFace',
        'previewVideo',
        'reUploadShopVideo',
        'reeditPhoto',
        'resumeVideoUpload',
        'retryJsInjectUpload',
        'saveImage',
        'saveTempImages',
        'selectAndUploadMedia',
        'selectImage',
        'selectMixMediasAndUpload',
        'selectVideoAndUpload',
        'startAudioRecord',
        'uploadCertVideo',
        'uploadShopVideo',
        'uploadVideoFromAlbum',
        'verifyLiveUser',
    ],
    social: [
        'addTokenBlockShareId',
        'bindPhone',
        'bindRiskPreCheck',
        'decryptContactsName',
        'enterGroupChat',
        'followUser',
        'joinGroup',
        'login',
        'logout',
        'mobileQuickAuthInfo',
        'mobileQuickLoginInfo',
        'needUpdateProfile',
        'requestFollowUserV2',
        'selectCountryPhoneCode',
        'sendIMMessage',
        'sendImFriendMessage',
        'setPageFollowRefer',
        'setShareTokenToClipBoard',
        'share',
        'startAuthActivity',
        'verifyAccount',
        'verifySMSCode',
        'verifyThirdPartyLogin',
        'wechatLogin',
    ],
    system: [
        'collapseKeyboard',
        'getPushPermission',
        'getServerTime',
        'gete2',
        'openPushPermission',
    ],
    tool: [
        'getClipBoard',
        'getExpTagTransList',
        'loadUrlOnNewPage',
        'openBrowser',
        'scanCode',
    ],
    ui: [
        'selectCity',
        'showBottomSheet',
        'showPicker',
    ],
    webview: [
        'clearClipBoard',
        'exitWebView',
        'getABTest',
        'getAppEnvironment',
        'getDeviceInfo',
        'hasInstalledApp',
        'hideNavigationBar',
        'popBack',
        'resetTopButtons',
        'setClipBoard',
        'setPageTitle',
        'setSlideBack',
        'setTopLeftBtn',
        'setTopLeftSecondBtn',
        'setTopRightBtn',
        'setTopRightSecondBtn',
        'submitData',
    ],
}).flatMap(([namespace, names]) => names.map(name => [
    `${namespace}.${name}`,
    `kwai.${name}`,
])));
const invalidResultBridges = [
    'social.currentUserInfo',
    'post.draftRecommendPhotos',
    'post.draftRecommendPublishPhotos',
    'kwai.KSVerifyRealNameInfo',
    'kwai.verifyRealNameInfo',
    'component.aliyunVerifyRealNameInfo',
    'component.verifyRealNameInfo',
];
const multipleCallbacksBridges = [
    'component.download',
    'kwai.download',
    'kwai.downloadThirdPartyAPP',
    'kwai.startNFC',
    'kwaiAd.callAdBridge',
    'kwaiAd.callCardHandler',
    'pay.startHalfScreenRecharge',
    'post.postVideo',
    'post.reUploadShopVideo',
    'post.selectImage',
    'post.uploadShopVideo',
    'post.selectMixMediasAndUpload',
    'kwaiLive.subscribeChannel',
];
const multipleCallbacksBridgeSet = new Set(multipleCallbacksBridges);
const useCallbackBridgeSet = new Set([...invalidResultBridges, ...multipleCallbacksBridges]);

const version = "2.0.7";

const globalConfig = {
    get mode() {
        return getCurrentMode();
    },
    set mode(mode) {
        setCurrentMode(mode);
        console$1.info(`You're currently running version ${version} in ${mode} mode.`);
    },
};
const setGlobalConfig = (nextGlobalConfig) => {
    Object.assign(globalConfig, nextGlobalConfig);
};

const transformConfig = (config) => {
    const transformers = [];
    const setLegacyBridge = (bridgeToLegacyBridge) => {
        transformers.push(config => {
            const legacyBridge = bridgeToLegacyBridge[config.bridge];
            if (typeof legacyBridge === 'undefined') {
                return config;
            }
            return {
                ...config,
                bridge: legacyBridge,
            };
        });
    };
    const setDefaultParams = (bridgeToDefaultParams) => {
        transformers.push((config) => {
            const defaultParams = bridgeToDefaultParams[config.bridge];
            if (typeof defaultParams === 'undefined') {
                return config;
            }
            const params = {
                ...defaultParams,
                ...config.params,
            };
            return {
                ...config,
                params,
            };
        });
    };
    if (config.bridge === 'tool.checkAppInstalled') {
        setDefaultParams({
            [config.bridge]: { identifier: config.params[isAndroid ? 'android' : 'ios'] },
        });
    }
    if (isIOS && compareKwaiAppVersion('9.10.11') >= 0) {
        setLegacyBridge({
            'hybrid.getHybridStatus': 'webview.pageContentStatus',
            'hybrid.getAndUpdateHybridDetail': 'webview.pageContentInfo',
            'hybrid.preloadVideoList': 'media.pvList',
            'hybrid.isVideoFullyCached': 'media.vReady',
        });
    }
    if (isIOS && compareKwaiAppVersion('11.1.40') < 0) {
        setLegacyBridge({
            'advertise.startNeoAdVideo': 'kwai.startNeoAdVideo',
        });
    }
    if (isIOS && compareKwaiAppVersion('10.7.20') < 0) {
        setLegacyBridge({
            'merchant.getSidToken': 'kwai.getSidToken',
        });
    }
    if (isAndroid && compareKwaiAppVersion('10.6.50') < 0) {
        setLegacyBridge({
            'ui.setStatusBarStyle': 'kwai.setStatusBarStyle',
        });
    }
    if (compareKwaiAppVersion('10.4.30') < 0 || !isKwaiApp) {
        setLegacyBridge(bridgeToLegacyKwaiBridge);
    }
    if (isIOS && compareKwaiAppVersion('10.4.10') < 0) {
        setDefaultParams({
            'system.startVibrate': {
                strength: 'low',
                duration: 300,
            },
        });
    }
    if (compareKwaiAppVersion('10.3.20') < 0 || !isKwaiApp) {
        setLegacyBridge({
            'webview.exitCurrentWebView': `kwai.${isIOS ? 'exitCurrentWebview' : 'exitWebView'}`,
        });
    }
    if (compareKwaiAppVersion('9.6.20') < 0) {
        transformers.push(config => {
            const { bridge } = config;
            if (![
                'syncLocationWithPermissionCheck',
                'getLocationWithPermissionCheck',
                'requestLocationPermissionWithPermissionCheck',
            ].some(name => bridge.endsWith(name))) {
                return config;
            }
            return {
                ...config,
                bridge: bridge.replace('WithPermissionCheck', ''),
            };
        });
    }
    return transformers.reduce((config, transformer) => transformer(config), config);
};

const getInvocationConfig = (args) => {
    const [bridge, params = {}, optionsOrCallback] = args;
    const [options, callback] = typeof optionsOrCallback === 'function'
        ? [{}, optionsOrCallback]
        : [optionsOrCallback ?? {}];
    return {
        initialBridge: bridge,
        initialParams: params,
        bridge,
        params,
        options,
        callback,
    };
};
const getLegacyErrorMessage = (response) => hasOwnProperty(response, 'error_msg') && typeof response.error_msg === 'string' ? response.error_msg : '';
const isIntrinsicAPI = (config) => config.bridge.startsWith('yoda.');
const invokeAPI = (config) => {
    const { bridge, params } = config;
    const [, name] = bridge.split('.');
    const api = apis[name];
    return api(params);
};
const invokeBridge = (config) => {
    const yoda = getYoda();
    const { initialBridge, bridge, params, callback } = config;
    const [namespace, name] = bridge.split('.');
    if (useCallbackBridgeSet.has(initialBridge)) {
        void yoda.bridge(namespace, name, params, (response) => {
            console$1.info(`Received a response from '${bridge}'`, response);
            callback?.(response);
        }, multipleCallbacksBridgeSet.has(initialBridge));
        return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
        void yoda.bridge(namespace, name, params, (response) => {
            console$1.info(`Received a response from '${bridge}'`, response);
            if (response.result === 1) {
                const { result, ...data } = response;
                resolve(data);
                return;
            }
            const { message = getLegacyErrorMessage(response) } = response;
            const bridgeError = new BridgeError(message, response.result, config);
            globalConfig.errorHandler?.(bridgeError);
            reject(bridgeError);
        });
    });
};
const invoke = async (...args) => {
    try {
        const initialConfig = getInvocationConfig(args);
        if (!isYoda()) {
            throw new BridgeError([
                'Cannot invoke bridge',
                ...process.env.NODE_ENV === 'production' ? [] : [`'${initialConfig.bridge}'`],
                'in non-Yoda environment.',
            ].join(' '), 125014, initialConfig);
        }
        const config = transformConfig(initialConfig);
        const { options: { timeout = globalConfig.timeout ?? 0 } } = config;
        const baseInvoking = (isIntrinsicAPI(config)
            ? invokeAPI(config)
            : invokeBridge(config));
        const data = timeout > 0 && Number.isFinite(timeout)
            ? await Promise.race([
                baseInvoking,
                delay(timeout).then(() => Promise.reject(new BridgeError('Bridge invocation timed out.', 125010, config))),
            ])
            : await baseInvoking;
        return data;
    }
    catch (err) {
        if (isBridgeError(err)) {
            globalConfig.errorHandler?.(err);
        }
        throw err;
    }
};

const legacyEventTypes = new Set([
    // page lifecycle
    'native_visible',
    'native_background',
    'native_foreground',
    // IOS only
    'native_will_leave',
    'native_leave',
    'native_reentry',
    // page load event
    'native_loadPage',
    'native_pageFinished',
    // login
    'native_userDidLogin',
    'native_userDidLogout',
    // network
    'native_networkChanged',
    // screenshot
    'native_screenshot_event',
    'native_web_view_display_mode_changed',
    'native_share_dialog_event',
    'native_shake',
    // dark mode
    'native_darkModeChange',
    /*
     * physical-back-button
     * Android only
     */
    'physical-back-button',
]);
const addListener$1 = async (type, listener, options) => {
    if (legacyEventTypes.has(type)) {
        await invoke('kwai.on', {
            type,
            handler: listener,
        });
        return;
    }
    await invoke('event.addEventListener', {
        /**
         * 1. 重构事件机制
         * 2. 重构摇一摇事件
         */
        type: typeof options?.data === 'undefined'
            ? type
            : {
                type,
                options: options.data,
            },
        listener,
    });
};
const removeListener$1 = async (type, listener) => {
    if (legacyEventTypes.has(type)) {
        await invoke('kwai.off', {
            type,
            handler: listener,
        });
        return;
    }
    await invoke('event.removeEventListener', {
        type,
        listener,
    });
};

const eventMQ = {};
function addListener(typeStr, listener, callbackId) {
    const targetTypeListener = eventMQ[typeStr] || {
        callbackId,
        eventRecord: {},
    };
    const id = getUUId();
    listener.__yodaCallbackId__[typeStr] = String(id);
    targetTypeListener.eventRecord[id] = listener;
    eventMQ[typeStr] = targetTypeListener;
}
function createCb(type) {
    return function (ret) {
        const targetTypeListener = eventMQ[type];
        Object.keys(targetTypeListener?.eventRecord || {}).forEach((key) => targetTypeListener.eventRecord[Number(key)](JSON.parse(JSON.stringify(ret))));
    };
}
function getCallbackIdByType(type) {
    const targetTypeListener = eventMQ[type];
    return getEventIdByNumber(targetTypeListener.callbackId);
}
function removeListener(typeStr, listener) {
    const targetTypeListener = eventMQ[typeStr];
    const callbackId = listener.__yodaCallbackId__[typeStr];
    delete targetTypeListener.eventRecord[Number(callbackId)];
    delete listener.__yodaCallbackId__[typeStr];
    /*
     * 如果当前不存在监听事件，完全有移除
     * 有新监听，则重建监听对象，防止callbackid 异常
     */
    if (!hasListener(typeStr)) {
        delete eventMQ[typeStr];
    }
}
function hasListener(typeStr) {
    const targetTypeListener = eventMQ[typeStr];
    return Object.keys(targetTypeListener?.eventRecord || {}).length > 0;
}

var Direction;
(function (Direction) {
    Direction["x"] = "x";
    Direction["y"] = "y";
    Direction["z"] = "z";
})(Direction || (Direction = {}));

const SHAKE_EVENT = 'shaked';
const SHAKE_START_EVENT = 'shake-start';
const SHAKE_END_EVENT = 'shake-end';
const JUDGE_STOP_TIME = 1000;
const DEFAULT_SETTING = {
    level: 2,
    times: 3,
    intervalTime: 1300,
    iOSIntervalTime: 500,
    androidIntervalTime: 1300,
    isEmitImmediately: true,
};
const ANDROID_LEVEL_MAP = {
    1: {
        basic: 13,
        total: 450,
    },
    2: {
        basic: 16,
        total: 700,
    },
    3: {
        basic: 20,
        total: 1100,
    },
};
const IOS_LEVEL_MAP = {
    1: {
        basic: 9,
        total: 220,
    },
    2: {
        basic: 12,
        total: 400,
    },
    3: {
        basic: 14,
        total: 500,
    },
};

class ShakeHandler {
    constructor(props) {
        this.shakeConfig = {};
        this.shakedArr = [];
        this.isChecking = false;
        this.nowStatus = {
            x: 0,
            y: 0,
            z: 0,
        };
        this.lastStatus = {
            x: 0,
            y: 0,
            z: 0,
        };
        this.stopMark = null;
        this.checkIsShakeStoped = false;
        this.notEmitButShaked = true;
        this.isShakeStarted = false;
        this.isAndroid = false;
        this.isArrivedConfigStandard = false;
        this.levelMap = ANDROID_LEVEL_MAP;
        this.dispatchEvent = null;
        this.setStillShaking = debounce(() => this.notShaking(), JUDGE_STOP_TIME);
        this.dispatchEvent = props.dispatchEvent;
        this.isAndroid = props.isAndroid;
        this.levelMap = this.isAndroid ? ANDROID_LEVEL_MAP : IOS_LEVEL_MAP;
    }
    setOptions(options) {
        if (options) {
            this.shakeConfig = {
                ...DEFAULT_SETTING,
                ...options,
            };
            // IOS 和 Android重力感应的灵敏度等都不太一样，数值分端调试，并在次数上允许小量误差
            this.shakeConfig.times = this.isAndroid ? this.shakeConfig.times - 1 : (this.shakeConfig.times - 1) * 2;
            this.shakeConfig.intervalTime = this.isAndroid
                ? this.shakeConfig.androidIntervalTime
                : this.shakeConfig.iOSIntervalTime;
        }
        else {
            this.shakeConfig = { ...DEFAULT_SETTING };
        }
    }
    resetShakeStatus(isStoped) {
        this.shakedArr = [];
        this.isChecking = false;
        this.notEmitButShaked = false;
        if (isStoped) {
            this.isArrivedConfigStandard = false;
            this.isShakeStarted = false;
        }
    }
    checkIsShake(result) {
        this.isChecking = true;
        Object.keys(this.nowStatus).forEach((key) => this.nowStatus[key] = result[key] * 9.8);
        if (this.judgeArrivedTerminal()) {
            this.lastStatus = {
                x: 0,
                y: 0,
                z: 0,
            };
            this.handleShakeHappend();
            this.setStillShaking();
            this.isChecking = false;
            return;
        }
        if (this.judgeLikelyShake()) {
            this.handleArrivedStandard();
        }
        else {
            this.isChecking = false;
        }
    }
    judgeLikelyShake() {
        const { x, y, z } = this.nowStatus;
        const { basic, total } = this.levelMap[this.shakeConfig.level];
        return x > basic || y > basic || z > basic || x * x + y * y + z * z > total;
    }
    // 用加速度变化最大的方向作为判断依据，确认加速度是否反向，从而判定是否到达一次摇动的端点
    judgeArrivedTerminal() {
        let maxDiffVal = 0;
        let diffVal = 0;
        let toJudgeKey = Direction.x;
        // 获取加速度变化最大的方向
        Object.keys(this.nowStatus).forEach((key) => {
            diffVal = Math.abs(this.lastStatus[key] - this.nowStatus[key]);
            if (maxDiffVal < diffVal) {
                toJudgeKey = key;
                maxDiffVal = diffVal;
            }
        });
        if (this.lastStatus[toJudgeKey] * this.nowStatus[toJudgeKey] < 0) {
            return true;
        }
        return false;
    }
    handleArrivedStandard() {
        this.lastStatus = { ...this.nowStatus };
        this.checkIsShakeStoped = false;
        this.setStillShaking();
    }
    async handleShakeHappend() {
        if (!this.isShakeStarted) {
            await this.dispatchEvent({
                type: SHAKE_START_EVENT,
                data: {},
            });
        }
        this.isShakeStarted = true;
        this.updateShakedArr(new Date().getTime());
    }
    notShaking() {
        this.checkIsShakeStoped = true;
        this.checkDoDelayEmit();
    }
    updateShakedArr(newTimeStamp) {
        const { intervalTime } = this.shakeConfig;
        if (this.shakedArr.length > 0) {
            if (newTimeStamp - this.shakedArr[this.shakedArr.length - 1] <= intervalTime) {
                this.shakedArr.push(newTimeStamp);
            }
            else {
                this.shakedArr = [];
                this.isChecking = false;
            }
        }
        else {
            this.shakedArr.push(newTimeStamp);
        }
        // 允许少许误差
        if (this.shakedArr.length >= this.shakeConfig.times) {
            this.handleArrivedEmitStandard();
        }
        else {
            this.isChecking = false;
        }
    }
    handleArrivedEmitStandard() {
        this.isArrivedConfigStandard = true;
        this.resetShakeStatus();
        if (this.shakeConfig.isEmitImmediately) {
            this.dispatchEvent({
                type: SHAKE_EVENT,
                data: {},
            });
        }
        else {
            this.notEmitButShaked = true;
        }
    }
    checkDoDelayEmit() {
        if (this.notEmitButShaked && this.checkIsShakeStoped && !this.shakeConfig.isEmitImmediately) {
            this.dispatchEvent({
                type: SHAKE_EVENT,
                data: {},
            });
        }
        if (this.isShakeStarted) {
            this.dispatchEvent({
                type: SHAKE_END_EVENT,
                data: { isArrivedConfigStandard: this.isArrivedConfigStandard },
            });
        }
        this.resetShakeStatus(true);
    }
}

const interval = 60;
let shakeHandler = null;
let checkIsShake = null;
const startMonitorShake = async () => {
    const yoda = getYoda();
    /*
     * Const startAccelerometerRes = await yoda.system.startAccelerometer({
     *     interval,
     * });
     */
    const startAccelerometerRes = await yoda.bridge('system', 'startAccelerometer', {
        interval,
    });
    checkIsShake = shakeHandler.checkIsShake.bind(shakeHandler);
    // Const eventRes = await yoda.event.addEventListener('accelerometer-change', checkIsShake)
    const eventRes = await yoda.bridge('event', 'addEventListener', {
        type: 'accelerometer-change',
        listener: checkIsShake,
    });
    if (startAccelerometerRes.result === 1 && eventRes.result !== 1) {
        stopMonitorShake();
    }
    if (startAccelerometerRes.result !== 1 || eventRes.result !== 1) {
        throw new Error(`摇一摇初始化失败，请稍后重试。AccelerometerRes:${JSON.stringify(startAccelerometerRes)};eventRes:${JSON.stringify(eventRes)}`);
    }
};
const validateOption = (options) => {
    if (!options) {
        return;
    }
    const { level, times, isEmitImmediately } = options;
    // Android 和 iOS 级别类型一致
    if (level !== undefined && !ANDROID_LEVEL_MAP[level]) {
        throw new Error('请传入正确的level，可选值为1、2、3');
    }
    if (times !== undefined) {
        if (!Number.isInteger(times)) {
            throw new Error('times应为整数');
        }
        if (times < 1) {
            throw new Error('times应大于1');
        }
    }
    if (isEmitImmediately !== undefined) {
        if (typeof isEmitImmediately !== 'boolean') {
            throw new Error('isEmitImmediately应为boolean类型');
        }
    }
};
const initShakeHandler = async (options) => {
    const yoda = getYoda();
    if (!await checkCanUse('system', 'startAccelerometer')) {
        throw new Error('当前APP暂不支持摇一摇');
    }
    if (shakeHandler) {
        throw new Error('当前存在尚未结束监听的摇一摇');
    }
    const dispatchEvent = async (params) => yoda.bridge('event', 'dispatchEvent', params);
    shakeHandler = new ShakeHandler({
        dispatchEvent,
        isAndroid,
    });
    validateOption(options);
    shakeHandler.setOptions(options);
    shakeHandler.resetShakeStatus();
    await startMonitorShake.bind(yoda)();
};
const stopMonitorShake = async () => {
    const yoda = getYoda();
    if (!await checkCanUse('system', 'stopAccelerometer')) {
        throw new Error('当前APP暂不支持摇一摇');
    }
    shakeHandler = null;
    // Const eventRes = await yoda.event.removeEventListener('accelerometer-change', checkIsShake)
    const eventRes = await yoda.bridge('event', 'removeEventListener', {
        type: 'accelerometer-change',
        listener: checkIsShake,
    });
    // Const stopRes = await yoda.system.stopAccelerometer()
    const stopRes = await yoda.bridge('system', 'stopAccelerometer', {});
    if (eventRes.result !== 1 || stopRes.result !== 1) {
        throw new Error(`摇一摇停止监听失败。stopRes:${JSON.stringify(stopRes)};eventRes:${JSON.stringify(eventRes)}`);
    }
};

const yodaCustomEvent = {
    shaked: SHAKE_EVENT,
};
const eventToInitMap = {
    [yodaCustomEvent.shaked]: initShakeHandler,
};
const handleEventUnregisterMap = {
    [yodaCustomEvent.shaked]: stopMonitorShake,
};

// 添加事件监听
const addEventListener = (params, callback) => {
    const { type: baseType, listener } = params;
    const type = typeof baseType === 'string' ? baseType : baseType.type;
    const options = typeof baseType === 'string' ? {} : baseType.options;
    eventToInitMap[type]?.(options);
    !listener.__yodaCallbackId__ && (listener.__yodaCallbackId__ = {});
    // 保持原有判断逻辑不变，若当前lisetener
    if (listener.__yodaCallbackId__[type]) {
        throw new Error(`addEventListener ${type} 的 listener 已经被绑定过了`);
    }
    const registerForNativeListener = hasListener(type);
    let callBackId = null;
    let returnPromise = Promise.resolve();
    // Call native 新增监听
    if (!registerForNativeListener) {
        const deferredIns = deferredInvoke.pushMQ(true, createCb(type), true);
        callBackId = parseInt(getEventIdOnlyNumber(deferredIns.traceId));
        returnPromise = invoke$1({
            namespace: 'event',
            name: 'addEventListener',
            params: {
                type,
                listener: String(deferredIns.traceId),
            },
            callback,
        });
    }
    else {
        // 前端维护，直接回调
        isFunction(callback) && callback({ result: 1 });
    }
    addListener(type, listener, callBackId);
    return returnPromise;
};
// 移除事件监听
const removeEventListener = (params, callback) => {
    const { type, listener } = params;
    handleEventUnregisterMap[type]?.();
    let resultPromise = Promise.resolve();
    if (listener.__yodaCallbackId__) {
        const callbackId = getCallbackIdByType(type);
        // 移除前端监听
        removeListener(type, listener);
        // 若当前不包含监听
        if (!hasListener(type)) {
            // 移除native 侧监听
            resultPromise = invoke$1({
                namespace: 'event',
                name: 'removeEventListener',
                params: {
                    type,
                    listener: callbackId,
                },
                callback,
            });
            // 移除js 侧监听
            deferredInvoke.removeMQ(callbackId);
        }
    }
    return resultPromise;
};

/**
 * 删除 yoda 对象
 * 1. 事件分发移至 invoke
 * 2. 重构摇一摇事件
 * 3. 移除所有内部调用
 */
const yoda = {
    bridge: (namespace, name, params, callback, multiCallback = false) => {
        const callParams = {
            namespace,
            name,
            params,
            multiCallback,
            callback,
        };
        if (namespace === 'event') {
            if (name === 'addEventListener') {
                return addEventListener(params, callback);
            }
            if (name === 'removeEventListener') {
                return removeEventListener(params, callback);
            }
        }
        // 兼容 @wangzhaoqi 9920 调用一个不存在的bridge 无法回调问题
        if (compareKwaiAppVersion('9.9.20') === 0 && isAndroid) {
            return invokeAndroid9920(callParams);
        }
        return invoke$1(callParams);
    },
};
// 缓存yoda对象
setYoda(yoda);
setContainer({
    invoke,
    addListener: addListener$1,
    removeListener: removeListener$1,
});

export { addListener$1 as addListener, invoke, isBridgeError, removeListener$1 as removeListener, setGlobalConfig, version };
