import type { CallbackArg, Listener } from '../../type';
import * as eventMQ from './eventMQ';
import type { Deferred } from '../../bridge/invokeToDeferred';
import { deferredInvoke } from '../../bridge/invokeToDeferred';
import * as bridge from '../../bridge/index';

import { isFunction } from '../../utils';
import {
    eventToInitMap,
    handleEventUnregisterMap,
} from './packagingApi/apiMap';
import { getEventIdOnlyNumber } from '../../utils/eventId';

// 添加事件监听
export const addEventListener = (
    params: {
        type: string | {
            type: string;
            options?: Record<string, any>;
        };
        listener: Listener;
    },
    callback?: (res: unknown) => void,
): Promise<CallbackArg> => {
    const { type: baseType, listener } = params;
    const type = typeof baseType === 'string' ? baseType : baseType.type;
    const options = typeof baseType === 'string' ? {} : baseType.options;

    eventToInitMap[type]?.(options as any);
    !listener.__yodaCallbackId__ && (listener.__yodaCallbackId__ = {});

    // 保持原有判断逻辑不变，若当前lisetener
    if (listener.__yodaCallbackId__[type]) {
        throw new Error(`addEventListener ${type} 的 listener 已经被绑定过了`);
    }

    const registerForNativeListener = eventMQ.hasListener(type);
    let callBackId: number | null = null;

    let returnPromise: Promise<CallbackArg> = Promise.resolve() as any;

    // Call native 新增监听
    if (!registerForNativeListener) {
        const deferredIns: Deferred = deferredInvoke.pushMQ(
            true,
            eventMQ.createCb(type),
            true
        );

        callBackId = parseInt(getEventIdOnlyNumber(deferredIns.traceId as any));
        returnPromise = bridge.invoke({
            namespace: 'event',
            name: 'addEventListener',
            params: {
                type,
                listener: String(deferredIns.traceId),
            },
            callback,
        }) as Promise<CallbackArg>;
    } else {
        // 前端维护，直接回调
        isFunction(callback) && callback({ result: 1 });
    }

    eventMQ.addListener(type, listener, callBackId as any);

    return returnPromise;
};

// 移除事件监听
export const removeEventListener = (
    params: {
        type: string;
        listener: Listener;
    },
    callback?: (res: unknown) => void,
): Promise<CallbackArg> => {
    const { type, listener } = params;

    handleEventUnregisterMap[type]?.();

    let resultPromise: Promise<CallbackArg> = Promise.resolve() as any;

    if (listener.__yodaCallbackId__) {
        const callbackId = eventMQ.getCallbackIdByType(type);

        // 移除前端监听
        eventMQ.removeListener(type, listener);

        // 若当前不包含监听
        if (!eventMQ.hasListener(type)) {
            // 移除native 侧监听
            resultPromise = bridge.invoke({
                namespace: 'event',
                name: 'removeEventListener',
                params: {
                    type,
                    listener: callbackId,
                },
                callback,
            }) as Promise<CallbackArg>;
            // 移除js 侧监听
            deferredInvoke.removeMQ(callbackId);
        }
    }

    return resultPromise;
};
