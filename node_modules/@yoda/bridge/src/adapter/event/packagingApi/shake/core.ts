import type { EventOptions, AccelerometerRes, ShakeProps, LevalMap } from './type';
import { Direction } from './type';
import { debounce } from '../../../../utils';
import { SHAKE_EVENT, JUDGE_STOP_TIME, DEFAULT_SETTING, IOS_LEVEL_MAP, ANDROID_LEVEL_MAP, SHAKE_START_EVENT, SHAKE_END_EVENT } from './constants';

export class ShakeHandler {
    constructor(props: ShakeProps) {
        this.dispatchEvent = props.dispatchEvent;
        this.isAndroid = props.isAndroid;
        this.levelMap = this.isAndroid ? ANDROID_LEVEL_MAP : IOS_LEVEL_MAP;
    }

    shakeConfig: EventOptions = {};

    shakedArr: number[] = [];

    isChecking = false;

    nowStatus: AccelerometerRes = {
        x: 0,
        y: 0,
        z: 0,
    };

    lastStatus: AccelerometerRes = {
        x: 0,
        y: 0,
        z: 0,
    };

    stopMark: null | ReturnType<typeof setTimeout> = null;

    checkIsShakeStoped = false;

    notEmitButShaked = true;

    isShakeStarted = false;

    isAndroid = false;

    isArrivedConfigStandard = false;

    levelMap: LevalMap = ANDROID_LEVEL_MAP;

    dispatchEvent: null | ((params: unknown) => Promise<any>) = null;

    setStillShaking = debounce(() => this.notShaking(), JUDGE_STOP_TIME);

    setOptions(options: EventOptions) {
        if (options) {
            this.shakeConfig = {
                ...DEFAULT_SETTING,
                ...options,
            };

            // IOS 和 Android重力感应的灵敏度等都不太一样，数值分端调试，并在次数上允许小量误差
            this.shakeConfig.times = this.isAndroid ? this.shakeConfig.times! - 1 : (this.shakeConfig.times! - 1) * 2;
            this.shakeConfig.intervalTime = this.isAndroid
                ? this.shakeConfig.androidIntervalTime!
                : this.shakeConfig.iOSIntervalTime!;
        } else {
            this.shakeConfig = { ...DEFAULT_SETTING };
        }
    }

    resetShakeStatus(isStoped?: boolean) {
        this.shakedArr = [];
        this.isChecking = false;
        this.notEmitButShaked = false;

        if (isStoped) {
            this.isArrivedConfigStandard = false;
            this.isShakeStarted = false;
        }
    }

    checkIsShake(result: AccelerometerRes) {
        this.isChecking = true;
        Object.keys(this.nowStatus).forEach((key: any) => (this.nowStatus as any)[key] = (result as any)[key] * 9.8);

        if (this.judgeArrivedTerminal()) {
            this.lastStatus = {
                x: 0,
                y: 0,
                z: 0,
            };
            this.handleShakeHappend();
            this.setStillShaking();
            this.isChecking = false;

            return;
        }

        if (this.judgeLikelyShake()) {
            this.handleArrivedStandard();
        } else {
            this.isChecking = false;
        }
    }

    judgeLikelyShake() {
        const { x, y, z } = this.nowStatus;
        const { basic, total } = this.levelMap[this.shakeConfig.level!];

        return x > basic || y > basic || z > basic || x * x + y * y + z * z > total;
    }

    // 用加速度变化最大的方向作为判断依据，确认加速度是否反向，从而判定是否到达一次摇动的端点
    judgeArrivedTerminal() {
        let maxDiffVal = 0;
        let diffVal = 0;
        let toJudgeKey: Direction = Direction.x;

        // 获取加速度变化最大的方向
        Object.keys(this.nowStatus).forEach((key: any) => {
            diffVal = Math.abs((this.lastStatus as any)[key] - (this.nowStatus as any)[key]);

            if (maxDiffVal < diffVal) {
                toJudgeKey = key;
                maxDiffVal = diffVal;
            }
        });

        if (this.lastStatus[toJudgeKey] * this.nowStatus[toJudgeKey] < 0) {
            return true;
        }

        return false;
    }

    handleArrivedStandard() {
        this.lastStatus = { ...this.nowStatus };
        this.checkIsShakeStoped = false;
        this.setStillShaking();
    }

    async handleShakeHappend() {
        if (!this.isShakeStarted) {
            await this.dispatchEvent!({
                type: SHAKE_START_EVENT,
                data: {},
            });
        }

        this.isShakeStarted = true;
        this.updateShakedArr(new Date().getTime());
    }

    notShaking() {
        this.checkIsShakeStoped = true;
        this.checkDoDelayEmit();
    }

    updateShakedArr(newTimeStamp: number) {
        const { intervalTime } = this.shakeConfig;

        if (this.shakedArr.length > 0) {
            if (newTimeStamp - this.shakedArr[this.shakedArr.length - 1] <= intervalTime!) {
                this.shakedArr.push(newTimeStamp);
            } else {
                this.shakedArr = [];
                this.isChecking = false;
            }
        } else {
            this.shakedArr.push(newTimeStamp);
        }

        // 允许少许误差
        if (this.shakedArr.length >= this.shakeConfig.times!) {
            this.handleArrivedEmitStandard();
        } else {
            this.isChecking = false;
        }
    }

    handleArrivedEmitStandard() {
        this.isArrivedConfigStandard = true;
        this.resetShakeStatus();

        if (this.shakeConfig.isEmitImmediately) {
            this.dispatchEvent!({
                type: SHAKE_EVENT,
                data: {},
            });
        } else {
            this.notEmitButShaked = true;
        }
    }

    checkDoDelayEmit() {
        if (this.notEmitButShaked && this.checkIsShakeStoped && !this.shakeConfig.isEmitImmediately) {
            this.dispatchEvent!({
                type: SHAKE_EVENT,
                data: {},
            });
        }

        if (this.isShakeStarted) {
            this.dispatchEvent!({
                type: SHAKE_END_EVENT,
                data: { isArrivedConfigStandard: this.isArrivedConfigStandard },
            });
        }

        this.resetShakeStatus(true);
    }
}


