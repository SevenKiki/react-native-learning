import '../type/index';
import { deferredInvoke } from './invokeToDeferred';
import {
    NAMESPACE_2_GLOBALVAR,
} from '../webview/constant';

import { bridgeParamsHandler } from '../webview/utils';

import { setupMultiInstanceGuard } from './guard';

import { compareYodaVersion, isIOS } from '../utils';
import { console } from '../loggers';

const invoke = async (invokeConfig: any) => {
    const { namespace, name, params, multiCallback, callback } = invokeConfig;

    const ns = NAMESPACE_2_GLOBALVAR[namespace];
    const { id, promise } = deferredInvoke.create(
        namespace,
        name,
        multiCallback,
        callback
    );

    // TODO 确定逻辑后处理 临时添加 活动 namespace
    // if (ns || addCbParamsBridges.includes(name) || namespace == 'sf2022') {
        // 实际调用前需要将 register 中改写的 namespace 改回来
    const originalNamespace = ns || namespace;

    const _invokeCallback = (res: any) => {
        invokeCallback(id!, res as string);
    };

    invokeConfig.namespace = originalNamespace === 'Kwai'
        && typeof navigator !== 'undefined'
        && navigator.userAgent.includes('livemate/') ? 'livemate' : originalNamespace;

    // 参数预处理
    invokeConfig.params = bridgeParamsHandler(
        originalNamespace,
        name,
        params,
        _invokeCallback
    ) ?? {};

        /*
         * 比较版本号
         * 7730 以上版本不需要做兼容处理
         * 兼容方式注册的桥，双端只关注 params.callback，yoda 方式注册的桥只关注 invoke callbackId
         * if (appVersion && compareVersion(appVersion, '7.7.30') < 0) {
         * 在 js-sdk 层将桥调用的回调方法转到 params 后，需要将 callbackId 重置下
         * 主要处理部分只回调一次的桥（回调执行一次后会被 delete），如果 params.callback 和 invokeCallback 指向一个回调
         * 可能会导致 params.callback 还未执行，回调已被 delete
         * 临时回调函数只在这个地方有声明，原sdk、plugin 并未 指定该 callback
         * const tmpCbKey = '__yoda_kuaishou_plugin_tmp_cb__';
         * yoda._callbacks[tmpCbKey] = yoda._callbacks[tmpCbKey] || noop;
         * invokeConfig.callbackId = tmpCbKey;
         * 需要额外挂到 window 上是因为 iOS 可能会去 window 上找该回调
         *     window.__yoda_kuaishou_plugin_tmp_cb__ = noop;
         * }
         */
    // }

    console.info(`Invoking '${invokeConfig.namespace}.${invokeConfig.name}'`, invokeConfig.params);

    if (isIOS && !window.webkit && compareYodaVersion('2.10.9.2') < 0) {
        return promise;
    }

    window.__yodaBridge__.invoke(
        invokeConfig.namespace,
        invokeConfig.name,
        JSON.stringify(invokeConfig.params),
        String(id)
    );

    return promise;
};

// TODO这种格式后面还需要做各种全局校验
type YodaResponse = {
    result: number;
} & Record<string, any>;

const invokeCallback = (id: string, res: string | YodaResponse) => {
    if (isIOS && compareYodaVersion('2.3.7') < 0) {
        // 以前 Yoda iOS 回调时插值表达式写错了，导致这里的 id 类型是 number
        // eslint-disable-next-line no-param-reassign
        id = `${id}`;
    }

    const data: YodaResponse | null = typeof res === 'string' ? JSON.parse(res) : res;

    if (data?.result === 1) {
        deferredInvoke.resolve(id, data);
    } else {
        deferredInvoke.reject(id, data);
    }
};

if (typeof window !== 'undefined') {
    // 开启守卫
    setupMultiInstanceGuard();
    // 挂载接收 native 回调事件
    window.__yodaBridgeCallback__ = invokeCallback;
}

export { invoke };
