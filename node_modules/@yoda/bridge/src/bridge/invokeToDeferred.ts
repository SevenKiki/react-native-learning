import { getUUId, isPerformanceId, getEventId, isEventId } from '../utils';
import { logger } from '../loggers/scatter';

/*
 *  单次调用 | 多次调用
 *  多次调用要保留函数持有，直接保存cb函数
 *  TODO 由于不知道多次回调函数什么时候结束，可能会造成内存不可控
 */
export interface Deferred {
    traceId?: string;
    isMulti: boolean;
    promise: Promise<unknown>;
    namespace?: string;
    name?: string;
    startTime?: string;
}

type singleDeferred = Deferred & {
    resolve: (value: unknown) => void;
    reject: (reason?: any) => void;
};

type multiDeferred = Deferred & {
    resolve: Function;
};

function createSingleDeferred(cb?: Function) {
    let resolve: ((value: unknown) => void) | null = null;
    let promise = new Promise(r => {
        resolve = r;
    });

    if (cb) {
        promise = promise.then(
            cb as (value: unknown) => unknown,
            cb as (value: unknown) => unknown
        );
    }

    return {
        isMulti: false,
        resolve: resolve as any,
        promise,
    };
}

function createMultiDeferred(cb?: Function) {

    /*
     * 多次调用模式下，promise
     * 只是兼容当前调用方式
     * TODO 文档中需要特殊说明
     */
    const promise = new Promise(() => {});

    return {
        isMulti: true,
        resolve: cb,
        promise,
    };
}

export const invokeMap: Record<string, singleDeferred | multiDeferred> = {};

export const deferredInvoke = {
    pushMQ(
        isMulti = false,
        callBackFn?: Function,
        isEvent = false
    ): singleDeferred | multiDeferred {
        const id = isEvent ? getEventId() : getUUId(invokeMap);
        const deferred: singleDeferred | multiDeferred = isMulti
            ? createMultiDeferred(callBackFn)
            : createSingleDeferred(callBackFn);

        deferred.traceId = String(id);

        invokeMap[id] = deferred;

        return deferred;
    },
    removeMQ(callbackId: string) {
        invokeMap[callbackId] = undefined as any;
    },
    create<Value, Reason>(
        namespace: string,
        name: string,
        isMulti = false,
        callBackFn?: Function
    ) {
        const deferred: singleDeferred | multiDeferred = this.pushMQ(
            isMulti,
            callBackFn
        );

        deferred.namespace = namespace;
        deferred.name = name;

        // 创建
        const startTimeStr = logger({
            namespace,
            name,
            type: 'invoke',
            callbackId: deferred.traceId!,
        });

        invokeMap[deferred.traceId!].startTime = startTimeStr!;

        return {
            id: deferred.traceId,
            promise: deferred.promise,
        };
    },
    resolve(id: string, data: unknown) {
        if (isPerformanceId(id)) {
            return;
        }

        const deferred = invokeMap[id];

        if (!deferred) {

            /*
             * 创建
             * return console.warn('native callback error:', data);
             */
            return;
        }

        deferred.resolve(data);

        // 设置成为undefined保证不内存泄露，不用delete是防止回退字典模式
        if (!deferred.isMulti) {
            this.removeMQ(id);
        }

        if (isEventId(id)) {
            return;
        }

        // 发送回调成功日志
        logger(
            {
                namespace: deferred.namespace!,
                name: deferred.name!,
                type: 'callback',
                callbackId: deferred.traceId!,
                resultCode: (data as any).result,
            },
            deferred.startTime
        );
    },
    reject(id: string, reason: unknown) {
        const deferred = invokeMap[id];

        if (!deferred) {

            /*
             * 若无对应调用，不做处理，稍后增加 log
             * return console.warn('native callback error:', reason);
             */
            return;
        }

        // 以异常信息回调正常业务也逻辑
        deferred.resolve(reason);

        // 设置成为undefined保证不内存泄露，不用delete是防止回退字典模式
        if (!deferred.isMulti) {
            this.removeMQ(id);
        }

        // 由于事件的回调result!=1,导致会使事件的回调会走到reject 中
        if (isEventId(id)) {
            return;
        }

        // 发送回调成功日志
        logger(
            {
                namespace: deferred.namespace!,
                name: deferred.name!,
                type: 'callback',
                callbackId: deferred.traceId!,
                resultCode: (reason as any).result,
                errorMsg: (reason as any).message,
            },
            deferred.startTime
        );
    },
};
