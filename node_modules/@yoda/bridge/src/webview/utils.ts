import { BRIDGE_TYPE, NAMESPACE_2_GLOBALVAR } from './constant';
import { isFunction } from '../utils';

const { noCallbackList, onClickList, handlerList } = BRIDGE_TYPE;

/**
 *
 * 生成唯一的id
 * @export
 * @returns
 */
export function generateUUID(rc = true) {
    // https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523
    let d = new Date().getTime();

    if (
        typeof performance !== 'undefined'
        && typeof performance.now === 'function'
    ) {
        d += performance.now(); // Use high-precision timer if available
    }

    const pattern = rc
        ? 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
        : 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';

    return pattern.replace(/[xy]/g, c => {
        const r = (d + Math.random() * 16) % 16 | 0;

        d = Math.floor(d / 16);

        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
}

/**
 *
 * 生成临时唯一的方法挂接到window上，给客户端回调用
 * @name generateUUCallbackFunction
 * @private
 * @param {function} callback 回调函数，客户端方法执行完后会执行该方法
 * @param {boolean} notDelete 是否删除当前回调，留在当前页面的内存中
 * @param {string} bridge 的命名空间和方法名，方便后续问题排查
 * @param {string} 回调方法对应的唯一ID
 * @returns
 */
export function generateUUCallbackFunction(
    callback: Function,
    notDelete: boolean,
    callbackName: string
) {
    const callbackId = generateUUID(false);
    const name = `yoda_kuaishou_plugin_callback_${callbackName}_${callbackId}`;

    (window as any)[name] = function (data: any) {
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch (e) {
                console.warn(e); // eslint-disable-line
            }
        }

        if (isFunction(callback)) {
            callback.call(window, data);
        } else if (
            typeof callback === 'string'
            && isFunction(window[callback])
        ) {
            (window as any)[callback].call(window, data);
        }

        if (!notDelete) {
            delete (window as any)[name];
        }
    };

    return name;
}

// 用于 showDialog 相关 api 中，将回调转化成接口需要的 URL
export function transformFuncToURL(btn: any, callbackName: string) {
    const tmpBtn = btn;

    if (btn && Array.isArray(btn.actions)) {
        tmpBtn.actions = btn.actions.map((action: any) => {
            if (action && action.url && isFunction(action.url)) {
                action.url = generateUUCallbackFunction(
                    action.url,
                    true,
                    callbackName
                );
            }

            return action;
        });
    }

    return tmpBtn;
}

const handlerCbMap: Record<string, any> = {};

// 事件相关 api 中处理 handler
export function generateHandlerFunction(callback: Function, bridge: string) {
    let handlerName = '';
    let cb = null;

    Object.keys(handlerCbMap).some((cbName: any) => {
        const handlerCb = handlerCbMap[cbName];

        if (handlerCb === callback) {
            cb = handlerCb;
            handlerName = cbName;

            return true;
        }
        return false;
    });

    // 当传递的 handler 回调之前已经挂载过，就不再重新挂载，重新生成 handler 回调名
    if (cb !== callback && callback) {
        const name = generateUUCallbackFunction(callback, true, bridge);

        handlerCbMap[name] = callback;
        handlerName = name;
    }

    return handlerName;
}

/**
 * Bridge 调用参数预处理，针对几类特定 bridge 进行处理
 * @name bridgeParamsHandler
 * @private
 * @param {string} namespace 命名空间
 * @param {string} bridge 桥名
 * @param {Object} 调用参数
 * @param {function} bridge 本身调用的回调
 */
export function bridgeParamsHandler(
    namespace: string,
    bridgeName: string,
    params: any,
    invokeCallback: Function
) {
    let handledParams = { ...params };
    const callbackName = `${namespace}_${bridgeName}`;

    /*
     * 特殊适配 Kwai 等命名空间下 bridge 回调的传递
     * 回调为 onClick 形式的
     */
    if (onClickList.includes(bridgeName)) {
        handledParams.onClick = generateUUCallbackFunction(
            handledParams.onClick,
            true,
            callbackName
        );
        // 不允许传递任何参数给 native 的
    } else if (noCallbackList.includes(bridgeName)) {
        handledParams = null;
        // 事件类传 handler 的
    } else if (handlerList.includes(bridgeName)) {
        const callbackUUid = generateUUCallbackFunction(
            invokeCallback,
            false,
            callbackName
        );

        // 调用 off 桥不传 handler 时，则不能传再对其进行处理
        if (handledParams.handler && isFunction(handledParams.handler)) {
            handledParams.handler = generateHandlerFunction(
                handledParams.handler,
                callbackName
            );
        }

        handledParams.callback = callbackUUid;
        // ShowDialog
    } else if (bridgeName === 'showDialog') {
        const { positiveButton, negativeButton, neutralButton } = handledParams;

        if (positiveButton) {
            handledParams.positiveButton = transformFuncToURL(
                positiveButton,
                callbackName
            );
        }

        if (negativeButton) {
            handledParams.negativeButton = transformFuncToURL(
                negativeButton,
                callbackName
            );
        }

        if (neutralButton) {
            handledParams.neutralButton = transformFuncToURL(
                neutralButton,
                callbackName
            );
        }
        // 其他默认都是通过 callback 传给 native
    } else if (Object.keys(NAMESPACE_2_GLOBALVAR).includes(namespace)) {
        const callbackUUid = generateUUCallbackFunction(
            invokeCallback,
            true,
            callbackName
        );

        handledParams.callback = handledParams.callback || callbackUUid;
    }

    return handledParams;
}

