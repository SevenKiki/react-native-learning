import type { NativeBridges } from '@yoda/bridge-types';
import { apis, type IntrinsicAPIs } from './apis';
import { BridgeError, isBridgeError } from './bridge-error';
import { multipleCallbacksBridgeSet, type UseCallbackBridge, useCallbackBridgeSet } from './constants';
import { globalConfig } from './global-config';
import { getYoda } from './instance';
import { console } from './loggers';
import { transformConfig } from './transform';
import type {
    YodaBridges,
    InvocationParams,
    InvocationOptions,
    InvocationBridgeNamespace,
    InvocationBridgeName,
    InvocationConfig,
    InvocationPromise,
    InvocationResponse,
    InvocationResponseData,
    InvocationParameters,
} from './types';
import { delay, hasOwnProperty, isYoda, type UnionToIntersection } from './utils';

const getInvocationConfig = <T extends keyof YodaBridges>(args: InvocationParameters<T>) => {
    const [bridge, params = {}, optionsOrCallback] = args;
    const [options, callback] = typeof optionsOrCallback === 'function'
        ? [{} as InvocationOptions, optionsOrCallback]
        : [optionsOrCallback ?? {}];

    return {
        initialBridge: bridge,
        initialParams: params,
        bridge,
        params,
        options,
        callback,
    } as InvocationConfig<T>;
};

const getLegacyErrorMessage = <T extends keyof NativeBridges>(response: InvocationResponse<T>) =>
    hasOwnProperty(response, 'error_msg') && typeof response.error_msg === 'string' ? response.error_msg : '';

const isIntrinsicAPI = (config: InvocationConfig<keyof YodaBridges>): config is InvocationConfig<keyof IntrinsicAPIs> =>
    config.bridge.startsWith('yoda.');

const invokeAPI = <T extends keyof IntrinsicAPIs>(config: InvocationConfig<T>): InvocationPromise<T> => {
    const { bridge, params } = config;
    const [, name] = bridge.split('.') as [InvocationBridgeNamespace<T>, InvocationBridgeName<T>];
    const api = apis[name] as (params: InvocationParams<T>) => InvocationPromise<T>;

    return api(params);
};

const invokeBridge = <T extends keyof NativeBridges>(
    config: InvocationConfig<T>,
): InvocationPromise<T> => {
    const yoda = getYoda();
    const { initialBridge, bridge, params, callback } = config;
    const [namespace, name] = bridge.split('.') as [InvocationBridgeNamespace<T>, InvocationBridgeName<T>];

    if (useCallbackBridgeSet.has(initialBridge)) {
        void yoda.bridge(namespace, name, params, (response: InvocationResponse<T>) => {
            console.info(`Received a response from '${bridge}'`, response);

            callback?.(response as
                UnionToIntersection<InvocationResponse<Extract<UseCallbackBridge, keyof YodaBridges>>>);
        }, multipleCallbacksBridgeSet.has(initialBridge));

        return Promise.resolve() as InvocationPromise<T>;
    }

    return new Promise<InvocationResponseData<T>>((resolve, reject) => {
        void yoda.bridge(namespace, name, params, (response: InvocationResponse<T>) => {
            console.info(`Received a response from '${bridge}'`, response);

            if (response.result === 1) {
                const { result, ...data } = response;

                resolve(data);

                return;
            }

            const { message = getLegacyErrorMessage(response) } = response;

            const bridgeError = new BridgeError(message, response.result, config);

            globalConfig.errorHandler?.(bridgeError);

            reject(bridgeError);
        });
    }) as InvocationPromise<T>;
};

export const invoke = async <T extends keyof YodaBridges>(
    ...args: InvocationParameters<T>
): InvocationPromise<T> => {
    try {
        const initialConfig = getInvocationConfig(args);

        if (!isYoda()) {
            throw new BridgeError([
                'Cannot invoke bridge',
                ...process.env.NODE_ENV === 'production' ? [] : [`'${initialConfig.bridge}'`],
                'in non-Yoda environment.',
            ].join(' '), 125014, initialConfig);
        }

        const config = transformConfig(initialConfig);
        const { options: { timeout = globalConfig.timeout ?? 0 } } = config;

        const baseInvoking = (isIntrinsicAPI(config)
            ? invokeAPI(config)
            : invokeBridge(config)) as InvocationPromise<T>;

        const data = timeout > 0 && Number.isFinite(timeout)
            ? await Promise.race([
                baseInvoking,
                delay(timeout).then(() => Promise.reject(new BridgeError(
                    'Bridge invocation timed out.',
                    125010,
                    config,
                ))),
            ])
            : await baseInvoking;

        return data;
    } catch (err) {
        if (isBridgeError(err)) {
            globalConfig.errorHandler?.(err);
        }

        throw err;
    }
};
