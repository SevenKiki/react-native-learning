const fs = require('fs');
const path = require('path');
const debug = require('debug')('cdn-upload');
const chalk = require('chalk');
const { uploadMultiple } = require('./service');
const glob = require('glob-promise');
const promiseLimit = require('promise-limit');
const { formatCdnDir, getExitErrorCodes, mockLocalResponseError, formatInputFiles } = require('./utils/index');
const { checkFileExist, validateCdnDir, checkFileEmpty, checkFileNameValid } = require('./utils/validate');
const { requestWithRetry } = require('./utils/request');
const { ERROR_CODE_MAP, RADAR_MODE_MAP, RADAR_MODE_NAME_MAP, RADAR_MODE_TIP_MAP } = require('./utils/config.js');
const { jsonStringify } = require('./utils/util.js');
const radar = require('./utils/radar.js');
const { cacheToken } = require('./utils/token-cache');

/**
 * 文件上传类
 * @params {Object} options
 * @params {String} options.pid           // 项目pid。在 https://kcdn.corp.kuaishou.com/dashboard/project-info 页面获取项目Pid
 * @params {String} options.token         // 项目token。在 https://kcdn.corp.kuaishou.com/dashboard/project-info 页面获取项目Token
 * @params {String} options.uid           // 用户id，默认: npm
 * @params {String} options.cdnDir        // 指定目标CDN路径。默认: 根目录
 * @params {String|Array} options.files   // 本地文件/文件夹路径。支持相对路径和绝对路径
 * @params {String} options.allowRewrite  // 是否开启同名文件更新功能。'true': 开启，'false':不开启	
 * @params {String} options.allowHash     // 是否支持文件名hash。 'true': 开启，'false': 不开启
 * @params {String} options.allowMD5      // 是否支持返回的head里添加md5信息。 'true': 开启，'false': 不开启
 * @params {String} options.exitOnApiError   // 逗号分割的具体错误类型，发生错误后直接退出进程。默认: unknown。never: 忽略报错; duplicate: 同名更新错误; unknown: 校验不通过、上传失败、未知错误
 * @params {String} options.env           // 文件上传的环境。默认: production
 * 
 * @params {Boolean} options.showConsole       // 是否打印日志到控制台面板。默认: true
 * @params {Boolean} options.maxRetryTime      // 失败重试次数，默认 5次
 * @params {Boolean} options.retryDelay        // 失败重试间隔，单位ms。默认1s
 * 
 * @methods start() // 开始上传文件。返回已上传的cdnUrl数组
 * 
 * @demo 使用例子：
      const Upload = require('@kcdn/multi-upload');
      const upload = new Upload({
        pid: 'xxxxxxxx',
        token: '11379_xxxxxxxx',
        uid: 'dengzhirong',
        allowRewrite: 'true',
        allowHash: 'false',
        cdnDir: 'unit-test-002',
        files: ['debug-dir'],
      });
      upload.start();
 */
module.exports = class Upload {
  constructor(options = {}) {
    this.options = options;
    this.log('[kcdn-upload] ready to init');

    const { cdnDir = '', files = [], maxRetryTime = 5, retryDelay = 1000, exitOnApiError, env } = options;
    let { uid } = options;

    const formattedCdnDir = formatCdnDir(cdnDir); // cdn目标地址支持使用环境变量入参

    // 获取流水线环境变量中，当前构建的用户id，默认: npm
    if (!uid) {
      const { BUILD_USERNAME, BUILD_OWNER, GIT_COMMIT_AUTHOR, PIPELINE_OWNER, USER } = process.env || {};
      uid = BUILD_USERNAME || GIT_COMMIT_AUTHOR || BUILD_OWNER || PIPELINE_OWNER || USER || 'npm';
    }

    // uid带上npm后缀标识
    uid = !/^.*\/npm$/.test(uid) ? `${uid}/npm` : uid;

    // 是否是staging环境
    const isStaging = env === 'staging' ? true : false;

    this.options = {
      ...options,
      uid,
      cdnDir: formattedCdnDir,
      exitOnApiError,
      maxRetryTime,
      retryDelay,
      isStaging,
    };

    this.cdnDir = formattedCdnDir;
    this.exitErrorCodes = getExitErrorCodes(exitOnApiError) || []; // 退出进程的错误code列表

    // 将待上传的文件目录转换成数组，兼容绝对路径的情况
    this.files = formatInputFiles(files, process.cwd());

    this.log(`👉 cdnDir: ${chalk.cyan(cdnDir)} to ${chalk.cyan(formattedCdnDir)} `);
    this.log(`👉 files: ${chalk.cyan(jsonStringify(this.files))}`);
    this.log(`👉 Upload Params: ${chalk.cyan(jsonStringify(this.options))}`);

    // 校验入参是否正确
    try {
      this.validate();
    } catch (e) {
      // 参数校验失败，退出进程
      console.error(new Error(`参数校验失败, ${e.message || e}`));
      process.exit(100);
    }
  }

  // 上传的入口方法
  async start() {
    // 清空上传结果
    this.resetResult();

    // 上传文件
    return this.upload()
      .then(data => {
        this.radarTrack('SUCCESS'); // 日志上报

        // 缓存token
        const { pid, token } = this.options || {};
        cacheToken(pid, token);

        return data;
      })
      .catch(e => {
        console.error(e);
        process.exit(100);
      });
  }

  async upload() {
    this.log(`========================================`);
    this.startTime = Date.now(); // 开始上传时间

    // 1. 上传文件/文件夹
    const result = await this.uploadFiles(this.files);
    // debug('【文件上传结果】', jsonStringify(result || ''));

    // 2. 展示文件上传成功后的文件列表
    const cdnUrlList = this.getCdnUrlList(result);
    this.log(`========================================`);
    this.log(
      `👻 Successfully uploaded ${chalk.cyan(cdnUrlList && cdnUrlList.length)} files. ` +
        `The KCDN urls are as follows: \n${jsonStringify(cdnUrlList, undefined, 2)}`
    );

    // 3. 展示上传总概况：总文件数、成功/失败/不存在的文件数、总耗时等
    this.calcStatusCount(result);
    const { totalCount, successCount, failedCount, notExistCount, duration } = this.result;

    this.log(`========================================`);
    this.log(
      `${failedCount ? '❌' : '👌'} ` +
        `Total Files: ${chalk.cyan(totalCount)}, ` +
        `${chalk.green('✔')} Successfully uploaded ${chalk.cyan(successCount)} files! ` +
        `${chalk.red('✗️')} Failed uploaded ${chalk.cyan(failedCount)} files!` +
        (notExistCount ? `${chalk.red('✗️')} Not Exist ${chalk.cyan(notExistCount)} files !` : '')
    );
    this.log(`⏰ Uploaded Total Time: ${chalk.cyan(duration)} ms`);

    // 4. 返回cdnUrls列表
    return cdnUrlList;
  }

  /**
   * 校验入参是否正确
   * @return new Error
   */
  validate() {
    const { files } = this;
    const { pid, token, cdnDir } = this.options;
    // 1. 如果pid/token为空
    const projectInfoUrl = 'https://kcdn.corp.kuaishou.com/dashboard/project-info';
    if (!pid) throw new Error(`pid不能为空。请登录: ${projectInfoUrl} 查看您项目的【pid】`);
    if (!token) throw new Error(`token不能为空。请登录: ${projectInfoUrl} 查看您项目的【token】`);

    // 2. 如果cdn路径不符合规范，不允许上传
    if (!validateCdnDir(cdnDir)) throw new Error(`cdn目录校验不通过，不能以./或../开头。cdnDir: ${cdnDir}`);

    // 3. 待上传的本地文件不能为空
    if (!files || !files.length) throw new Error('files不能为空');
  }

  resetResult() {
    this.result = {
      totalCount: 0,
      successCount: 0,
      failedCount: 0,
      notExistCount: 0,
      duration: 0,
    };
  }

  /**
   * 获取文件上传状态的统计
   * @param {Array} result 文件上传结果列表: [{ code, message, data: { success, fileResults: [{ status, message, cdnUrl }] } }]
   * @return {Object}  { successCount, failedCount, notExistCount }
   */
  calcStatusCount(result) {
    let successCount = 0,
      failedCount = 0,
      notExistCount = 0;

    result.map(item => {
      const { isExist, code, data } = item || {};
      if (isExist === false) {
        notExistCount += 1;
      } else if (!item || code !== 0 || !data || data.success !== true) {
        failedCount += 1;
      } else {
        successCount += 1;
      }
    });
    this.result = {
      ...this.result,
      successCount, // 上传成功的文件数
      failedCount, // 上传失败的文件数
      notExistCount, // 不存在的文件数
      totalCount: result.length, // 总文件数
      duration: Date.now() - this.startTime, // 上传总耗时
    };
    return this.result;
  }

  /**
   * 批量上传多文件/文件夹
   * @returns {Array} 接口请求Response数组，如：[{ code, message, data: { success, fileResults: [{ status, message, cdnUrl }] } }]
   */
  async uploadFiles() {
    let files = this.files || [];
    const limitNetwork = promiseLimit(10); // 最大10个并发请求
    this.result = this.result || {};
    this.result.totalCount = this.result.totalCount || 0; // 统计总文件数

    // 1. 生成请求promise数组
    let multiPromises = files.map(async filePath => {
      let stat = null;
      try {
        stat = fs.statSync(filePath);
      } catch (e) {
        const msg = `文件/文件目录不存在。file: ${chalk.cyan(filePath)}`;
        return this.quitProcess('unknown', { msg, file: filePath, code: 'LOCAL_QUIT_BY_NOT_FOUND_FILE' });
      }

      if (stat.isFile()) {
        // 如果是文件，直接上传
        const res = await glob(filePath, { nodir: true });
        const file = res && res[0];
        if (!file) {
          const msg = `文件路径不存在: ${chalk.cyan(filePath)}`;
          return this.quitProcess('unknown', { msg, file: filePath, code: 'LOCAL_QUIT_BY_NOT_FOUND_FILE' });
        }

        this.result.totalCount += 1;
        return limitNetwork(() => this.uploadSingleFile(file, ''));
      } else if (stat.isDirectory()) {
        // 如果是文件夹，遍历文件夹下的所有文件后，并发批量上传
        const dirFiles = await glob(`${filePath}/**`, { nodir: true });
        const totalCount = dirFiles && dirFiles.length;
        this.log(`🔆 resolving [${filePath}]: Total ${chalk.cyan(totalCount)} files`);
        debug(`[${filePath}]文件列表: ${jsonStringify(dirFiles, undefined, 2)}`);
        this.result.totalCount += totalCount;

        let promises = dirFiles.map(file =>
          limitNetwork(() => {
            const dir = path.relative(filePath, path.dirname(file)); // 文件基于filePath的相对路径
            return this.uploadSingleFile(file, dir);
          })
        );
        return Promise.all(promises);
      }
    });

    // 2. 文件夹之间串行执行，文件夹内部并发上传
    let result = [];
    for (let i = 0; i < multiPromises.length; i++) {
      result[i] = await multiPromises[i];
    }

    // 3. 上传结果: 二维数组 => 一维数组
    result = result.reduce((result, item) => [...result, ...(item instanceof Array ? item : [item])], []);
    return result;
  }

  /**
   * 上传单个文件
   * @param {String} file     文件路径
   * @param {String} fileDir  文件的相对目录路径
   * @returns {Object | Null} 成功则返回 object，失败则返回 null，文件不存在则返回 { isExist: false }
   */
  async uploadSingleFile(file, fileDir) {
    const { pid, token, uid, cdnDir, allowRewrite, allowHash, allowMD5, isStaging } = this.options;

    // 文件要上传的目标路径: cdnDir + 当前文件的相对目录路径
    let targetDir = path.join(cdnDir, fileDir);
    // 兼容windows系统反斜杠问题
    targetDir = path.join(cdnDir, fileDir).split(path.sep).join('/');
    this.log(`uploading file: ${chalk.cyan(file)} to ${chalk.cyan(targetDir)} ...`);

    /**
     * 1. 判断文件是否存在。不存在则不继续上传
     * 解决场景：上传与文件删除并行执行的情况。如 研发云流水线中，kcdn上传插件 与 雷达sourceMap插件 并发运行时
     */
    const isExist = checkFileExist(file);
    if (!isExist) {
      this.log(`${chalk.yellowBright('◇')} Skipped nonexistent file: ${chalk.cyan(file)}`);
      return { isExist: false, file };
    }

    // 2. 判断文件是否为空
    const isEmpty = await checkFileEmpty(file);
    if (isEmpty) {
      const msg = '文件大小不能为空';
      const response = mockLocalResponseError(msg);
      return this.formatFileUploadResponse(response, file, targetDir);
    }

    // 3. 验证文件名规则是否正确。文件名不能带中文，且只能包含英文字母数字和-.~
    // 备注：业务之前使用，允许带 @ 特殊字符，所以插件不做文件名规则校验
    // const { isValid: isFileNameValid, message: fileNameErrorMsg } = checkFileNameValid(file);
    // if (!isFileNameValid) {
    //   const response = mockLocalResponseError(fileNameErrorMsg);
    //   return this.formatFileUploadResponse(response, file, targetDir);
    // }

    // 3. 上传文件
    const params = { pid, token, uid, allowRewrite, allowHash, allowMD5, files: [file], dir: targetDir, isStaging };
    const response = await requestWithRetry({
      // 文件上传请求
      request: () => uploadMultiple(params, { radarLog: false }),

      // 失败重试前的处理函数
      beforeRetry: retryTime => {
        this.log(`🐒 Failed retry time: ${chalk.cyan(retryTime)}, file: ${chalk.cyan(file)}`);
      },

      // 请求完成后的回调函数。函数返回false，表示上传失败
      afterResponse: response => {
        return response && response.data && !!response.data.success;
      },

      maxRetryTime: this.maxRetryTime, // 失败重试次数，默认 5次
      retryDelay: this.retryDelay, // 失败重试间隔，单位ms。默认1s
    });

    return this.formatFileUploadResponse(response, file, targetDir);
  }

  /**
   * 返回文件上传的处理结果
   * @param {Object} response   上传接口Response: { code: 0, message: 'xxx', data: { success: true, fileResults: [ { status: 1, message: 'xxx', cdnUrl: 'https://xxxx' } ] } }
   * @param {String} file       文件路径
   * @param {String} targetDir  文件上传到kcdn的路径
   * @returns {Object | Null} 成功则返回 object，失败则返回 null，文件不存在则返回 { isExist: false }
   */
  formatFileUploadResponse(response, file, targetDir) {
    const { allowRewrite } = this.options;

    const { code, message = '', data: responseData } = response || {};
    const { success, fileResults } = responseData || {};
    const fileResult = Array.isArray(fileResults) ? fileResults[0] : {};
    const { status, message: fileResultMessage } = fileResult || {};
    const isSuccess = code === 0 && success && fileResult;

    // 1. 上传成功
    if (isSuccess && status === 1) {
      this.log(`${chalk.green('✔')} Successfully uploaded file: ${chalk.cyan(file)} to ${chalk.cyan(targetDir)} `);
      return response;
    }

    // 2. 同名文件更新
    const isAllowRewite = allowRewrite === 'true' || allowRewrite === true;
    if (isSuccess && status === 3) {
      this.log(`${chalk.yellowBright('◇')} Skipped same name file: ${chalk.cyan(file)}`);

      // 如果不允许同名文件更新，则报错并阻塞进程
      if (!isAllowRewite) {
        const msg = `file duplicate error, file: ${file}`;
        this.quitProcess('duplicate', { msg, file, code: 'API_QUIT_BY_FILE_IS_DUPLICATE' });
      }
      return response;
    }

    // 3. 上传失败，退出进程
    const errorMsg = fileResultMessage || message || ERROR_CODE_MAP[code] || '';
    const fullErrorMsg = `file: ${chalk.cyan(file)}, message: ${chalk.red(errorMsg)}`;
    this.log(`${chalk.red('✗️')} ${fullErrorMsg}`);
    // this.log(`${chalk.red('✗️')} Api Response: ${jsonStringify(response || '')}`);

    const msg = `unknown api error, ${fullErrorMsg}. Api Response: ${jsonStringify(response || '')}`;
    this.quitProcess('unknown', { msg, file, code: 'API_QUIT_BY_UPLOAD_ERROR' });
    return null;
  }

  /**
   * 获取上传成功后的cdnUrl列表
   * @param {Array} result 文件上传接口返回的Response数组
   * @return undefined
   */
  getCdnUrlList(result) {
    return result
      .map(item => {
        const fileResults = item && item.data && item.data.fileResults;
        const fileResult = Array.isArray(fileResults) ? fileResults[0] : null;
        return fileResult && fileResult.cdnUrl;
      })
      .filter(i => i);
  }

  /**
   * 退出进程
   * @param {String} existCode 退出进程的类型。unknown 未知错误 duplicate 同名更新失败
   * @param {String} option.msg   错误信息
   * @param {String} option.code  错误码
   * @param {String} option.file  出错的文件路径
   */
  async quitProcess(existCode, { msg = '', code = '', file } = {}) {
    const { exitErrorCodes = [] } = this;

    // 未知错误: 参数校验、上传接口异常、文件名校验不通过、空文件等
    if (existCode === 'unknown' && exitErrorCodes.includes('unknown')) {
      msg && console.error(new Error(`❌ ${msg}`));

      await this.radarTrack(code, { msg, file }); // 日志上报
      process.exit(100);
    }

    // 同名文件更新失败
    if (existCode === 'duplicate' && exitErrorCodes.includes('duplicate')) {
      msg && console.error(new Error(`❌ ${msg}`));

      await this.radarTrack(code, { msg, file }); // 日志上报
      process.exit(100);
    }
  }

  // 日志打印。入参与console.log一致
  log(...args) {
    const { showConsole } = this.options || {};
    if (showConsole === false || showConsole === 'false') return;
    console.log(...args);
  }

  // 日志上报
  async radarTrack(code, response = {}, request = {}) {
    const uploadMode = this.getUploadMode(); // 上传方式

    return Promise.all([
      // 1. 文件上传日志上报
      this.trackLog(uploadMode, code, response, request),

      // 2. 同名更新日志埋点上报
      this.trackRewriteLog(code, uploadMode),
    ]).catch(e => {});
  }

  // 文件上传日志上报
  trackLog(uploadMode, code, response = {}, request = {}) {
    const { uid } = this.options || {};
    return radar.track({
      user: uid,
      code: code || 'SUCCESS',
      api: RADAR_MODE_MAP[uploadMode] || uploadMode, // 接口名
      mode: RADAR_MODE_NAME_MAP[uploadMode] || uploadMode, // 主调接口服务
      request: jsonStringify({
        ...(this.options || {}),
        ...(typeof request === 'object' ? request : {}),
      }),
      response: this.formattedRaderLogResponse(code, response),
      duration: (this.result && this.result.duration) || 0,
    });
  }

  // 同名更新的远程日志埋点
  async trackRewriteLog(code, uploadMode) {
    const { allowRewrite, pid, uid } = this.options || {};
    const { totalCount, successCount } = this.result || {};

    // 如果是同名更新，添加远程日志打点
    if ([true, 'true'].includes(allowRewrite) && [0, 'SUCCESS'].includes(code)) {
      return radar.log({
        user: uid,
        api: RADAR_MODE_MAP[uploadMode] || uploadMode || '',
        msg: `同名文件更新__总文件数: ${totalCount}__成功上传文件数: ${successCount}__项目pid: ${pid}__上传者: ${uid}`,
      });
    }
  }

  // 日志上报: 语义化执行结果
  formattedRaderLogResponse(code, response = {}) {
    const { result = {}, options = {} } = this;
    const { uid, mode, allowRewrite, pid } = options || {};
    const { totalCount, successCount, failedCount, notExistCount, duration } = result || {};

    // 移除chalk的颜色标识占位符
    let msg = (response && response.msg) || '';
    msg = (msg + '')
      .replace(/\[3\d{1}m/gi, '')
      .replace(/\[3\d{1}m/gi, '')
      .replace(/\u001b/gi, '');

    const uploadMode = this.getUploadMode(); // 上传方式

    let resultStr =
      `上传状态：${['SUCCESS', 0].includes(code) ? '成功' : '失败'}；\n` +
      `总文件数：${totalCount}, 成功上传的文件数: ${successCount}, 失败上传的文件数: ${failedCount}, 不存在跳过的文件数: ${notExistCount}；\n` +
      `总耗时: ${duration} ms；\n` +
      `项目: ${pid}, 是否允许同名更新: ${allowRewrite}, 上传者: ${uid}；\n` +
      `上传方式：${RADAR_MODE_TIP_MAP[uploadMode] || uploadMode || mode}；\n`;
    resultStr += msg ? `报错信息: ${msg}；\n` : '';

    // 流水线相关信息
    const { CI_JOB_ID, BUILD_TAG, BUILD_OWNER } = process.env || {};
    if (CI_JOB_ID) {
      resultStr += `流水线地址：https://halo.corp.kuaishou.com/devcloud/pipeline/history/${CI_JOB_ID}?back=all-pipeline；\n`;
      resultStr += `流水线构建Tag：BUILD_TAG=${BUILD_TAG}，构建用户: ${BUILD_OWNER}；\n`;
    }

    const responseStr = jsonStringify(
      {
        ...(result || {}),
        ...(typeof response === 'object' ? response : {}),
        msg,
        code,
      },
      undefined,
      2
    );
    resultStr += `\n响应详情: \n${responseStr}`;

    return resultStr;
  }

  // 日志上报: 获取文件上传方式
  getUploadMode() {
    const { mode } = this.options || {};
    const { CI_JOB_ID } = process.env || {};
    const isPipeline = !!CI_JOB_ID;
    if (mode === 'cmd' && !isPipeline) return 'cmd';
    if (mode === 'cmd' && isPipeline) return 'pipelineCmd';

    if (!isPipeline) return 'pipelineCustom';
    return 'custom';
  }
};
