const prompt = require('prompt');
const colors = require('colors/safe');
const { getTokenFromCache } = require('./token-cache.js');
const { default: chalk } = require('chalk');

// æ·»åŠ ç€è‰²
prompt.message = colors.green(' ? ');
prompt.delimiter = colors.green('');

const uploadSchema = [
  { name: 'pid', title: 'é¡¹ç›®pid', type: 'string', default: 'fe', required: true },
  {
    name: 'token',
    title: 'é¡¹ç›®token',
    type: 'string',
    message: 'tokenä¸èƒ½ä¸ºç©º',
    required: true,
    ask: () => {
      // å¦‚æžœå·²æœ‰tokenï¼Œåˆ™ä¸å†ç»§ç»­è¯¢é—®
      const pidHistory = prompt.history('pid');
      const pid = pidHistory && pidHistory.value;
      if (!pid) return true;

      const token = getTokenFromCache(pid) || '';
      return !token;
    },
  },
  { name: 'cdnDir', title: 'ç›®æ ‡CDNè·¯å¾„', type: 'string', default: '/', required: false },
  {
    name: 'files',
    title: 'æœ¬åœ°æ–‡ä»¶ç›®å½•/æ–‡ä»¶',
    tip: '(ä»¥ç©ºæ ¼åˆ†éš”)',
    type: 'string',
    default: './',
    required: false,
  },
  // { name: 'allowRewrite', description: 'æ˜¯å¦å¼€å¯åŒåæ–‡ä»¶æ›´æ–°åŠŸèƒ½', ...booleanSchema },
  // { name: 'allowHash', description: 'æ˜¯å¦æ”¯æŒæ–‡ä»¶åhash', ...booleanSchema },
];

/**
 * ä»Žå‘½ä»¤è¡Œæç¤ºä¸­èŽ·å–å‚æ•°
 * @param {Object} params  æ–‡ä»¶ä¸Šä¼ å‚æ•°
 * @returns {Object | NULL}
 */
exports.getArgvFromPrompt = async params => {
  let { pid, token } = params;
  if (pid && token) return {};

  // æ‰“å°æ–‡æ¡£è¯´æ˜Ž
  const projectInfoUrl = 'https://kcdn.corp.kuaishou.com/dashboard/project-info'; // é¡¹ç›®è¯¦æƒ…
  console.log(`ðŸ‘‰ ç‚¹å‡»æŸ¥çœ‹KCDNé¡¹ç›®çš„pidå’Œtoken: ${projectInfoUrl}\n`);
  // console.log(`â­ æ›´å¤šæ–‡æ¡£è¯´æ˜Žè¯·è¯¦çœ‹: ${hl(docUrl)}`);

  // æœ‰å€¼çš„ï¼Œä¸éœ€è¦ç»§ç»­è¾“å…¥
  const filteredSchema = uploadSchema
    .filter(({ name } = {}) => {
      const value = params[name];
      if (name === 'files' && (!value || !value.length)) return true;
      return !value;
    })
    .map(item => {
      const { title, required, tip } = item;
      item.description = `[${required ? 'å¿…å¡«' : 'é€‰å¡«'}] ${required ? `è¯·è¾“å…¥${title}` : title}${tip || ''}`;
      return item;
    });
  prompt.start();

  return new Promise((resolve, reject) => {
    prompt.get(filteredSchema, function (err, data) {
      if (err || !data || typeof data !== 'object') return reject(err);

      // ç§»é™¤å‰åŽç©ºæ ¼
      Object.keys(data).forEach(key => {
        const value = data[key];
        data[key] = typeof value === 'string' ? (value + '').trim() : '';
      });

      // å¾…ä¸Šä¼ æ–‡ä»¶è½¬æ¢æˆæ•°ç»„æ ¼å¼
      data.files = (data.files || '')
        .split(/\s|\,/gi)
        .map(i => i && i.trim())
        .filter(i => i);

      // ä¸å…è®¸ä¸Šä¼ æœ¬åœ°æ ¹ç›®å½•
      if (data.files.includes('/')) return reject('ä¸å…è®¸ä¸Šä¼ æœ¬åœ°æ ¹ç›®å½•');

      // æ— tokenï¼Œä»Žç¼“å­˜ä¸­è¯»å–
      const pid = params.pid || data.pid;
      data.token = params.token || data.token || getTokenFromCache(pid) || '';

      // æ‰“å°è¾“å…¥å‚æ•°
      console.log('=========================');
      Object.keys(data).forEach(key => {
        const item = uploadSchema.filter(({ name } = {}) => name === key)[0];
        const { title } = item || {};
        console.log(`${title || key}: ${chalk.cyan(data[key])}`);
      });
      console.log('=========================');

      resolve(data || {});
    });
  });
};
