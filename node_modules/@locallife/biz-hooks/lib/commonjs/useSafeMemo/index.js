"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

/** useMemo 的安全版本
 *
 * 仅在需要**确保** memo 值在 deps 未发生变化时，factory 不会重新执行的情况下使用。
 * 其他情况还是正常使用原始的 useMemo 即可。
 *
 * Why?
 *
 * useMemo 可以作为优化手段，它返回一个“记忆值”，仅在 deps 发生变化时，才会重新计算新的数据。
 *
 * 但是官方文档中说：
 * **You may rely on useMemo as a performance optimization, not as a semantic guarantee.**
 * In the future, React may choose to “forget” some previously memoized values and recalculate them on next render,
 * e.g. to free memory for offscreen components.
 * Write your code so that it still works without useMemo — and then add it to optimize performance.
 *
 * 所以，在某些条件下，即便 deps 未发生变化，useMemo 也可能会选择性的“忘记”一些数据，并重新计算。
 *
 * useSafeMemo 使用 useRef 来记忆旧值，并且没有实现任何“忘记”逻辑，以此来防数据的重新计算。
 */
const useSafeMemo = (factory, deps) => {
  const value = (0, _react.useRef)();
  const oldDeps = (0, _react.useRef)();

  if (!(oldDeps.current && deps) || oldDeps.current.length !== deps.length || oldDeps.current.some((dep, index) => dep !== deps[index])) {
    oldDeps.current = deps;
    value.current = factory();
  } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


  return value.current;
};

var _default = useSafeMemo;
exports.default = _default;
//# sourceMappingURL=index.js.map