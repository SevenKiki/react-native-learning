"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-use-before-define */
function clone(obj) {
  return typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : obj;
}

function camel2Underline() {
  let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.replaceAll(/[A-Z]/g, i => {
    return '_' + i.toLowerCase();
  });
}

function generateUuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    let r = Math.random() * 16 | 0,
        v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
} // 进行克隆是为了不影响调用侧的参数对象


function preDealOptions(options) {
  return Object.entries(options).reduce((obj, _ref) => {
    let [key, val] = _ref;
    return Object.assign(obj, {
      [camel2Underline(key)]: clone(val)
    });
  }, {
    name: ''
  });
}

const presetStartStatus = ['start', 'START'];
const presetEndStatus = ['end', 'END']; // 默认多步任务时间间隔

const defaultTimeout = 30000;

class LocalLifeTaskLogger {
  /** logFn函数需要能接受处理格式如{name, extra_info, ...other} */
  static setTaskLogFn(logFn) {
    this.taskLogFn = logFn;
  }

  static setErrorLogFn(errorFn) {
    this.errorLogFn = errorFn;
  }

  static task(options) {
    var _this = this;

    let isAsync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let maxLifeTimeBetweenSteps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTimeout;

    if (!this.errorLogFn) {
      throw new Error('You should set error function firstly.');
    }

    if (!this.taskLogFn) {
      this.errorLogFn('You should set log function firstly.');
      return;
    }

    let {
      name,
      extra_info = {},
      status,
      ...other
    } = preDealOptions(options);

    if (!name) {
      this.errorLogFn('event should take a [name] key');
      return;
    } // status处理


    if (!extra_info.status && status) {
      extra_info.status = status;
    } // 单步任务直接发


    if (!isAsync) {
      this.taskLogFn({
        name,
        extra_info,
        ...other
      });
      return;
    } // 多步任务


    if (isAsync) {
      // 默认状态是开始 - 'START'
      if (!extra_info.status) {
        extra_info.status = presetStartStatus[0];
      } // 用于识别任务链


      const taskChainId = generateUuid();
      extra_info.taskChainId = taskChainId; // 发第一个任务埋点

      this.taskLogFn({
        name,
        extra_info,
        ...other
      }); // 任务开始时间

      let statTime = Date.now(); // 上一次任务时间

      let lastTime = statTime; // 任务链

      let taskChain = null; // 记录任务链是否被终止，免去调用时的‘?.’判断

      let ended = false;
      /**
       * 定时器部分
       **/

      let timer = null;

      const setTimer = function () {
        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        const time = timeout || maxLifeTimeBetweenSteps;
        setTimeout(() => {
          // 清掉变量
          end(); // 如果超时，以当前任务报超时错误

          _this.errorLogFn(`task ${taskChainId} timed out for ${time / 1000} second(s).`);
        }, time);
      };

      const clearTimer = () => {
        clearTimeout(timer);
        timer = null;
      };

      setTimer(); // 下一次任务

      /**
       * nextOptions第一层可包含status，若options.extra_info无status字段，外层status字段将会包含在options.extra_info进行埋点发送
       * nextOptions: {name: string, extra_info: any, status?: string, ...other}
       * @param nextOptions 埋点参数
       * @param timeout
       * @returns
       */

      const nextTrigger = function (nextOptions) {
        let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (ended) {
          return;
        }

        let {
          name: nextName = name,
          extra_info: nextExtraInfo = {},
          status: nextStatus,
          ...nextOther
        } = nextOptions;

        if (!nextExtraInfo.status && nextStatus) {
          nextExtraInfo.status = nextStatus;
        }

        nextStatus = nextExtraInfo.status; // status是异常值，空值或者为开始值

        if (!nextStatus || presetStartStatus.includes(nextStatus)) {
          // 先帮你把这个发了
          _this.taskLogFn({
            name: nextName,
            // eslint-disable-next-line camelcase
            extra_info: nextExtraInfo,
            ...nextOther
          }); // 结束当前任务


          end(); // 异常状态报个错

          _this.errorLogFn(`task ${taskChainId} received invalid status - [${nextStatus}].`);

          return;
        }

        const now = Date.now();
        nextExtraInfo = { ...extra_info,
          //初始value，包含了taskChainId
          ...nextExtraInfo,
          // 当次value
          lastStepDuration: now - lastTime // 上一步到当前步骤的耗时

        };
        lastTime = now;

        _this.taskLogFn({
          name: nextName,
          extra_info: nextExtraInfo,
          ...nextOther
        }); // 重置定时


        clearTimer();
        setTimer(timeout); // 当前状态是结束

        if (presetEndStatus.includes(nextStatus)) {
          end();
        } // 使之可以链式调用，end时候会比较有用


        return taskChain;
      }; // 任务超时或结束，清掉变量，记录持续时间


      const end = () => {
        if (ended) {
          return;
        }

        this.taskLogFn({
          name: 'CUSTOM_TASK_CHAIN_LOGGER_END',
          extra_info: {
            duration: lastTime - statTime,
            taskChainId,
            lastStepDuration: Date.now() - lastTime
          }
        });
        clearTimer();
        ended = true;
      };

      taskChain = {
        next: nextTrigger,
        end
      };
      return taskChain;
    }
  }

}

exports.default = LocalLifeTaskLogger;

_defineProperty(LocalLifeTaskLogger, "taskLogFn", void 0);

_defineProperty(LocalLifeTaskLogger, "errorLogFn", void 0);
//# sourceMappingURL=LocalLifeTaskLogger.js.map