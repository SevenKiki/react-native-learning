/* eslint-disable no-use-before-define */

function clone(obj) {
    return typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : obj;
}

function camel2Underline(str = '') {
    return str.replaceAll(/[A-Z]/g, (i) => {
        return '_' + i.toLowerCase();
    });
}

function generateUuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
        /[xy]/g,
        function (c) {
            let r = (Math.random() * 16) | 0,
                v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        },
    );
}

// 进行克隆是为了不影响调用侧的参数对象
function preDealOptions(options) {
    return Object.entries(options).reduce(
        (obj, [key, val]) =>
            Object.assign(obj, { [camel2Underline(key)]: clone(val) }),
        { name: '' },
    );
}

const presetStartStatus = ['start', 'START'];
const presetEndStatus = ['end', 'END'];

// 默认多步任务时间间隔
const defaultTimeout = 30000;

interface LogOption {
    name: string;
    extra_info?: any;
    [key: string]: any;
}

interface CustomOption extends LogOption {
    status?: string;
    extraInfo?: {
        status?: string;
        [key: string]: any;
    };
    extra_info?: {
        status?: string;
        [key: string]: any;
    };
}

export default class LocalLifeTaskLogger {
    private static taskLogFn: any;
    private static errorLogFn: any;
    /** logFn函数需要能接受处理格式如{name, extra_info, ...other} */
    static setTaskLogFn(logFn: (option: LogOption) => void) {
        this.taskLogFn = logFn;
    }

    static setErrorLogFn(errorFn) {
        this.errorLogFn = errorFn;
    }

    static task(
        options: CustomOption,
        isAsync = false as boolean,
        maxLifeTimeBetweenSteps = defaultTimeout as number,
    ) {
        if (!this.errorLogFn) {
            throw new Error('You should set error function firstly.');
        }
        if (!this.taskLogFn) {
            this.errorLogFn('You should set log function firstly.');
            return;
        }

        let {
            name,
            extra_info = {},
            status,
            ...other
        }: CustomOption = preDealOptions(options);

        if (!name) {
            this.errorLogFn('event should take a [name] key');
            return;
        }

        // status处理
        if (!extra_info.status && status) {
            extra_info.status = status;
        }

        // 单步任务直接发
        if (!isAsync) {
            this.taskLogFn({ name, extra_info, ...other });
            return;
        }

        // 多步任务
        if (isAsync) {
            // 默认状态是开始 - 'START'
            if (!extra_info.status) {
                extra_info.status = presetStartStatus[0];
            }
            // 用于识别任务链
            const taskChainId = generateUuid();
            extra_info.taskChainId = taskChainId;

            // 发第一个任务埋点
            this.taskLogFn({
                name,
                extra_info,
                ...other,
            });

            // 任务开始时间
            let statTime = Date.now();
            // 上一次任务时间
            let lastTime = statTime;
            // 任务链
            let taskChain = null as any;
            // 记录任务链是否被终止，免去调用时的‘?.’判断
            let ended = false as boolean;

            /**
             * 定时器部分
             **/
            let timer = null as any;
            const setTimer = (timeout = 0) => {
                const time = timeout || maxLifeTimeBetweenSteps;
                setTimeout(() => {
                    // 清掉变量
                    end();
                    // 如果超时，以当前任务报超时错误
                    this.errorLogFn(
                        `task ${taskChainId} timed out for ${
                            time / 1000
                        } second(s).`,
                    );
                }, time);
            };
            const clearTimer = () => {
                clearTimeout(timer);
                timer = null;
            };
            setTimer();

            // 下一次任务
            /**
             * nextOptions第一层可包含status，若options.extra_info无status字段，外层status字段将会包含在options.extra_info进行埋点发送
             * nextOptions: {name: string, extra_info: any, status?: string, ...other}
             * @param nextOptions 埋点参数
             * @param timeout
             * @returns
             */
            const nextTrigger = (nextOptions: CustomOption, timeout = 0) => {
                if (ended) {
                    return;
                }
                let {
                    name: nextName = name,
                    extra_info: nextExtraInfo = {},
                    status: nextStatus,
                    ...nextOther
                } = nextOptions;
                if (!nextExtraInfo.status && nextStatus) {
                    nextExtraInfo.status = nextStatus;
                }
                nextStatus = nextExtraInfo.status;
                // status是异常值，空值或者为开始值
                if (!nextStatus || presetStartStatus.includes(nextStatus)) {
                    // 先帮你把这个发了
                    this.taskLogFn({
                        name: nextName,
                        // eslint-disable-next-line camelcase
                        extra_info: nextExtraInfo,
                        ...nextOther,
                    });
                    // 结束当前任务
                    end();
                    // 异常状态报个错
                    this.errorLogFn(
                        `task ${taskChainId} received invalid status - [${nextStatus}].`,
                    );
                    return;
                }

                const now = Date.now();
                nextExtraInfo = {
                    ...extra_info, //初始value，包含了taskChainId
                    ...nextExtraInfo, // 当次value
                    lastStepDuration: now - lastTime, // 上一步到当前步骤的耗时
                };

                lastTime = now;

                this.taskLogFn({
                    name: nextName,
                    extra_info: nextExtraInfo,
                    ...nextOther,
                });

                // 重置定时
                clearTimer();
                setTimer(timeout);

                // 当前状态是结束
                if (presetEndStatus.includes(nextStatus)) {
                    end();
                }

                // 使之可以链式调用，end时候会比较有用
                return taskChain;
            };

            // 任务超时或结束，清掉变量，记录持续时间
            const end = () => {
                if (ended) {
                    return;
                }
                this.taskLogFn({
                    name: 'CUSTOM_TASK_CHAIN_LOGGER_END',
                    extra_info: {
                        duration: lastTime - statTime,
                        taskChainId,
                        lastStepDuration: Date.now() - lastTime,
                    },
                });
                clearTimer();
                ended = true;
            };
            taskChain = {
                next: nextTrigger,
                end,
            };
            return taskChain;
        }
    }
}
