import React, { useState, memo, useMemo } from 'react';
import { InteractionManager } from 'react-native';

export const OP_INLINE = 1;
export const OP_IMMEDIATE = 2;
export const OP_NEXT_DRAWFRAME = 3;
export const OP_NEAREST_IDLE_JS = 4;
export const OP_NEAREST_IDLE_INTERACTIVE = 5;

export const schedulers = {
    [OP_INLINE]: (action) => action(), // 无干涉，正常更新DOM
    [OP_IMMEDIATE]: setImmediate, // 在当次JS Event Loop尾部更新DOM
    [OP_NEXT_DRAWFRAME]: requestAnimationFrame, // 在临近一次Native渲染结束后更新DOM
    [OP_NEAREST_IDLE_JS]: requestIdleCallback, // 在下一次JS Event Loop低负载时更新DOM
    [OP_NEAREST_IDLE_INTERACTIVE]: InteractionManager.runAfterInteractions, // 在动画和触控交互结束后更新DOM
};

export interface AlphaProps {
    target: React.ComponentType<any>;
    placeholder?: () => JSX.Element | undefined;
    // 传递给首屏组件的数据
    data?: any;
    schedule?: keyof typeof schedulers;
    timeout?: number;
}

const UPDATE_PROPS_PENDING_UPDATE = 1;
const UPDATE_COMMITIED = 2;

export const Alpha = memo((props: AlphaProps) => {
    const [updateState, setUpdateState] = useState<number>(
        UPDATE_PROPS_PENDING_UPDATE,
    );
    useMemo(() => {
        if (props.schedule === OP_INLINE || props.schedule === OP_IMMEDIATE) {
            if (props.placeholder) {
                console.warn('OP_INLINE 不要使用placeholder');
            }
            return;
        }
        const commit = schedulers[props.schedule || OP_NEXT_DRAWFRAME];
        commit(
            () => {
                setUpdateState(UPDATE_COMMITIED);
            },
            { timeout: props.timeout || 1000 },
        );
    }, []);

    function renderContent() {
        const { target: Target, placeholder } = props;
        if (
            Target &&
            (props.schedule === OP_INLINE || updateState === UPDATE_COMMITIED)
        ) {
            return <Target {...props.data} />;
        }

        return placeholder ? placeholder() : null;
    }

    return renderContent();
});
