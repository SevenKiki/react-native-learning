import React, {
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState,
} from 'react';
import { NativeModules, View, StyleSheet } from 'react-native';
import { Alpha, OP_INLINE, OP_NEXT_DRAWFRAME } from './alpha';
import LoadingScene from './loadingScene';
import ErrorScene from './errorScene';
import { CustomQueryClient } from './customQueryClient';
import { QueryClientProvider, QueryKey } from 'react-query';
import { PageContext } from './pageContext';
import {
    getPageRubasKey,
    pageLog,
    PageRubasRule,
    publishRubas,
    useReportContainer,
} from './log';
import { getErrorCode, getErrorMessage, getRubasTime } from './utils';
import { _AppPropsProvider } from './_AppPropsProvider';
import { useLcpCollect } from './hooks/useLcpCollect';

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
});

export type TAppProps = {
    rootTag: number;
    onCreateTimestamp: number;
    bundleId?: string;
    componentName?: string;
};

export type TPageProps<T extends TAppProps, U extends any> = {
    appProps: T; // 通过native传入的props
    contentPager: React.ComponentType<any>; // 首屏组件
    LoadingComponent?: React.ComponentType<any>; // loading组件
    ErrorComponent?: React.ComponentType<any>; // error组件
    noReport?: boolean; // 是否进行埋点上报
    needLoading?: boolean; // 是否需要loading页面，不填为true
    needError?: boolean; // 是否需要异常页面，默认为true
    onSuccess?: () => void; // 数据处理成功地回调
    onError?: () => void; // 数据处理失败地回调
    queryKey?: QueryKey; // react-query key，需与第一次调用时的key一致
    onRequest?: () => Promise<U>; // 数据请求和处理
    navigationKey?: string; // 页面标识,针对使用react-navigation的情况
    onShowLoading?: () => void; // mount回调
};

enum EAppState {
    LOADING, // 加载状态
    ERROR, // 错误状态
    COMPLETED, // 完成状态
}

// 工程脚手架
export const Page = <T extends TAppProps, U extends any>(
    props: TPageProps<T, U>,
) => {
    _AppPropsProvider.init(props.appProps);
    useReportContainer(props);
    const t2TimeStampRef = useRef(Date.now());
    const [loadedData, setLoadedData] = useState(false);
    const [appState, setAppState] = useState(
        props.needLoading || undefined === props.needLoading
            ? EAppState.LOADING
            : EAppState.COMPLETED,
    );

    const handleResult = useCallback(() => {
        const queryState = CustomQueryClient.get().getQueryState(
            props.queryKey,
        );
        if (queryState.status === 'success') {
            t2TimeStampRef.current = queryState.dataUpdatedAt;
            publishRubas({
                event: getPageRubasKey(
                    props,
                    queryState.errorUpdateCount
                        ? PageRubasRule.apiRetrySuccess
                        : PageRubasRule.apiSuccess,
                ),
            });
            setLoadedData(true);
            setAppState(EAppState.COMPLETED);
            props.onSuccess?.();
        } else if (queryState.status === 'error') {
            if (queryState.errorUpdateCount === 1) {
                publishRubas({
                    event: getPageRubasKey(props, PageRubasRule.apiFailed),
                    payload: {
                        local_life_network_error_code: getErrorCode(
                            queryState?.error,
                        ),
                        local_life_network_error_message: getErrorMessage(
                            queryState?.error,
                        ),
                    },
                });
            }
            setAppState(EAppState.ERROR);
            props.onError?.();
        }
    }, []);

    const handleException = useCallback(() => {
        setAppState(EAppState.ERROR);
        props.onError?.();
        publishRubas({
            event: getPageRubasKey(props, PageRubasRule.apiFailed),
        });
    }, []);

    // 请求数据
    const requestData = useCallback(() => {
        setAppState(EAppState.LOADING);
        // t1上报
        if (!props.noReport) {
            pageLog(
                '分阶段耗时',
                `t1=${Date.now() - props.appProps.onCreateTimestamp}`,
            );
            NativeModules.RootViewPageBridge.rootViewDidMountWith(
                props.appProps.rootTag,
                {},
            );
            publishRubas({
                event: 'local_life_page_on_load_view_t1',
                payload: getRubasTime(Date.now()),
            });
        }
        if (props.queryKey && props.onRequest) {
            props.onRequest().then(handleResult).catch(handleException);
        } else if (!props.noReport) {
            // 无网络请求或者数据处理时，t2、t3上报
            const time2 = Date.now() - props.appProps.onCreateTimestamp;
            NativeModules.RootViewPageBridge.reportPageRenderTime(
                props.appProps.rootTag,
                time2,
                time2,
                {},
            );
        }
    }, []);

    useMemo(requestData, []);
    const { lcpImages } = useLcpCollect();

    useEffect(() => {
        if (loadedData) {
            // 有网络请求或者数据处理时，t2、t3上报
            if (!props.noReport) {
                const t3 = Date.now() - props.appProps.onCreateTimestamp;
                const t2 =
                    t2TimeStampRef.current - props.appProps.onCreateTimestamp;
                NativeModules.RootViewPageBridge.reportPageRenderTime(
                    props.appProps.rootTag,
                    t2,
                    t3,
                    {},
                );
                pageLog('分阶段耗时', `t2=${t2},t3=${t3}`);
                publishRubas({
                    event: 'local_life_page_request_t2',
                    payload: getRubasTime(t2TimeStampRef.current),
                });
                publishRubas({
                    event: 'local_life_page_render_t3',
                    payload: getRubasTime(Date.now()),
                });
            }
            publishRubas({
                event: getPageRubasKey(props, PageRubasRule.pageRender),
            });
        }
    }, [loadedData]);

    // 渲染组件
    function renderContent() {
        const needLoading = !!(
            props.needLoading ||
            undefined === props.needLoading ||
            (props.onRequest && props.queryKey)
        );
        const needError = !!(props.needError || undefined === props.needError);
        return (
            <QueryClientProvider client={CustomQueryClient.get()}>
                <PageContext.Provider
                    value={{ loadedData: loadedData, lcpImages: lcpImages }}
                >
                    <View style={styles.container}>
                        <Alpha
                            target={props.contentPager}
                            schedule={
                                needLoading ? OP_NEXT_DRAWFRAME : OP_INLINE
                            }
                            data={props.appProps}
                        />
                        {needLoading && EAppState.LOADING === appState && (
                            <Alpha
                                target={props.LoadingComponent || LoadingScene}
                                schedule={OP_INLINE}
                            />
                        )}
                        {needError && EAppState.ERROR === appState && (
                            <Alpha
                                target={props.ErrorComponent || ErrorScene}
                                schedule={OP_INLINE}
                                data={{
                                    onRetry: () => {
                                        CustomQueryClient.get()
                                            .refetchQueries(props.queryKey)
                                            .then(handleResult)
                                            .catch(handleException);
                                    },
                                }}
                            />
                        )}
                    </View>
                </PageContext.Provider>
            </QueryClientProvider>
        );
    }

    return renderContent();
};
