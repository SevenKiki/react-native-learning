//*** licence placeholder ***//

package com.facebook.react.tests.diskcache;

import android.content.Context;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;
import bolts.Task;
import com.facebook.cache.common.SimpleCacheKey;
import com.facebook.cache.disk.DiskCacheConfig;
import com.facebook.cache.disk.FileCache;
import com.facebook.imagepipeline.core.DiskStorageCacheFactory;
import com.facebook.imagepipeline.core.DynamicDefaultDiskStorageFactory;
import com.facebook.react.modules.diskcache.FileEntry;
import com.facebook.react.modules.diskcache.FileMeta;
import com.facebook.react.modules.diskcache.MetaDiskCache;
import com.facebook.soloader.SoLoader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.CRC32;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class DiskCacheTest {

  private String mPath;
  private FileCache mFileCache;
  private MetaDiskCache mMetaDiskCache;
  private ByteBuffer mFixBuffer;
  private String mFixKey;

  @Before
  public void setup() {
    Context context = InstrumentationRegistry.getContext();
    SoLoader.init(context, false);
    mPath = context.getFilesDir().getAbsolutePath();
    mFileCache = new DiskStorageCacheFactory(new DynamicDefaultDiskStorageFactory()).get(
        DiskCacheConfig.newBuilder(context)
            .setBaseDirectoryName(mPath)
            .build()
    );
    long start = DiskCacheUtils.startTrace();
    mMetaDiskCache = MetaDiskCache.createMetaDiskCache(DiskCacheConfig.newBuilder(context)
        .setBaseDirectoryPath(new File(mPath + File.separator + "test"))
        .setMaxCacheSize(1024 * 1024 * 40)
        .setIndexPopulateAtStartupEnabled(true)
        .setVersion(1)
        .build(), null, null);
    DiskCacheUtils.endTrace("setup", start);
    mFixBuffer = DiskCacheUtils.createRandomBuffer();
    mFixKey = "core.bundle";
  }

  @Test
  public void writeAndReadFromStagingWithSameKeyAndBuffer() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    FileEntry fileEntry = DiskCacheUtils.createFileEntry(mMetaDiskCache, mFixBuffer);
    mMetaDiskCache.put(simpleCacheKey, fileEntry);

    Assert.assertTrue(mMetaDiskCache.containsSync(simpleCacheKey));
    mMetaDiskCache.get(simpleCacheKey, new AtomicBoolean(false)).continueWith(task -> {
      FileEntry resultEntry = task.getResult();
      Assert.assertTrue(resultEntry.verifyMeta());
      Assert.assertTrue(resultEntry.verifyData(true));
      Assert.assertTrue((fileEntry.getFileMeta().testEquals(resultEntry.getFileMeta())));

      mMetaDiskCache.remove(simpleCacheKey);
      return null;
    });
    didFinishTest();
  }

  @Test
  public void writeAndReadFromFileWithSameKeyAndBuffer() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    FileEntry fileEntry = DiskCacheUtils.createFileEntry(mMetaDiskCache, mFixBuffer);
    long start = DiskCacheUtils.startTrace();
    mMetaDiskCache.putAsync(simpleCacheKey, fileEntry).continueWith(task -> {
      DiskCacheUtils.endTrace("MetaDiskCache Write:", start);
      long start1 = DiskCacheUtils.startTrace();
      mMetaDiskCache.get(simpleCacheKey, new AtomicBoolean(false)).continueWith(task1 -> {
        DiskCacheUtils.endTrace("MetaDiskCache Read:", start1);
        FileEntry resultEntry = task1.getResult();
        Assert.assertTrue(resultEntry.verifyMeta());
        Assert.assertTrue(resultEntry.verifyData(true));
        Assert.assertTrue((fileEntry.getFileMeta().testEquals(resultEntry.getFileMeta())));

        mMetaDiskCache.remove(simpleCacheKey);
        return null;
      });
      return null;
    });
    didFinishTest();
  }

  @Test
  public void deleteAndRead() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    mMetaDiskCache.remove(simpleCacheKey).continueWith(task -> {
      Assert.assertFalse(mMetaDiskCache.containsSync(simpleCacheKey));
      mMetaDiskCache.get(simpleCacheKey, new AtomicBoolean(false)).continueWith(task1 -> {
        Assert.assertNull(task1.getResult());
        return null;
      });
      return null;
    });
    mMetaDiskCache.contains(simpleCacheKey).continueWith(task -> {
      Assert.assertFalse(task.getResult());
      return null;
    });
    didFinishTest();
  }

  @Test
  public void modifyFromStaging() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    FileEntry fileEntry = DiskCacheUtils.createFileEntry(mMetaDiskCache, mFixBuffer);

    ByteBuffer randomBuffer = DiskCacheUtils.createRandomBuffer(DiskCacheUtils.M);
    CRC32 crc32 = new CRC32();
    crc32.update(randomBuffer.array());
    FileMeta.Builder builder = new FileMeta.Builder();
    builder.setFlags(0).setCrc32((int) crc32.getValue()).setDataSize(DiskCacheUtils.M)
        .setV8Version(10)
        .setCachedDataVersion(11).setEncoding(12);
    FileEntry newFileEntry = DiskCacheUtils
        .createFileEntryWithMeta(mMetaDiskCache, randomBuffer, builder.build());

    mMetaDiskCache.put(simpleCacheKey, fileEntry);
    mMetaDiskCache.put(simpleCacheKey, newFileEntry);

    mMetaDiskCache.get(simpleCacheKey, new AtomicBoolean(false)).continueWith(task -> {
      FileEntry fileEntry1 = task.getResult();
      Assert.assertTrue(fileEntry1.verifyMeta());
      Assert.assertTrue(fileEntry1.verifyData(true));
      Assert.assertTrue((newFileEntry.getFileMeta().testEquals(fileEntry1.getFileMeta())));
      return null;
    });
    didFinishTest();
  }

  @Test
  public void concurrentModifyForRobustTest() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);

    List<Runnable> runnables = new ArrayList<>();

    AtomicInteger sizeMultiplier = new AtomicInteger(1);
    Callable<FileEntry> createRandomFileEntry = () -> {
      int size = DiskCacheUtils.M * sizeMultiplier.getAndIncrement();
      ByteBuffer randomBuffer = DiskCacheUtils.createRandomBuffer(size);
      CRC32 crc32 = new CRC32();
      crc32.update(randomBuffer.array());
      FileMeta.Builder builder = new FileMeta.Builder();
      builder.setFlags(0).setCrc32((int) crc32.getValue()).setDataSize(size).setV8Version(10)
          .setCachedDataVersion(11).setEncoding(12);
      return DiskCacheUtils.createFileEntryWithMeta(mMetaDiskCache, randomBuffer, builder.build());
    };

    runnables.add(() -> {
      try {
        mMetaDiskCache.put(simpleCacheKey, createRandomFileEntry.call());
      } catch (Exception e) {
        e.printStackTrace();
      }
    });

    runnables.add(() -> {
      mMetaDiskCache.remove(simpleCacheKey);
    });

    runnables.add(() -> {
      try {
        mMetaDiskCache.put(simpleCacheKey, createRandomFileEntry.call());
      } catch (Exception e) {
        e.printStackTrace();
      }
    });

    runnables.add(() -> {
      mMetaDiskCache.get(simpleCacheKey, new AtomicBoolean(false));
    });

    runnables.add(() -> {
      mMetaDiskCache.clearAll();
    });

    runnables.add(() -> {
      try {
        mMetaDiskCache.put(simpleCacheKey, createRandomFileEntry.call());
      } catch (Exception e) {
        e.printStackTrace();
      }
    });

    try {
      DiskCacheUtils.assertConcurrent("", runnables, 100);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    didFinishTest();
  }

  @Test
  public void setMaxSize() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    FileEntry fileEntry = DiskCacheUtils
        .createFileEntry(mMetaDiskCache, DiskCacheUtils.createRandomBuffer(50 * DiskCacheUtils.M));

    mMetaDiskCache.clearAll();
    mMetaDiskCache.putAsync(simpleCacheKey, fileEntry).continueWith(task -> {
      SimpleCacheKey simpleCacheKey1 = new SimpleCacheKey("1");
      FileEntry fileEntry1 = DiskCacheUtils
          .createFileEntry(mMetaDiskCache,
              DiskCacheUtils.createRandomBuffer(30 * DiskCacheUtils.M));

      mMetaDiskCache.putAsync(simpleCacheKey1, fileEntry1).continueWith(task1 -> {
        Assert.assertEquals(mMetaDiskCache.getSize(), 30 * DiskCacheUtils.M + FileMeta.SIZE);
        Assert.assertFalse(mMetaDiskCache.containsSync(simpleCacheKey));
        Assert.assertTrue(mMetaDiskCache.containsSync(simpleCacheKey1));
        return null;
      });
      return null;
    });
    didFinishTest();
  }

  @Test
  public void evictLRU() {
    for (int i = 0; i < 6; ++i) {
      ByteBuffer randomBuffer = DiskCacheUtils.createRandomBuffer(10 * DiskCacheUtils.M);
      mMetaDiskCache
          .put(new SimpleCacheKey(String.valueOf(i)),
              DiskCacheUtils.createFileEntry(mMetaDiskCache, randomBuffer));
      didFinishTest();
    }
    didFinishTest();
    Assert.assertFalse(mMetaDiskCache.checkDisk(new SimpleCacheKey("1")));
    didFinishTest();
  }

  @Test
  public void testMetaDiskCache() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    FileEntry fileEntry = DiskCacheUtils
        .createFileEntry(mMetaDiskCache, DiskCacheUtils.createRandomBuffer());
    mMetaDiskCache.put(simpleCacheKey, fileEntry);
    AtomicBoolean isCancelled = new AtomicBoolean(false);
    Task<FileEntry> fileEntryTask = mMetaDiskCache.get(simpleCacheKey, isCancelled);
    fileEntryTask.continueWith(task -> {
      FileEntry fileEntry1 = task.getResult();
      return null;
    });
    didFinishTest();
  }

  @Test
  public void testFrescoDiskCache() {
    try {
      ByteBuffer byteBuffer = DiskCacheUtils.createRandomBuffer();
      long start = DiskCacheUtils.startTrace();
      mFileCache.insert(new SimpleCacheKey(mFixKey), os -> {
        os.write(byteBuffer.array());
        DiskCacheUtils.endTrace("testFrescoDiskCache write:", start);
      });
    } catch (IOException ioException) {
      ioException.printStackTrace();
    }
    didFinishTest();
  }

  @Test
  public void testNormalIO() {
    final String path = mPath + File.separator + "test.txt";
    ByteBuffer byteBuffer = DiskCacheUtils.createRandomBuffer();
    int length = byteBuffer.array().length;
    long start = DiskCacheUtils.startTrace();
    try (FileOutputStream fileOutputStream = new FileOutputStream(path)) {
      fileOutputStream.write(byteBuffer.array());
      DiskCacheUtils.endTrace("testNormalIO write:", start);

      long start1 = DiskCacheUtils.startTrace();
      try (FileInputStream fileInputStream = new FileInputStream(path)) {
        byte[] buffer = new byte[length];
        fileInputStream.read(buffer, 0, length);
        DiskCacheUtils.endTrace("testNormalIO read:", start1);
      }
    } catch (IOException ioException) {
      ioException.printStackTrace();
    }
  }

  @Test
  public void testPreload() {
    SimpleCacheKey simpleCacheKey = new SimpleCacheKey(mFixKey);
    ByteBuffer byteBuffer = DiskCacheUtils.createRandomBuffer();
    FileEntry fileEntry = DiskCacheUtils.createFileEntry(mMetaDiskCache, byteBuffer);
    mMetaDiskCache.put(simpleCacheKey, fileEntry);
    DiskCacheUtils.sleep(3);

    long start = DiskCacheUtils.startTrace();
    FileEntry fileEntry1 = mMetaDiskCache.getSync(simpleCacheKey);
    Assert.assertNotNull(fileEntry1);
    DiskCacheUtils.endTrace("regular get", start);

    DiskCacheUtils.sleep(1);

    mMetaDiskCache.preload(simpleCacheKey, new AtomicBoolean(false));
    DiskCacheUtils.sleep(3);
    start = DiskCacheUtils.startTrace();
    FileEntry fileEntry2 = mMetaDiskCache.getSync(simpleCacheKey);
    Assert.assertNotNull(fileEntry2);
    DiskCacheUtils.endTrace("preload get", start);

    didFinishTest();
  }

  private void didFinishTest() {
    DiskCacheUtils.sleep(3);
  }

}
