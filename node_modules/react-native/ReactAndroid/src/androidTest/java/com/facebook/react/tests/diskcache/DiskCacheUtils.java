//*** licence placeholder ***//

package com.facebook.react.tests.diskcache;

import android.util.Log;
import com.facebook.common.memory.PooledByteBuffer;
import com.facebook.common.references.CloseableReference;
import com.facebook.react.modules.diskcache.FileEntry;
import com.facebook.react.modules.diskcache.FileMeta;
import com.facebook.react.modules.diskcache.MetaDiskCache;
import java.nio.ByteBuffer;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.zip.CRC32;
import org.junit.Assert;

public class DiskCacheUtils {

  public final static String TAG = "DiskCacheTest";
  public final static int K = 1024;
  public final static int M = 1024 * 1024;

  public static FileEntry createFileEntry(final MetaDiskCache metaDiskCache,
      final ByteBuffer byteBuffer) {
    long start = startTrace();
    CRC32 crc32 = new CRC32();
    crc32.update(byteBuffer.array());
    endTrace("crc ", start);
    return createFileEntryWithMeta(metaDiskCache, byteBuffer,
        FileMeta.createStub((int) crc32.getValue(), byteBuffer.array().length));
  }

  public static FileEntry createFileEntryWithMeta(final MetaDiskCache metaDiskCache,
      final ByteBuffer byteBuffer, final FileMeta fileMeta) {
    long start = startTrace();
    ByteBuffer totalBuffer = ByteBuffer.allocate(FileMeta.SIZE + byteBuffer.array().length);
    totalBuffer.put(fileMeta.serialize());
    totalBuffer.put(byteBuffer).flip();
    CloseableReference<PooledByteBuffer> ref = CloseableReference
        .of(metaDiskCache.getPooledByteBufferFactory().newByteBuffer(totalBuffer.array()));
    endTrace("create ", start);
    start = startTrace();
    FileEntry fileEntry = FileEntry.createWithMeta(ref, fileMeta);
    endTrace("create finish", start);
    return fileEntry;
  }

  public static long startTrace() {
    return System.currentTimeMillis();
  }

  public static void endTrace(final String message, long start) {
    Log.e(TAG, message + ":" + (System.currentTimeMillis() - start));
  }

  public static void sleep(int second) {
    try {
      Thread.sleep(second * 1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public static ByteBuffer createRandomBuffer() {
    return createRandomBuffer(10 * M);
  }

  public static ByteBuffer createRandomBuffer(int length) {
    byte[] bytes = new byte[length];
    SecureRandom secureRandom = new SecureRandom();
    secureRandom.nextBytes(bytes);
    return ByteBuffer.wrap(bytes);
  }

  // https://github.com/junit-team/junit4/wiki/Multithreaded-code-and-concurrency
  public static void assertConcurrent(final String message,
      final List<? extends Runnable> runnables, final int maxTimeoutSeconds)
      throws InterruptedException {
    final int numThreads = runnables.size();
    final List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());
    final ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
    try {
      final CountDownLatch allExecutorThreadsReady = new CountDownLatch(numThreads);
      final CountDownLatch afterInitBlocker = new CountDownLatch(1);
      final CountDownLatch allDone = new CountDownLatch(numThreads);
      for (final Runnable submittedTestRunnable : runnables) {
        threadPool.submit(new Runnable() {
          public void run() {
            allExecutorThreadsReady.countDown();
            try {
              afterInitBlocker.await();
              submittedTestRunnable.run();
            } catch (final Throwable e) {
              exceptions.add(e);
            } finally {
              allDone.countDown();
            }
          }
        });
      }
      // wait until all threads are ready
      Assert.assertTrue(
          "Timeout initializing threads! Perform long lasting initializations before passing runnables to assertConcurrent",
          allExecutorThreadsReady.await(runnables.size() * 10, TimeUnit.MILLISECONDS));
      // start all test runners
      afterInitBlocker.countDown();
      Assert.assertTrue(message + " timeout! More than" + maxTimeoutSeconds + "seconds",
          allDone.await(maxTimeoutSeconds, TimeUnit.SECONDS));
    } finally {
      threadPool.shutdownNow();
    }
    Assert.assertTrue(message + "failed with exception(s)" + exceptions, exceptions.isEmpty());
  }
}
