//*** licence placeholder ***//

package com.facebook.base.cache;

import androidx.annotation.NonNull;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import javax.annotation.concurrent.NotThreadSafe;

@NotThreadSafe
public class FileUtilsAndroid {

  public static void write(RandomAccessFile randomAccessFile, int offset, byte[] buffer,
      int bufLength) throws IOException {
    if (randomAccessFile == null || offset < 0 || bufLength < 0) {
      throw new RuntimeException("invalid read params");
    }

    randomAccessFile.seek(offset);
    randomAccessFile.write(buffer, 0, bufLength);
  }

  /**
   * @param randomAccessFile already opened fd
   * @param offset file offset, NOT buffer offset
   * @param size expected read size
   * @return
   * @throws RuntimeException
   * @throws IOException
   */
  public static ByteBuffer read(RandomAccessFile randomAccessFile, int offset, int size)
      throws RuntimeException, IOException {
    // sanity check
    if (randomAccessFile == null || offset < 0 || size < 0) {
      throw new RuntimeException("invalid read params");
    }

    if (!randomAccessFile.getFD().valid()) {
      throw new RuntimeException("fd invalid");
    }

    // move the cursor to offset
    randomAccessFile.seek(offset);

    // read data
    byte[] buffer = new byte[size];
    int readSize = 0;
    while (readSize < size) {
      int sizeStep = randomAccessFile.read(buffer, readSize, size - readSize);
      if (sizeStep == -1) {
        // end of file
        break;
      }
      readSize += sizeStep;
    }

    // content validation check
    if (readSize != size) {
      throw new IOException("Unexpected size of read content");
    }
    return ByteBuffer.wrap(buffer);
  }

  public static ByteBuffer read(InputStream inputStream, int offset, int size) throws IOException {
    return read(inputStream, offset, size, false);
  }

  public static ByteBuffer read(InputStream inputStream, int offset, int size, boolean isDirect)
      throws IndexOutOfBoundsException, IOException {
    // sanity check
    if (inputStream == null || offset < 0 || size < 0) {
      throw new IndexOutOfBoundsException("invalid read params");
    }

    skip(inputStream, offset);

    // read data
    ByteBuffer buffer;
    if (isDirect) {
      buffer = ByteBuffer.allocateDirect(size);
    } else {
      buffer = ByteBuffer.allocate(size);
    }
    int readSize = 0;
    while (readSize < size) {
      int sizeStep = inputStream.read(buffer.array(), readSize, size - readSize);
      if (sizeStep == -1) {
        // end of file
        break;
      }
      readSize += sizeStep;
    }

    // content validation check
    if (readSize != size) {
      throw new IOException("Unexpected size of read content");
    }
    return buffer;
  }

  public static void skip(InputStream inputStream, long size) throws IOException {
    // sanity check
    if (inputStream == null || size < 0) {
      throw new IndexOutOfBoundsException("invalid read params");
    }

    long skipSize = inputStream.skip(size);
    if (skipSize != size) {
      throw new IOException("skip failed");
    }
  }

  public static int read(@NonNull InputStream in, @NonNull byte[] b, int off, int len)
      throws IOException {
    if (len < 0) {
      throw new IndexOutOfBoundsException("len is negative");
    }
    int total = 0;
    while (total < len) {
      int result = in.read(b, off + total, len - total);
      if (result == -1) {
        break;
      }
      total += result;
    }
    return total;
  }

  public static boolean delete(final String path) {
    boolean ret = false;
    try {
      ret = new File(path).delete();
    } catch (Exception e) {
      e.printStackTrace();
      return ret;
    }
    return ret;
  }

}
