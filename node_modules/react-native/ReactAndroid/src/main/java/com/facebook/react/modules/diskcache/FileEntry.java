//*** licence placeholder ***//

package com.facebook.react.modules.diskcache;

import androidx.annotation.NonNull;
import com.facebook.base.cache.FileUtilsAndroid;
import com.facebook.common.logging.FLog;
import com.facebook.common.memory.PooledByteBuffer;
import com.facebook.common.memory.PooledByteBufferInputStream;
import com.facebook.common.references.CloseableReference;
import com.facebook.infer.annotation.Assertions;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.zip.CRC32;
import javax.annotation.Nullable;

public class FileEntry implements Closeable {

  private final @Nullable
  CloseableReference<PooledByteBuffer> mPooledByteBufferRef;

  private boolean mIsPreload = false;

  private boolean mFromMemory = false;

  private FileMeta mFileMeta = null;
  private boolean mHasVerifiedMeta = false;
  private boolean mHasVerifiedData = false;

  /**
   * Create from entire file content. Mostly for reading from file cache. Meta is deserialized from header of the content.
   * @param pooledByteBufferRef is the entire file content. Direct buffer inside.
   * @return file entry with meta verified.
   */
  public static FileEntry create(CloseableReference<PooledByteBuffer> pooledByteBufferRef) {
    FileEntry fileEntry = new FileEntry(pooledByteBufferRef, null);
    boolean ret = fileEntry.verifyMeta();
    return ret ? fileEntry : null;
  }

  /**
   * Create from file content and user-defined file meta. Skip deserializing meta if not null.
   * @param pooledByteBufferRef is the entire file content. Any buffer inside.
   * @param fileMeta is user-defined meta.
   * @return file entry with meta verified.
   */
  public static FileEntry createWithMeta(CloseableReference<PooledByteBuffer> pooledByteBufferRef,
      final FileMeta fileMeta) {
    FileEntry fileEntry = new FileEntry(pooledByteBufferRef, fileMeta);
    boolean ret = fileEntry.verifyMeta();
    return ret ? fileEntry : null;
  }

  /**
   * Create from data buffer and user-defined meta. Mostly for writing to file cache.
   * @param metaDiskCache is used for buffer allocation.
   * @param byteBuffer heap buffer.
   * @param fileMeta user-defined meta.
   * @return file entry with meta verified.
   */
  public static FileEntry createWithDataAndMeta(@NonNull MetaDiskCache metaDiskCache,
      ByteBuffer byteBuffer, final FileMeta fileMeta) {
    Assertions.assertCondition(!byteBuffer.isDirect());
    byteBuffer.rewind();
    byteBuffer.put(fileMeta.serialize()).rewind();
    // TODO:复用byteBuffer减少分配大内存
    CloseableReference<PooledByteBuffer> ref = CloseableReference
        .of(metaDiskCache.getPooledByteBufferFactory().newByteBuffer(byteBuffer.array()));
    return FileEntry.createWithMeta(ref, fileMeta);
  }

  private FileEntry(CloseableReference<PooledByteBuffer> pooledByteBufferRef,
      @Nullable FileMeta fileMeta) {
    Assertions.assertCondition(CloseableReference.isValid(pooledByteBufferRef));
    this.mPooledByteBufferRef = pooledByteBufferRef.clone();
    if (fileMeta != null) {
      this.mFileMeta = fileMeta;
    } else {
      initializeMetaIfNeeded();
    }
  }

  /**
   * Returns the cloned file entry if the parameter received is not null, null otherwise.
   *
   * @param fileEntry the FileEntry to clone
   */
  public static @Nullable
  FileEntry cloneOrNull(FileEntry fileEntry) {
    return fileEntry != null ? fileEntry.cloneOrNull() : null;
  }

  private @Nullable
  FileEntry cloneOrNull() {
    FileEntry fileEntry;
    CloseableReference<PooledByteBuffer> pooledByteBufferRef =
        CloseableReference.cloneOrNull(mPooledByteBufferRef);
    try {
      fileEntry =
          (pooledByteBufferRef == null) ? null : createWithMeta(pooledByteBufferRef, getFileMeta());
    } finally {
      // Close the recently created reference since it will be cloned again in the constructor.
      CloseableReference.closeSafely(pooledByteBufferRef);
    }
    if (fileEntry != null) {
      fileEntry.copyStateFrom(this);
    }
    return fileEntry;
  }

  /**
   * Closes the buffer enclosed by this class.
   */
  @Override
  public void close() {
    CloseableReference.closeSafely(mPooledByteBufferRef);
  }

  /**
   * Returns true if the internal buffer reference is valid or the InputStream Supplier is not null,
   * false otherwise.
   */
  public synchronized boolean isValid() {
    return CloseableReference.isValid(mPooledByteBufferRef);
  }

  /**
   * Returns a cloned reference to the stored encoded bytes.
   *
   * <p>The caller has to close the reference once it has finished using it.
   */
  public CloseableReference<PooledByteBuffer> getByteBufferRef() {
    return CloseableReference.cloneOrNull(mPooledByteBufferRef);
  }

  /**
   * Returns an InputStream from the internal InputStream Supplier if it's not null. Otherwise
   * returns an InputStream for the internal buffer reference if valid and null otherwise.
   *
   * <p>The caller has to close the InputStream after using it.
   */
  public @Nullable
  InputStream getInputStream() {
    CloseableReference<PooledByteBuffer> pooledByteBufferRef =
        CloseableReference.cloneOrNull(mPooledByteBufferRef);
    if (pooledByteBufferRef != null) {
      try {
        return new PooledByteBufferInputStream(pooledByteBufferRef.get());
      } finally {
        CloseableReference.closeSafely(pooledByteBufferRef);
      }
    }
    return null;
  }

  public boolean getIsPreload() {
    return mIsPreload;
  }

  public void setPreload(boolean preload) {
    mIsPreload = preload;
  }

  public boolean getFromMemory() {
    return mFromMemory;
  }

  public void setFromMemory(boolean fromMemory) {
    this.mFromMemory = fromMemory;
  }

  public @Nullable
  InputStream getMetaInputStream() {
    ByteBuffer byteBuffer = ByteBuffer.wrap(mFileMeta.serialize());
    return new ByteArrayInputStream(byteBuffer.array());
  }

  /**
   * Initialize file meta if null.
   */
  public boolean verifyMeta() {
    if (mHasVerifiedMeta) {
      return true;
    }

    if (!initializeMetaIfNeeded()) {
      return false;
    }

    if (!isMetaDataAvailable()) {
      return false;
    }

    mHasVerifiedMeta = true;
    return true;
  }

  private boolean initializeMetaIfNeeded() {
    if (mFileMeta == null && isValid()) {
      try (InputStream inputStream = getInputStream()) {
        ByteBuffer metaBuffer = FileUtilsAndroid.read(inputStream, 0, FileMeta.SIZE);
        mFileMeta = FileMeta.deserialize(metaBuffer.array());
        return true;
      } catch (IOException ioException) {
        return false;
      }
    }

    return mFileMeta != null;
  }

  public boolean verifyData(boolean verifyCRC) {
    try (InputStream inputStream = getInputStream()) {
      // TODO:渐进CRC避免分配大内存OOM
      ByteBuffer dataBuffer = FileUtilsAndroid
          .read(inputStream, FileMeta.SIZE, mFileMeta.getDataSize());
      if (dataBuffer.array().length != mFileMeta.getDataSize()) {
        return false;
      }

      if (verifyCRC) {
        CRC32 crc32 = new CRC32();
        crc32.update(dataBuffer.array());
        return (int) crc32.getValue() == mFileMeta.getCrc32();
      }
    } catch (IOException ioException) {
      return false;
    } catch (IndexOutOfBoundsException indexOutOfBoundsException) {
      return false;
    }

    mHasVerifiedData = true;
    return true;
  }

  /**
   * Get file content.
   * @param verifyCRC true if users need an integrity check.
   * @return Direct buffer.
   */
  public ByteBuffer getData(boolean verifyCRC) {
    if (!mHasVerifiedData && !verifyData(verifyCRC)) {
      return null;
    }

    if (mHasVerifiedMeta) {
      ByteBuffer bufferRef = getByteBufferRef().get().getByteBuffer();
      Assertions.assertNotNull(bufferRef);

      // Pass a duplicated direct buffer to native. It is released by native.
      bufferRef.position(FileMeta.SIZE);
      ByteBuffer directBuffer = ByteBuffer.allocateDirect(mFileMeta.getDataSize());
      directBuffer.put(bufferRef).flip();
      bufferRef.rewind();
      Assertions.assertCondition(directBuffer.isDirect());
      return directBuffer;
    } else {
      FLog.e(MetaDiskCache.TAG, "getData: meta has not been verified");
    }
    return null;
  }

  public FileMeta getFileMeta() {
    return mFileMeta;
  }

  /**
   * Copy the meta data from another FileEntry.
   *
   * @param fileEntry the FileEntry to copy the meta data from.
   */
  public void copyStateFrom(FileEntry fileEntry) {
    mHasVerifiedMeta = fileEntry.mHasVerifiedMeta;
    mHasVerifiedData = fileEntry.mHasVerifiedData;
  }

  /**
   * Returns true if all the image information has loaded, false otherwise.
   */
  public boolean isMetaDataAvailable() {
    return mFileMeta.getSerialVersionUID() == FileMeta.MAGIC &&
        mFileMeta.getDataSize() > 0;
  }

  /**
   * Closes the file entry handling null.
   *
   * @param fileEntry the file entry to close.
   */
  public static void closeSafely(@Nullable FileEntry fileEntry) {
    if (fileEntry != null) {
      fileEntry.close();
    }
  }

  /**
   * Checks if the file entry is valid i.e. is not null, and is not closed.
   *
   * @return true if the file entry is valid
   */
  public static boolean isValid(@Nullable FileEntry fileEntry) {
    return fileEntry != null && fileEntry.isValid();
  }
}
