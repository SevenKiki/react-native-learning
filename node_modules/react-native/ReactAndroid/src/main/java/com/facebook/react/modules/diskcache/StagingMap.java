//*** licence placeholder ***//

package com.facebook.react.modules.diskcache;

import androidx.annotation.GuardedBy;
import androidx.annotation.Nullable;
import com.facebook.cache.common.CacheKey;
import com.facebook.common.logging.FLog;
import com.facebook.common.memory.PooledByteBuffer;
import com.facebook.common.references.CloseableReference;
import com.facebook.infer.annotation.Assertions;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StagingMap {
  private static final Class<?> TAG = StagingMap.class;

  @GuardedBy("this")
  private Map<CacheKey, FileEntry> mMap;

  private StagingMap() {
    mMap = new HashMap<>();
  }

  public static StagingMap getInstance() {
    return new StagingMap();
  }

  /**
   * Stores key-value in this StagingQueue. This call overrides previous value
   * of stored reference if
   * @param key
   * @param fileEntry FileEntry to be associated with key
   */
  public synchronized void put(final CacheKey key, final FileEntry fileEntry) {
    Assertions.assertNotNull(key);
    Assertions.assertCondition(FileEntry.isValid(fileEntry));

    // we're making a 'copy' of this reference - so duplicate it
    final FileEntry oldEntry = mMap.put(key, FileEntry.cloneOrNull(fileEntry));
    FileEntry.closeSafely(oldEntry);
    logStats();
  }

  public synchronized void putIfNotExist(final CacheKey key, final FileEntry fileEntry) {
    Assertions.assertNotNull(key);
    Assertions.assertCondition(FileEntry.isValid(fileEntry));

    // we're making a 'copy' of this reference - so duplicate it
    if (!mMap.containsKey(key)) {
      final FileEntry oldEntry = mMap.put(key, FileEntry.cloneOrNull(fileEntry));
      FileEntry.closeSafely(oldEntry);
    } else {
      FileEntry.closeSafely(fileEntry);
    }
    logStats();
  }

  public synchronized void clearPreload(final CacheKey key) {
    Assertions.assertNotNull(key);

    FileEntry fileEntry = mMap.get(key);
    if (fileEntry != null && fileEntry.getIsPreload()) {
      mMap.remove(key);
      FileEntry.closeSafely(fileEntry);
    }
    logStats();
  }

  /**
   * Removes all items from the StagingQueue.
   */
  public void clearAll() {
    final List<FileEntry> old;
    synchronized (this) {
      old = new ArrayList<>(mMap.values());
      mMap.clear();
    }
    for (int i = 0; i < old.size(); i++) {
      FileEntry fileEntry = old.get(i);
      if (fileEntry != null) {
        fileEntry.close();
      }
    }
  }

  /**
   * Removes item from the StagingQueue.
   * @param key
   * @return true if item was removed
   */
  public boolean remove(final CacheKey key) {
    Assertions.assertNotNull(key);
    final FileEntry fileEntry;
    synchronized (this) {
      fileEntry = mMap.remove(key);
    }
    if (fileEntry == null) {
      return false;
    }
    try {
      return fileEntry.isValid();
    } finally {
      fileEntry.close();
    }
  }

  /**
   * Removes key-value from the StagingQueue. Both key and value must match.
   * @param key
   * @param fileEntry value corresponding to key
   * @return true if item was removed
   */
  public synchronized boolean remove(final CacheKey key, final FileEntry fileEntry) {
    Assertions.assertNotNull(key);
    Assertions.assertNotNull(fileEntry);
    Assertions.assertCondition(FileEntry.isValid(fileEntry));

    final FileEntry oldValue = mMap.get(key);

    if (oldValue == null) {
      return false;
    }

    CloseableReference<PooledByteBuffer> oldRef = oldValue.getByteBufferRef();
    CloseableReference<PooledByteBuffer> ref = fileEntry.getByteBufferRef();
    try {
      if (oldRef == null || ref == null || oldRef.get() != ref.get()) {
        return false;
      }
      mMap.remove(key);
    } finally {
      CloseableReference.closeSafely(ref);
      CloseableReference.closeSafely(oldRef);
      FileEntry.closeSafely(oldValue);
    }

    logStats();
    return true;
  }

  /**
   * @param key
   * @return value associated with given key or null if no value is associated
   */
  public synchronized @Nullable
  FileEntry get(final CacheKey key) {
    Assertions.assertNotNull(key);
    FileEntry fileEntry = mMap.get(key);
    if (fileEntry != null) {
      synchronized (fileEntry) {
        if (!FileEntry.isValid(fileEntry)) {
          // Reference is not valid, this means that someone cleared reference while it was still in
          // use. Log error
          // TODO: 3697790
          mMap.remove(key);
          FLog.w(
              TAG,
              "Found closed reference %d for key %s (%d)",
              System.identityHashCode(fileEntry),
              key.getUriString(),
              System.identityHashCode(key));
          return null;
        }
        fileEntry = FileEntry.cloneOrNull(fileEntry);
      }
    }
    return fileEntry;
  }

  /**
   * Determine if an valid entry for the key exists in the staging area.
   */
  public synchronized boolean containsKey(CacheKey key) {
    Assertions.assertNotNull(key);
    if (!mMap.containsKey(key)) {
      return false;
    }
    FileEntry fileEntry = mMap.get(key);
    synchronized (fileEntry) {
      if (!FileEntry.isValid(fileEntry)) {
        // Reference is not valid, this means that someone cleared reference while it was still in
        // use. Log error
        // TODO: 3697790
        mMap.remove(key);
        FLog.w(
            TAG,
            "Found closed reference %d for key %s (%d)",
            System.identityHashCode(fileEntry),
            key.getUriString(),
            System.identityHashCode(key));
        return false;
      }
      return true;
    }
  }

  /**
   * Simple 'debug' logging of stats.
   */
  private synchronized void logStats() {
    FLog.v(TAG, "Count = %d", mMap.size());
  }

}
