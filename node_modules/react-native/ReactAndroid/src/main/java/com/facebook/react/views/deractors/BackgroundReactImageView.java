/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.react.views.deractors;

import java.util.Arrays;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Path;
import android.graphics.RectF;

import androidx.annotation.Nullable;

import com.facebook.drawee.controller.AbstractDraweeControllerBuilder;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.uimanager.FloatUtil;
import com.facebook.react.views.image.GlobalImageLoadListener;
import com.facebook.react.views.image.ReactImageView;
import com.facebook.yoga.YogaConstants;

public class BackgroundReactImageView extends ReactImageView {
  private float mCorners;
  private @Nullable
  float[] mBorderCornerRadii;
  private ScaleTypeBackgroundImage mScaleTypeBackgroundImage;
  private Path mPath;
  private float[] mRadii;
  private RectF mRectF;

  public BackgroundReactImageView(Context context,
    AbstractDraweeControllerBuilder draweeControllerBuilder,
    @Nullable GlobalImageLoadListener globalImageLoadListener,
    @Nullable Object callerContext) {
    super(context, draweeControllerBuilder, globalImageLoadListener, callerContext);
  }

  @Override
  public void draw(Canvas canvas) {
    canvas.save();
    if (mPath == null) {
      mPath = new Path();
    }
    mPath.reset();
    if(mRectF == null){
      mRectF = new RectF(0, 0, getWidth(), getHeight());
    }
    if (mCorners > 0F) {
      mPath.addRoundRect(mRectF, mCorners, mCorners, Path.Direction.CCW);
    } else if (mBorderCornerRadii != null) {
      if (mRadii == null) {
        mRadii = new float[8];
      }
      mRadii[0] = mBorderCornerRadii[0];
      mRadii[1] = mBorderCornerRadii[0];
      mRadii[2] = mBorderCornerRadii[1];
      mRadii[3] = mBorderCornerRadii[1];
      mRadii[4] = mBorderCornerRadii[2];
      mRadii[5] = mBorderCornerRadii[2];
      mRadii[6] = mBorderCornerRadii[3];
      mRadii[7] = mBorderCornerRadii[3];
      mPath.addRoundRect(mRectF, mRadii, Path.Direction.CCW);
      canvas.clipPath(mPath);
    } else {
      mPath.addRoundRect(mRectF, 0, 0, Path.Direction.CCW);
    }
    canvas.clipPath(mPath);
    super.draw(canvas);
  }

  public void updateBorderRadius(float borderRadius) {
    if (!FloatUtil.floatsEqual(mCorners, borderRadius)) {
      mCorners = borderRadius;
      invalidate();
    }
  }

  public void updateBorderRadius(float borderRadius, int position) {
    if (mBorderCornerRadii == null) {
      mBorderCornerRadii = new float[4];
      Arrays.fill(mBorderCornerRadii, YogaConstants.UNDEFINED);
    }
    if (!FloatUtil.floatsEqual(mBorderCornerRadii[position], borderRadius)) {
      mBorderCornerRadii[position] = borderRadius;
      invalidate();
    }
  }

  public void updateBorderRadius(float[] radii) {
    if (Arrays.equals(mBorderCornerRadii, radii)) {
      return;
    }
    if (mBorderCornerRadii == null) {
      mBorderCornerRadii = new float[4];
      Arrays.fill(mBorderCornerRadii, YogaConstants.UNDEFINED);
    }
    mBorderCornerRadii = radii;
    invalidate();
  }

  public void setBackgroundSource(@Nullable ReadableMap source) {
    getBackgroundScaleType().setSource(source);
  }

  public ScaleTypeBackgroundImage getBackgroundScaleType() {
    if (mScaleTypeBackgroundImage == null) {
      mScaleTypeBackgroundImage = new ScaleTypeBackgroundImage();
    }
    return mScaleTypeBackgroundImage;
  }
}
