/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.react.uimanager;

import android.view.View;
import androidx.annotation.Nullable;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.OnBatchCompleteListener;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.UIManager;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.uimanager.debug.NotThreadSafeViewHierarchyUpdateDebugListener;
import com.facebook.react.uimanager.events.EventDispatcher;
import java.util.List;
import java.util.Map;

/**
 * Native module to allow JS to create and update native Views.
 *
 * <p>
 *
 * <h2>== Transactional Requirement ==</h2>
 * <p>
 * A requirement of this class is to make sure that transactional UI updates occur all at once,
 * meaning that no intermediate state is ever rendered to the screen. For example, if a JS
 * application update changes the background of View A to blue and the width of View B to 100, both
 * need to appear at once. Practically, this means that all UI update code related to a single
 * transaction must be executed as a single code block on the UI thread. Executing as multiple code
 * blocks could allow the platform UI system to interrupt and render a partial UI state.
 *
 * <p>To facilitate this, this module enqueues operations that are then applied to native view
 * hierarchy through {@link NativeViewHierarchyManager} at the end of each transaction.
 *
 * <p>
 *
 * <h2>== CSSNodes ==</h2>
 * <p>
 * In order to allow layout and measurement to occur on a non-UI thread, this module also operates
 * on intermediate CSSNodeDEPRECATED objects that correspond to a native view. These
 * CSSNodeDEPRECATED are able to calculate layout according to their styling rules, and then the
 * resulting x/y/width/height of that layout is scheduled as an operation that will be applied to
 * native view hierarchy at the end of current batch. TODO(5241856): Investigate memory usage of
 * creating many small objects in UIManageModule and consider implementing a pool TODO(5483063):
 * Don't dispatch the view hierarchy at the end of a batch if no UI changes occurred
 */
@ReactModule(name = NativeUIManagerSpec.LIB_UIMANAGER)
public abstract class UIManagerModule extends ReactContextBaseJavaModule
  implements OnBatchCompleteListener, UIManager, NativeModule {

  /** Enables lazy discovery of a specific {@link ViewManager} by its name. */
  public interface ViewManagerResolver {
    /**
     * {@class UIManagerModule} class uses this method to get a ViewManager by its name. This is the
     * same name that comes from JS by {@code UIManager.ViewManagerName} call.
     */
    @Nullable
    ViewManager getViewManager(String viewManagerName);

    /**
     * Provides a list of view manager names to register in JS as {@code UIManager.ViewManagerName}
     */
    List<String> getViewManagerNames();

    List<ViewManager> getFallbackViewManagers();
  }

  /** Resolves a name coming from native side to a name of the event that is exposed to JS. */
  public interface CustomEventNamesResolver {
    /** Returns custom event name by the provided event name. */
    @Nullable
    String resolveCustomEventName(String eventName);
  }

  public UIManagerModule(ReactApplicationContext reactApplicationContext) {
    super(reactApplicationContext);
  }

  public abstract void profileNextBatch();

  public abstract UIImplementation getUIImplementation();

  public abstract void updateView(final int tag, final String className, final ReadableMap props);

  public abstract void dispatchViewManagerStringCommand(Double reactTag, String commandID,
    ReadableArray commandArgs);

  public abstract void dispatchViewManagerCommand(int reactTag, final int commandId,
    @Nullable ReadableArray commandArgs);

  public abstract void createView(int tag, String className, int rootViewTag, ReadableMap props);

  public abstract void setChildren(int viewTag, ReadableArray childrenTags);

  public abstract void manageChildren(
    int viewTag,
    @Nullable ReadableArray moveFrom,
    @Nullable ReadableArray moveTo,
    @Nullable ReadableArray addChildTags,
    @Nullable ReadableArray addAtIndices,
    @Nullable ReadableArray removeFrom);

  public abstract void onBatchComplete();

  public abstract void addUIBlock(UIBlock block);

  public abstract void prependUIBlock(UIBlock block);

  public abstract void addUIManagerListener(UIManagerModuleListener listener);

  public abstract void setViewHierarchyUpdateDebugListener(
    @Nullable NotThreadSafeViewHierarchyUpdateDebugListener listener);

  public abstract EventDispatcher getEventDispatcher();

  public abstract UIManagerModule.CustomEventNamesResolver getDirectEventNamesResolver();

  public abstract void setViewLocalData(final int tag, final Object data);

  public abstract View resolveView(int tag);

  public abstract void updateNodeSize(int nodeViewTag, int newWidth, int newHeight);

  @Deprecated
  public abstract ViewManagerRegistry getViewManagerRegistry_DO_NOT_USE();

  public abstract Map<String, Object> getConstants();

  public abstract void preComputeConstantsForViewManager(List<String> viewManagerNames);

  public abstract WritableMap getConstantsForViewManager(String viewManagerName);

  public abstract WritableMap getDefaultEventTypes();

  public abstract <T extends View> int addRootView(T rootView);

  public abstract void removeRootView(int rootViewTag);

  public abstract void replaceExistingNonRootView(int oldTag, int newTag);

  public abstract void removeSubviewsFromContainerWithID(int containerTag);

  public abstract void measure(int reactTag, Callback callback);

  public abstract void measureInWindow(int reactTag, Callback callback);

  public abstract void measureLayout(int tag, int ancestorTag, Callback errorCallback,
    Callback successCallback);

  public abstract void measureLayoutRelativeToParent(int tag, Callback errorCallback,
    Callback successCallback);

  public abstract void findSubviewIn(int reactTag, ReadableArray point, Callback callback);

  public abstract void viewIsDescendantOf(int reactTag, int ancestorReactTag, Callback callback);

  public abstract void setJSResponder(int reactTag, boolean blockNativeResponder);

  public abstract void clearJSResponder();

  public abstract void playTouchSound();

  public abstract void showPopupMenu(int reactTag, ReadableArray items, Callback error,
    Callback success);

  public abstract void dismissPopupMenu();

  public abstract void setLayoutAnimationEnabledExperimental(boolean enabled);

  public abstract void configureNextLayoutAnimation(ReadableMap config, Callback success,
    Callback error);

  public abstract void removeUIManagerListener(UIManagerModuleListener listener);

  public abstract int resolveRootTagFromReactTag(int reactTag);

  public abstract void invalidateNodeLayout(int tag);

  public abstract WritableMap lazilyLoadView(String name);
}
