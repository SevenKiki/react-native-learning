package com.facebook.react.views.deractors;

import android.util.SparseIntArray;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;

import androidx.annotation.Nullable;

import com.facebook.common.logging.FLog;
import com.facebook.react.bridge.UiThreadUtil;
import com.facebook.react.config.ReactFeatureFlags;
import com.facebook.react.uimanager.IViewManagerWithChildren;
import com.facebook.react.uimanager.IllegalViewOperationException;
import com.facebook.react.uimanager.NativeViewHierarchyManager;
import com.facebook.react.uimanager.RootView;
import com.facebook.react.uimanager.RootViewManager;
import com.facebook.react.uimanager.ViewAtIndex;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.ViewManager;
import com.facebook.react.uimanager.ViewManagerRegistry;
import com.facebook.react.uimanager.layoutanimation.LayoutAnimationListener;
import com.facebook.systrace.Systrace;
import com.facebook.systrace.SystraceMessage;

public class KdsNativeViewHierarchyManager extends NativeViewHierarchyManager {
  private static final String TAG = "KdsNativeViewHierarchyManager";
  public KdsNativeViewHierarchyManager(ViewManagerRegistry viewManagers) {
    this(viewManagers, new RootViewManager());
  }

  public KdsNativeViewHierarchyManager(ViewManagerRegistry viewManagers, RootViewManager manager) {
    super(viewManagers, manager);
  }

  // 重写父类，并添加BackgroundDecorView requestLayout逻辑
  public synchronized void updateLayout(
    int parentTag, int tag, int x, int y, int width, int height) {
    UiThreadUtil.assertOnUiThread();
    SystraceMessage.beginSection(
      Systrace.TRACE_TAG_REACT_VIEW, "NativeViewHierarchyManager_updateLayout")
      .arg("parentTag", parentTag)
      .arg("tag", tag)
      .flush();
    try {
      View viewToUpdate = resolveView(tag);

      // Even though we have exact dimensions, we still call measure because some platform views
      // (e.g.
      // Switch) assume that method will always be called before onLayout and onDraw. They use it to
      // calculate and cache information used in the draw pass. For most views, onMeasure can be
      // stubbed out to only call setMeasuredDimensions. For ViewGroups, onLayout should be stubbed
      // out to not recursively call layout on its children: React Native already handles doing
      // that.
      //
      // Also, note measure and layout need to be called *after* all View properties have been
      // updated
      // because of caching and calculation that may occur in onMeasure and onLayout. Layout
      // operations should also follow the native view hierarchy and go top to bottom for
      // consistency
      // with standard layout passes (some views may depend on this).

      viewToUpdate.measure(
        View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),
        View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));

      // We update the layout of the ReactRootView when there is a change in the layout of its
      // child.
      // This is required to re-measure the size of the native View container (usually a
      // FrameLayout) that is configured with layout_height = WRAP_CONTENT or layout_width =
      // WRAP_CONTENT
      //
      // This code is going to be executed ONLY when there is a change in the size of the Root
      // View defined in the js side. Changes in the layout of inner views will not trigger an
      // update
      // on the layout of the Root View.
      ViewParent parent = viewToUpdate.getParent();
      if (ReactFeatureFlags.enableBackgroundDecorView &&
        BackgroundDecorView.fromView(viewToUpdate) != null) {
        parent = BackgroundDecorView.fromView(viewToUpdate).getParent();
      }
      if (parent instanceof RootView) {
        parent.requestLayout();
      }

      // Check if the parent of the view has to layout the view, or the child has to lay itself out.
      if (!mRootTags.get(parentTag)) {
        ViewManager parentViewManager = mTagsToViewManagers.get(parentTag);
        IViewManagerWithChildren parentViewManagerWithChildren;
        if (parentViewManager instanceof IViewManagerWithChildren) {
          parentViewManagerWithChildren = (IViewManagerWithChildren) parentViewManager;
        } else {
          throw new IllegalViewOperationException(
            "Trying to use view with tag "
              + parentTag
              + " as a parent, but its Manager doesn't implement IViewManagerWithChildren");
        }
        if (parentViewManagerWithChildren != null
          && !parentViewManagerWithChildren.needsCustomLayoutForChildren()) {
          updateLayout(viewToUpdate, x, y, width, height);
        }
      } else {
        updateLayout(viewToUpdate, x, y, width, height);
      }
    } finally {
      Systrace.endSection(Systrace.TRACE_TAG_REACT_VIEW);
    }
  }

  // 重写父类，并添加BackgroundDecorView layout逻辑
  private void updateLayout(View viewToUpdate, int x, int y, int width, int height) {
    if (mLayoutAnimationEnabled && mLayoutAnimator.shouldAnimateLayout(viewToUpdate)) {
      mLayoutAnimator.applyLayoutUpdate(viewToUpdate, x, y, width, height);
    } else {
      if (ReactFeatureFlags.enableBackgroundDecorView &&
        BackgroundDecorView.fromView(viewToUpdate) != null) {
        BackgroundDecorView
          .fromView(viewToUpdate).layout(x, y, x + width, y + height);
      } else {
        viewToUpdate.layout(x, y, x + width, y + height);
      }
    }
  }

  // 重写父类，并添加BackgroundDecorView addView逻辑
  public synchronized void manageChildren(
    int tag,
    @Nullable int[] indicesToRemove,
    @Nullable ViewAtIndex[] viewsToAdd,
    @Nullable int[] tagsToDelete,
    @Nullable int[] indicesToDelete) {
    UiThreadUtil.assertOnUiThread();

    final SparseIntArray pendingIndicesToDelete = getOrCreatePendingIndicesToDelete(tag);

    final ViewGroup viewToManage = (ViewGroup) mTagsToViews.get(tag);
    final ViewGroupManager viewManager = (ViewGroupManager) resolveViewManager(tag);
    if (viewToManage == null) {
      throw new IllegalViewOperationException(
        "Trying to manageChildren view with tag "
          + tag
          + " which doesn't exist\n detail: "
          + constructManageChildrenErrorMessage(
          viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
    }

    int lastIndexToRemove = viewManager.getChildCount(viewToManage);
    if (indicesToRemove != null) {
      for (int i = indicesToRemove.length - 1; i >= 0; i--) {
        int indexToRemove = indicesToRemove[i];
        if (indexToRemove < 0) {
          throw new IllegalViewOperationException(
            "Trying to remove a negative view index:"
              + indexToRemove
              + " view tag: "
              + tag
              + "\n detail: "
              + constructManageChildrenErrorMessage(
              viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
        }
        if (indexToRemove >= viewManager.getChildCount(viewToManage)) {
          if (mRootTags.get(tag) && viewManager.getChildCount(viewToManage) == 0) {
            // This root node has already been removed (likely due to a threading issue caused by
            // async js execution). Ignore this root removal.
            return;
          }
          throw new IllegalViewOperationException(
            "Trying to remove a view index above child "
              + "count "
              + indexToRemove
              + " view tag: "
              + tag
              + "\n detail: "
              + constructManageChildrenErrorMessage(
              viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
        }
        if (indexToRemove >= lastIndexToRemove) {
          throw new IllegalViewOperationException(
            "Trying to remove an out of order view index:"
              + indexToRemove
              + " view tag: "
              + tag
              + "\n detail: "
              + constructManageChildrenErrorMessage(
              viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
        }

        int normalizedIndexToRemove = normalizeIndex(indexToRemove, pendingIndicesToDelete);
        View viewToRemove = viewManager.getChildAt(viewToManage, normalizedIndexToRemove);

        if (mLayoutAnimationEnabled
          && mLayoutAnimator.shouldAnimateLayout(viewToRemove)
          && arrayContains(tagsToDelete, viewToRemove.getId())) {
          // The view will be removed and dropped by the 'delete' layout animation
          // instead, so do nothing
        } else {
          viewManager.removeViewAt(viewToManage, normalizedIndexToRemove);
        }

        lastIndexToRemove = indexToRemove;
      }
    }

    if (tagsToDelete != null) {
      for (int i = 0; i < tagsToDelete.length; i++) {
        int tagToDelete = tagsToDelete[i];
        final int indexToDelete = indicesToDelete[i];
        final View viewToDestroy = mTagsToViews.get(tagToDelete);
        if (viewToDestroy == null) {
          throw new IllegalViewOperationException(
            "Trying to destroy unknown view tag: "
              + tagToDelete
              + "\n detail: "
              + constructManageChildrenErrorMessage(
              viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
        }

        if (mLayoutAnimationEnabled && mLayoutAnimator.shouldAnimateLayout(viewToDestroy)) {
          int updatedCount = pendingIndicesToDelete.get(indexToDelete, 0) + 1;
          pendingIndicesToDelete.put(indexToDelete, updatedCount);
          mLayoutAnimator.deleteView(
            viewToDestroy,
            new LayoutAnimationListener() {
              @Override
              public void onAnimationEnd() {
                // This should be called only on the UI thread, because
                // onAnimationEnd is called (indirectly) by Android View Animation.
                UiThreadUtil.assertOnUiThread();

                viewManager.removeView(viewToManage, viewToDestroy);
                dropView(viewToDestroy);

                int count = pendingIndicesToDelete.get(indexToDelete, 0);
                pendingIndicesToDelete.put(indexToDelete, Math.max(0, count - 1));
              }
            });
        } else {
          dropView(viewToDestroy);
        }
      }
    }

    if (viewsToAdd != null) {
      for (int i = 0; i < viewsToAdd.length; i++) {
        ViewAtIndex viewAtIndex = viewsToAdd[i];
        View viewToAdd = mTagsToViews.get(viewAtIndex.mTag);
        if (viewToAdd == null) {
          throw new IllegalViewOperationException(
            "Trying to add unknown view tag: "
              + viewAtIndex.mTag
              + "\n detail: "
              + constructManageChildrenErrorMessage(
              viewToManage, viewManager, indicesToRemove, viewsToAdd, tagsToDelete));
        }
        int normalizedIndexToAdd = normalizeIndex(viewAtIndex.mIndex, pendingIndicesToDelete);
        if (ReactFeatureFlags.enableBackgroundDecorView &&
          BackgroundDecorView.fromView(viewToAdd) != null) {
          viewToAdd = BackgroundDecorView.fromView(viewToAdd);
        }
        viewManager.addView(viewToManage, viewToAdd, normalizedIndexToAdd);
      }
    }
  }

  // 重写父类，并添加BackgroundDecorView drop被装饰的View逻辑
  protected synchronized void dropView(View view) {
    UiThreadUtil.assertOnUiThread();
    if (view == null) {
      // Ignore this drop operation when view is null.
      return;
    }
    if (ReactFeatureFlags.logDroppedViews) {
      cacheDroppedTag(view.getId());
    }
    if (mTagsToViewManagers.get(view.getId()) == null) {
      // This view has already been dropped (likely due to a threading issue caused by async js
      // execution). Ignore this drop operation.
      return;
    }
    if (!mRootTags.get(view.getId())) {
      // For non-root views we notify viewmanager with {@link ViewManager#onDropInstance}
      resolveViewManager(view.getId()).onDropViewInstance(view);
    }
    ViewManager viewManager = mTagsToViewManagers.get(view.getId());
    if (view instanceof ViewGroup && viewManager instanceof ViewGroupManager) {
      ViewGroup viewGroup = (ViewGroup) view;
      ViewGroupManager viewGroupManager = (ViewGroupManager) viewManager;
      for (int i = viewGroupManager.getChildCount(viewGroup) - 1; i >= 0; i--) {
        View child = viewGroupManager.getChildAt(viewGroup, i);
        if (child == null) {
          FLog.e(TAG, "Unable to drop null child view");
        } else if (mTagsToViews.get(child.getId()) != null) {
          dropView(child);
        } else if (ReactFeatureFlags.enableBackgroundDecorView &&
          child instanceof BackgroundDecorView) {
          dropView(((BackgroundDecorView) child).getOriginView());
        }
      }
      viewGroupManager.removeAllViews(viewGroup);
    }
    mTagsToPendingIndicesToDelete.remove(view.getId());
    mTagsToViews.remove(view.getId());
    mTagsToViewManagers.remove(view.getId());
  }
}
