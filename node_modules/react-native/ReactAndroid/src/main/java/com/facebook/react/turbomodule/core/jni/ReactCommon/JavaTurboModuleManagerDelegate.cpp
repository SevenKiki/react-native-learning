/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <functional>
#include "JavaTurboModuleManagerDelegate.h"
#include <android/log.h>
#include <ReactCommon/TurboModule.h>

namespace facebook {
namespace react {

jni::local_ref<JavaTurboModuleManagerDelegate::jhybriddata> JavaTurboModuleManagerDelegate::initHybrid(jni::alias_ref<jhybridobject>) {
  return makeCxxInstance();
}

void JavaTurboModuleManagerDelegate::registerNatives() {
  registerHybrid({
    makeNativeMethod("initHybrid", JavaTurboModuleManagerDelegate::initHybrid),
    makeNativeMethod("canCreateTurboModule", JavaTurboModuleManagerDelegate::canCreateTurboModule),
    makeNativeMethod("registerModules", JavaTurboModuleManagerDelegate::registerModules),
  });
}

std::shared_ptr<TurboModule> JavaTurboModuleManagerDelegate::getTurboModule(const std::string name, const std::shared_ptr<CallInvoker> jsInvoker) {
  // Not implemented yet: provide pure-C++ NativeModules here.
  return nullptr;
}

std::shared_ptr<TurboModule> JavaTurboModuleManagerDelegate::getTurboModule(const std::string name, const JavaTurboModule::InitParams &params) {
  std::shared_ptr<TurboModule> javaTurboModule = std::make_shared<JavaTurboModule>(params);
  if (infoMap_.find(name) != infoMap_.end()) {
    for (const auto methodInfo : infoMap_[name]) {
      std::function<TurboModule::MethodInvokerType> proxy = [methodInfo](
              jsi::Runtime &rt,
              TurboModule &turboModule,
              const facebook::jsi::Value *args,
              size_t count) -> facebook::jsi::Value {
            return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(
              rt, (TurboModuleMethodValueKind) methodInfo.retKind, methodInfo.name, methodInfo.signature, args, count);
        };
      javaTurboModule->methodMap_[methodInfo.name] = TurboModule::MethodMetadata{
        methodInfo.argCount, proxy 
      };
      __android_log_print(ANDROID_LOG_WARN, "aaa", "name %s, method %s", name.c_str(), methodInfo.name.c_str());
    }
  }
  return javaTurboModule;
}

bool JavaTurboModuleManagerDelegate::canCreateTurboModule(std::string name) {
  return getTurboModule(name, nullptr) != nullptr || getTurboModule(name, {.moduleName = name}) != nullptr;
}

void JavaTurboModuleManagerDelegate::registerModules(const std::string &moduleName, int argCount, const std::string &funcName, int kind, const std::string &sign) {
  infoMap_[moduleName].push_back(JavaTurboMethodInfo { static_cast<size_t>(argCount), funcName, kind, sign });
}

} // namespace react
} // namespace facebook
