package com.facebook.react.uimanager.kdscss;

import java.util.Arrays;
import java.util.List;

import android.util.Log;
import androidx.annotation.Nullable;

import com.facebook.infer.annotation.Assertions;
import com.facebook.react.bridge.JavaOnlyArray;
import com.facebook.react.bridge.JavaOnlyMap;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.config.ReactFeatureFlags;
import com.facebook.react.uimanager.IllegalViewOperationException;
import com.facebook.react.uimanager.NativeViewHierarchyManager;
import com.facebook.react.uimanager.NativeViewHierarchyOptimizer;
import com.facebook.react.uimanager.ReactShadowNode;
import com.facebook.react.uimanager.UIImplementation;
import com.facebook.react.uimanager.UIManagerModule;
import com.facebook.react.uimanager.UIViewOperationQueue;
import com.facebook.react.uimanager.ViewAtIndex;
import com.facebook.react.uimanager.ViewManager;
import com.facebook.react.uimanager.ViewManagerRegistry;
import com.facebook.react.uimanager.events.EventDispatcher;
import com.facebook.react.views.deractors.KdsNativeViewHierarchyManager;
import com.facebook.yoga.YogaDisplay;

public class KdsUIImplementation extends UIImplementation {
  public static final String TAG = "KdsUIImplementation";
  public KdsUIImplementation(
    ReactApplicationContext reactContext,
    UIManagerModule.ViewManagerResolver viewManagerResolver,
    EventDispatcher eventDispatcher,
    int minTimeLeftInFrameForNonBatchedOperationMs) {
    this(
      reactContext,
      new ViewManagerRegistry(viewManagerResolver),
      eventDispatcher,
      minTimeLeftInFrameForNonBatchedOperationMs);
  }

  public KdsUIImplementation(
    ReactApplicationContext reactContext,
    List<ViewManager> viewManagers,
    EventDispatcher eventDispatcher,
    int minTimeLeftInFrameForNonBatchedOperationMs) {
    this(
      reactContext,
      new ViewManagerRegistry(viewManagers),
      eventDispatcher,
      minTimeLeftInFrameForNonBatchedOperationMs);
  }

  public KdsUIImplementation(
    ReactApplicationContext reactContext,
    ViewManagerRegistry viewManagers,
    EventDispatcher eventDispatcher,
    int minTimeLeftInFrameForNonBatchedOperationMs) {
    this(
      reactContext,
      viewManagers,
      new UIViewOperationQueue(
        reactContext,
        ReactFeatureFlags.enableBackgroundDecorView ? new KdsNativeViewHierarchyManager(
          viewManagers) : new NativeViewHierarchyManager(viewManagers),
        minTimeLeftInFrameForNonBatchedOperationMs),
      eventDispatcher);
  }

  protected KdsUIImplementation(
    ReactApplicationContext reactContext,
    ViewManagerRegistry viewManagers,
    UIViewOperationQueue operationsQueue,
    EventDispatcher eventDispatcher) {
    super(reactContext, viewManagers, operationsQueue, eventDispatcher);
  }

  /**
   * 重载原生方法，增加通过tags设置fixed子节点进行拦截处理
   */
  @Override
  public void manageChildren(
    int viewTag,
    @Nullable ReadableArray moveFrom,
    @Nullable ReadableArray moveTo,
    @Nullable ReadableArray addChildTags,
    @Nullable ReadableArray addAtIndices,
    @Nullable ReadableArray removeFrom) {
    synchronized (uiImplementationThreadLock) {
      ReactShadowNode cssNodeToManage = mShadowNodeRegistry.getNode(viewTag);

      if (cssNodeToManage == null) {
        return;
      }

      int numToMove = moveFrom == null ? 0 : moveFrom.size();
      int numToAdd = addChildTags == null ? 0 : addChildTags.size();
      int numToRemove = removeFrom == null ? 0 : removeFrom.size();

      if (numToMove != 0 && (moveTo == null || numToMove != moveTo.size())) {
        throw new IllegalViewOperationException("Size of moveFrom != size of moveTo!");
      }

      if (numToAdd != 0 && (addAtIndices == null || numToAdd != addAtIndices.size())) {
        throw new IllegalViewOperationException("Size of addChildTags != size of addAtIndices!");
      }

      // We treat moves as an add and a delete
      ViewAtIndex[] viewsToAdd = new ViewAtIndex[numToMove + numToAdd];
      int[] indicesToRemove = new int[numToMove + numToRemove];
      int[] tagsToRemove = new int[indicesToRemove.length];
      int[] tagsToDelete = new int[numToRemove];
      int[] indicesToDelete = new int[numToRemove];

      if (numToMove > 0) {
        Assertions.assertNotNull(moveFrom);
        Assertions.assertNotNull(moveTo);
        for (int i = 0; i < numToMove; i++) {
          int moveFromIndex = moveFrom.getInt(i);
          int tagToMove = cssNodeToManage.getChildAt(moveFromIndex).getReactTag();
          viewsToAdd[i] = new ViewAtIndex(tagToMove, moveTo.getInt(i));
          indicesToRemove[i] = moveFromIndex;
          tagsToRemove[i] = tagToMove;
        }
      }

      if (numToAdd > 0) {
        Assertions.assertNotNull(addChildTags);
        Assertions.assertNotNull(addAtIndices);
        for (int i = 0; i < numToAdd; i++) {
          int viewTagToAdd = addChildTags.getInt(i);
          int indexToAddAt = addAtIndices.getInt(i);
          // 通过addChildTags增加的节点则替换成对应的空节点进行增加
          ReactShadowNode viewToAdd = mShadowNodeRegistry.getNode(viewTagToAdd);
          if (!isRootNode(cssNodeToManage.getReactTag()) && viewToAdd.isFixedNode()) {
            interceptFixedChildToRootView(mShadowNodeRegistry.getNode(viewTagToAdd),
              cssNodeToManage);
            viewTagToAdd = -viewTagToAdd;
          }
          viewsToAdd[numToMove + i] = new ViewAtIndex(viewTagToAdd, indexToAddAt);
        }
      }

      if (numToRemove > 0) {
        Assertions.assertNotNull(removeFrom);
        for (int i = 0; i < numToRemove; i++) {
          int indexToRemove = removeFrom.getInt(i);
          int tagToRemove = cssNodeToManage.getChildAt(indexToRemove).getReactTag();
          indicesToRemove[numToMove + i] = indexToRemove;
          tagsToRemove[numToMove + i] = tagToRemove;
          tagsToDelete[i] = tagToRemove;
          indicesToDelete[i] = indexToRemove;
        }
      }

      // NB: moveFrom and removeFrom are both relative to the starting state of the View's children.
      // moveTo and addAt are both relative to the final state of the View's children.
      //
      // 1) Sort the views to add and indices to remove by index
      // 2) Iterate the indices being removed from high to low and remove them. Going high to low
      //    makes sure we remove the correct index when there are multiple to remove.
      // 3) Iterate the views being added by index low to high and add them. Like the view removal,
      //    iteration direction is important to preserve the correct index.

      Arrays.sort(viewsToAdd, ViewAtIndex.COMPARATOR);
      Arrays.sort(indicesToRemove);

      // Apply changes to CSSNodeDEPRECATED hierarchy
      int lastIndexRemoved = -1;
      for (int i = indicesToRemove.length - 1; i >= 0; i--) {
        int indexToRemove = indicesToRemove[i];
        if (indexToRemove == lastIndexRemoved) {
          throw new IllegalViewOperationException(
            "Repeated indices in Removal list for view tag: " + viewTag);
        }
        cssNodeToManage.removeChildAt(indicesToRemove[i]); // Thread safety needed here

        lastIndexRemoved = indicesToRemove[i];
      }

      for (int i = 0; i < viewsToAdd.length; i++) {
        ViewAtIndex viewAtIndex = viewsToAdd[i];
        ReactShadowNode cssNodeToAdd = mShadowNodeRegistry.getNode(viewAtIndex.mTag);
        if (cssNodeToAdd == null) {
          throw new IllegalViewOperationException(
            "Trying to add unknown view tag: " + viewAtIndex.mTag);
        }
        cssNodeToManage.addChildAt(cssNodeToAdd, viewAtIndex.mIndex);
      }

      mNativeViewHierarchyOptimizer.handleManageChildren(
        cssNodeToManage,
        indicesToRemove,
        tagsToRemove,
        viewsToAdd,
        tagsToDelete,
        indicesToDelete);

      for (int i = 0; i < tagsToDelete.length; i++) {
        removeShadowNode(mShadowNodeRegistry.getNode(tagsToDelete[i]));
      }
    }
  }

  /**
   * 重载原生方法，增加对fixed子节点进行拦截处理
   */
  @Override
  public void setChildren(int viewTag, ReadableArray childrenTags) {
    synchronized (uiImplementationThreadLock) {
      ReactShadowNode cssNodeToManage = mShadowNodeRegistry.getNode(viewTag);

      JavaOnlyArray replaceFixedChildrenTags = new JavaOnlyArray();
      for (int i = 0; i < childrenTags.size(); i++) {
        ReactShadowNode cssNodeToAdd = mShadowNodeRegistry.getNode(childrenTags.getInt(i));
        if (cssNodeToAdd == null) {
          throw new IllegalViewOperationException(
            "Trying to add unknown view tag: " + childrenTags.getInt(i));
        }

        if (!mShadowNodeRegistry.isRootNode(viewTag) && cssNodeToAdd.isFixedNode()) {
          interceptFixedChildToRootView(cssNodeToAdd, cssNodeToManage);
          // 将fixed节点替换成虚拟节点
          cssNodeToAdd = mShadowNodeRegistry.getNode(-childrenTags.getInt(i));
          // 将fixed节点tag替换成虚拟节点
          replaceFixedChildrenTags.pushInt(-childrenTags.getInt(i));
        } else {
          replaceFixedChildrenTags.pushInt(childrenTags.getInt(i));
        }
        cssNodeToManage.addChildAt(cssNodeToAdd, i);
      }

      mNativeViewHierarchyOptimizer.handleSetChildren(cssNodeToManage, replaceFixedChildrenTags);
    }
  }

  /**
   * 重载原生方法，增加fixed节点关联移除逻辑
   */
  @Override
  public void removeShadowNodeRecursive(ReactShadowNode nodeToRemove) {
    if (nodeToRemove == null) {
      return;
    }

    // 节点包含移出的fixed节点则批量移除关联的fixed节点
    removeAllFixedChildrenRecursive(nodeToRemove);

    // virtualNode则移除关联fixed节点
    removeFixedChildRecursive(nodeToRemove);

    NativeViewHierarchyOptimizer.handleRemoveNode(nodeToRemove);
    mShadowNodeRegistry.removeNode(nodeToRemove.getReactTag());
    for (int i = nodeToRemove.getChildCount() - 1; i >= 0; i--) {
      removeShadowNodeRecursive(nodeToRemove.getChildAt(i));
    }
    nodeToRemove.removeAndDisposeAllChildren();
  }

  /**
   * 判断是否需要移除关联的Fixed节点，有可能已经移出RootNode到originalParent
   */
  private boolean shouldRemoveBindingFixedChild(int virtualChildTag) {
    ReactShadowNode virtualChild = mShadowNodeRegistry.getNode(virtualChildTag);
    if (virtualChildTag > 0 || virtualChild == null || !virtualChild.isBindingVirtualNode()) {
      return false;
    }

    return true;
  }

  /**
   * 创建空的虚拟占位节点
   */
  public void createVirtualChild(String className, int tag, int rootTag) {
    createView(tag, className, rootTag, JavaOnlyMap.of("collapsable", false));
    ReactShadowNode virtualChild = mShadowNodeRegistry.getNode(tag);
    virtualChild.setDisplay(YogaDisplay.NONE);
    virtualChild.setBindingVirtualNode(true);
  }

  /**
   * 当fixed节点再添加到父View时，拦截到RootView下，并创建虚拟占位节点
   */
  public void interceptFixedChildToRootView(ReactShadowNode fixedChild, ReactShadowNode parent) {
    if (fixedChild == null || isRootNode(fixedChild.getReactTag())) {
      return;
    }

    createVirtualChild(fixedChild.getViewClass(), -fixedChild.getReactTag(),
      fixedChild.getRootTag());
    parent.setMovedOutFixedChildTag(fixedChild.getReactTag());

    fixedChild.setOriginalParentTag(parent.getReactTag());
    int rootTag = fixedChild.getRootTag();
    ReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootTag);
    int rootNodeChildCount = rootNode.getChildCount();


    JavaOnlyArray fixedChildTags = new JavaOnlyArray();
    fixedChildTags.pushInt(fixedChild.getReactTag());

    JavaOnlyArray fixedChildIndex = new JavaOnlyArray();
    fixedChildIndex.pushInt(rootNodeChildCount);

    // 插入视图层级最外侧
    manageChildren(rootTag, null, null, fixedChildTags, fixedChildIndex, null);
  }

  /**
   * 将fixed节点从父节点下移动到RootView下
   */
  public void moveFixedChildFromParentToRootView(ReactShadowNode fixedChild,
    ReactShadowNode parent) {
    if (fixedChild == null || isRootNode(fixedChild.getReactTag()) || parent == null) {
      return;
    }

    int rootTag = fixedChild.getRootTag();
    ReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootTag);
    if (rootNode == null) {
      return;
    }

    int virtualChildTag = -fixedChild.getReactTag();

    // 创建虚拟占位节点
    createVirtualChild(fixedChild.getViewClass(), virtualChildTag, fixedChild.getRootTag());
    parent.setMovedOutFixedChildTag(fixedChild.getReactTag());
    fixedChild.setOriginalParentTag(parent.getReactTag());

    int indexInParent = parent.indexOf(fixedChild);

    int rootNodeChildCount = rootNode.getChildCount();
    crossLevelMoveChild(fixedChild, rootNode, rootNodeChildCount);

    JavaOnlyArray virtualChildTags = new JavaOnlyArray();
    virtualChildTags.pushInt(virtualChildTag);
    JavaOnlyArray virtualChildIndex = new JavaOnlyArray();
    virtualChildIndex.pushInt(indexInParent);

    // 插入虚拟占位节点
    manageChildren(parent.getReactTag(), null, null, virtualChildTags, virtualChildIndex, null);
    dispatchViewUpdates(-1);

    Log.i(TAG, "moveFixedChildFromParentToRootView fixedChildInfo tag:" + fixedChild.getReactTag()
      + " indexInParent:" + indexInParent + " parentInfo tag:" + parent.getReactTag() +
      " MovedOutFixedChildTags:" + parent.getMovedOutFixedChildTags() +
      "virtualNodeIndexInParent:" + parent.indexOf(mShadowNodeRegistry.getNode(virtualChildTag)));
  }

  /**
   * 将fixed节点从到RootView下移动到原先父节点下，同步移除虚拟占位节点
   */
  public void moveFixedChildFromRootViewToOriginalParent(ReactShadowNode fixedChild) {
    if (fixedChild == null || isRootNode(fixedChild.getReactTag()) ||
      fixedChild.getParent() == null || !isRootNode(fixedChild.getParent().getReactTag())) {
      return;
    }

    int reactTag = fixedChild.getReactTag();

    ReactShadowNode fixedVirtualChild = mShadowNodeRegistry.getNode(-reactTag);
    ReactShadowNode originalParent = mShadowNodeRegistry.getNode(fixedChild.getOriginalParentTag());
    int indexInOriginalParent = originalParent.indexOf(fixedVirtualChild);

    // 跨层级移动UI节点
    crossLevelMoveChild(fixedChild, originalParent, indexInOriginalParent);
    //清除父节点中记录的flag
    removeMovedOutFixedChildTag(originalParent, reactTag);

    JavaOnlyArray delete = new JavaOnlyArray();
    delete.pushInt(originalParent.indexOf(fixedVirtualChild));
    fixedVirtualChild.setBindingVirtualNode(false);

    // 移除虚拟占位节点
    manageChildren(originalParent.getReactTag(), null, null, null, null, delete);

    // 手动刷新
    dispatchViewUpdates(-1);
    Log.i(TAG,
      "moveFixedChildFromRootViewToOriginalParent fixedChildInfo tag:" + reactTag
        + " indexInParent:" + originalParent.indexOf(fixedChild)
        + " parentInfo tag:" + originalParent.getReactTag() +
        " MovedOutFixedChildTags:" + originalParent.getMovedOutFixedChildTags());
  }

  /**
   * 跨层级移动节点
   */
  public void crossLevelMoveChild(ReactShadowNode child, ReactShadowNode destParent, int index) {
    if (child == null || destParent == null) {
      return;
    }
    ReactShadowNode parent = child.getParent();

    if (parent == null) {
      return;
    }

    // 从原有父节点下移除
    parent.removeChildAt(parent.indexOf(child));
    // 添加到新的父节点下
    destParent.addChildAt(child, index);

    mNativeViewHierarchyOptimizer.crossLevelMoveChild(child, destParent, destParent.indexOf(child));
  }

  public boolean isRootNode(int tag) {
    return mShadowNodeRegistry.isRootNode(tag);
  }

  /**
   * 移除父节点中对应保存的曾移出的fixed节点tag
   */
  private void removeMovedOutFixedChildTag(ReactShadowNode parent, int removeTag) {
    if (parent == null) {
      return;
    }

    JavaOnlyArray fixedChildrenTags = parent.getMovedOutFixedChildTags();
    if (fixedChildrenTags == null || fixedChildrenTags.size() <= 1) {
      parent.resetMovedOutFixedChildTags(null);
      return;
    }

    JavaOnlyArray remainChildrenTags = new JavaOnlyArray();
    for (int i = 0; i < fixedChildrenTags.size(); i++) {
      int fixedTag = fixedChildrenTags.getInt(i);
      if (fixedTag != removeTag) {
        remainChildrenTags.pushInt(fixedTag);
      }
    }

    if (remainChildrenTags.size() == 0) {
      parent.resetMovedOutFixedChildTags(null);
    } else {
      parent.resetMovedOutFixedChildTags(remainChildrenTags);
    }
  }

  /**
   * 虚拟站位节点移除时，同步移除关联的fixed节点，通常是通过index来移除节点的场景
   */
  private void removeFixedChildRecursive(ReactShadowNode virtualChild) {
    if (virtualChild == null || virtualChild.getReactTag() > 0 ||
      !shouldRemoveBindingFixedChild(virtualChild.getReactTag())) {
      return;
    }

    ReactShadowNode fixedNodeToRemove = mShadowNodeRegistry.getNode(-virtualChild.getReactTag());
    if (fixedNodeToRemove == null) {
      return;
    }

    int rootTag = virtualChild.getRootTag();
    ReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootTag);
    JavaOnlyArray removeChildrenIndex = new JavaOnlyArray();
    removeChildrenIndex.pushInt(rootNode.indexOf(fixedNodeToRemove));

    if (removeChildrenIndex != null && removeChildrenIndex.size() > 0) {
      ReactShadowNode parent = virtualChild.getParent();
      if (parent != null) {
        // 删除FixedChildTag
        removeMovedOutFixedChildTag(parent, fixedNodeToRemove.getReactTag());
      }
      // 移除关联fixed节点
      manageChildren(rootTag, null, null, null, null, removeChildrenIndex);
    }
  }

  /**
   * 节点移除时同步移除曾移到RootView下的fixed节点
   */
  private void removeAllFixedChildrenRecursive(ReactShadowNode parent) {
    if (parent == null) {
      return;
    }

    JavaOnlyArray fixedChildrenTags = parent.getMovedOutFixedChildTags();
    if (fixedChildrenTags == null || fixedChildrenTags.size() <= 0) {
      return;
    }

    ReactShadowNode rootNode = null;
    JavaOnlyArray removeChildrenIndex = null;
    int rootTag = 0;
    for (int i = 0; i < fixedChildrenTags.size(); i++) {
      ReactShadowNode fixedNodeToRemove =
        mShadowNodeRegistry.getNode(fixedChildrenTags.getInt(i));

      if (fixedNodeToRemove == null) {
        continue;
      }

      if (rootNode == null) {
        rootTag = fixedNodeToRemove.getRootTag();
        rootNode = mShadowNodeRegistry.getNode(rootTag);
      }

      if (removeChildrenIndex == null) {
        removeChildrenIndex = new JavaOnlyArray();
      }

      removeChildrenIndex.pushInt(rootNode.indexOf(fixedNodeToRemove));
    }

    if (rootTag != 0 && removeChildrenIndex != null && removeChildrenIndex.size() > 0) {
      parent.resetMovedOutFixedChildTags(null);
      // 移除关联fixed节点
      manageChildren(rootTag, null, null, null, null, removeChildrenIndex);
    }
  }
}
