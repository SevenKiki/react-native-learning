#include "V8CodeCache.h"

#include <android/log.h>
#include <stdio.h>
#include <sys/stat.h>

#include <fstream>

#include "jsi/jsilib.h"
#include "v8.h"

#include "base/city.h"

using namespace std;

namespace facebook {

template <typename UnboundScript>
void ProduceCacheInternal(
    v8::Isolate *isolate,
    UnboundScript unboundScript,
    const std::string &url,
    jsi::CodeCacheItem &codeCacheItem,
    V8CodeCache::ProduceCacheOptions produceCacheOptions) {
  switch (produceCacheOptions) {
    case V8CodeCache::ProduceCacheOptions::kSetTimeStamp:
      // TODO: update timestamp only
      break;
    case V8CodeCache::ProduceCacheOptions::kProduceCodeCache: {
      if (unboundScript.IsEmpty()) {
        codeCacheItem.result = jsi::CodeCacheItem::Result::PRODUCE_FAILED;
        break;
      }

      std::unique_ptr<v8::ScriptCompiler::CachedData> cachedData(
          v8::ScriptCompiler::CreateCodeCache(unboundScript));
      if (cachedData) {
        cachedData->buffer_policy =
            v8::ScriptCompiler::CachedData::BufferNotOwned;
#if !CODE_CACHE_DEBUG
        codeCacheItem.data = std::unique_ptr<uint8_t>(const_cast<uint8_t*>(cachedData->data));
        codeCacheItem.size = cachedData->length;
        codeCacheItem.result = jsi::CodeCacheItem::Result::REQUEST_UPDATE;
#else
        const uint8_t *data = cachedData->data;
        int length = cachedData->length;
        bool ret = V8CodeCache::WriteFile(url, data, length);
      }
#endif
      } else {
        codeCacheItem.result = jsi::CodeCacheItem::Result::PRODUCE_FAILED;
      }

      break;
    }
    case V8CodeCache::ProduceCacheOptions::kNoProduceCache:
      // result was set in compile phase
      break;
  }
} // namespace facebook

std::tuple<
    v8::ScriptCompiler::CompileOptions,
    V8CodeCache::ProduceCacheOptions,
    v8::ScriptCompiler::NoCacheReason>
V8CodeCache::GetCompileOptions(
    const std::string &url,
    V8CacheOptions cacheOptions,
    const jsi::CodeCacheItem &codeCacheItem) {
  // TODO: add kNoCompileOptions for regular code cache
  if (HasCache(codeCacheItem)) {
    // consume code cache
    return std::make_tuple(
        v8::ScriptCompiler::kConsumeCodeCache,
        ProduceCacheOptions::kNoProduceCache,
        v8::ScriptCompiler::kNoCacheNoReason);
  } else {
    // full code cache
    return std::make_tuple(
        v8::ScriptCompiler::kEagerCompile,
        ProduceCacheOptions::kProduceCodeCache,
        v8::ScriptCompiler::kNoCacheBecauseDeferredProduceCodeCache);
  }
}

void V8CodeCache::ProduceCache(
    v8::Isolate *isolate,
    v8::Local<v8::Script> script,
    const std::string &url,
    jsi::CodeCacheItem &codeCacheItem,
    ProduceCacheOptions produceCacheOptions) {
  ProduceCacheInternal(
      isolate,
      script->GetUnboundScript(),
      url,
      codeCacheItem,
      produceCacheOptions);
}

bool V8CodeCache::HasCache(const jsi::CodeCacheItem &codeCacheItem) {
  if (codeCacheItem.size > 0) {
    return true;
  } else {
    return false;
  }
}

v8::ScriptCompiler::CachedData *V8CodeCache::CreateCachedData(
    const jsi::CodeCacheItem &codeCacheItem,
    const std::string &url) {
#if !CODE_CACHE_DEBUG
  if (codeCacheItem.size > 0) {
    return new v8::ScriptCompiler::CachedData(
        codeCacheItem.data.get(),
        codeCacheItem.size,
        v8::ScriptCompiler::CachedData::BufferNotOwned);
  } else {
    return nullptr;
  }
#else
  return V8CodeCache::CreateCachedData(url);
#endif
}

#if CODE_CACHE_DEBUG
bool V8CodeCache::ReadFile(
    const std::string &url,
    uint8_t **data,
    int &data_size) {
  std::ifstream file(
      "/data/data/com.kuaishou.krn.android/files/" + url + ".bin",
      ios::in | ios::binary | ios::ate);

  if (file.is_open()) {
    int size = file.tellg();
    *data = new uint8_t[size];
    data_size = size;
    file.seekg(0, ios::beg);
    file.read((char *)*data, size);
    file.close();
    return true;
  } else {
    return false;
  }
}

bool V8CodeCache::WriteFile(
    const std::string url,
    const uint8_t *data,
    int size) {
  std::ofstream file(
      "/data/data/com.kuaishou.krn.android/files/" + url + ".bin",
      std::ios::out | std::ios::trunc | ios::binary);

  if (file.is_open()) {
    file.write((char *)data, size);
    file.close();
    return true;
  } else {
    return false;
  }
}

bool V8CodeCache::HasCache(const std::string &url) {
  std::ifstream file(
      "/data/data/com.kuaishou.krn.android/files/" + url + ".bin",
      ios::in | ios::binary | ios::ate);
  if (file.is_open()) {
    int size = file.tellg();
    file.close();
    return size > 0;
  } else {
    return false;
  }
}

v8::ScriptCompiler::CachedData *V8CodeCache::CreateCachedData(
    const std::string &url) {
  uint8_t *data = nullptr;
  int size = 0;
  bool ret = ReadFile(url, &data, size);
  if (ret) {
    return new v8::ScriptCompiler::CachedData(
        data, size, v8::ScriptCompiler::CachedData::BufferOwned);
  } else {
    return nullptr;
  }
}
#endif

} // namespace facebook
