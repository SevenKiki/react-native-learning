package com.facebook.react.module.model;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReactModuleWithSpec;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;

class ReflectMethodInfoProvider extends ModuleMethodInfoProvider {
  public static final HashMap<String, String> PRIMITIVES = new HashMap<>();

  static {
    PRIMITIVES.put(void.class.getName(), "V");
    PRIMITIVES.put(boolean.class.getName(), "Z");
    PRIMITIVES.put(byte.class.getName(), "B");
    PRIMITIVES.put(char.class.getName(), "C");
    PRIMITIVES.put(short.class.getName(), "S");
    PRIMITIVES.put(int.class.getName(), "I");
    PRIMITIVES.put(long.class.getName(), "J");
    PRIMITIVES.put(float.class.getName(), "F");
    PRIMITIVES.put(double.class.getName(), "D");
  }

  private final Class<? extends NativeModule> mModuleClass;

  public ReflectMethodInfoProvider(Class<? extends NativeModule> moduleClass) {
    mModuleClass = moduleClass;
  }

  @Override
  public List<MethodDescriptor> getMethodInfo() {
    Set<String> methodIds = new HashSet<>();
    List<MethodDescriptor> methods = new ArrayList<>();
    Class<? extends NativeModule> classForMethods = mModuleClass;
    Class<? extends NativeModule> superClass =
      (Class<? extends NativeModule>) classForMethods.getSuperclass();
    if (ReactModuleWithSpec.class.isAssignableFrom(superClass)) {
      // For java module that is based on generated flow-type spec, inspect the
      // spec abstract class instead, which is the super class of the given java
      // module.
      classForMethods = superClass;
    }
    Method[] targetMethods = classForMethods.getDeclaredMethods();

    for (Method targetMethod : targetMethods) {
      ReactMethod annotation = targetMethod.getAnnotation(ReactMethod.class);
      if (annotation != null) {
        String methodName = targetMethod.getName();
        Class<?>[] parameterTypes = targetMethod.getParameterTypes();
        MethodDescriptor md = new MethodDescriptor();
        md.name = methodName;
        md.retKind = returnTypeToKind(targetMethod.getReturnType());
        md.signature = getSignature(targetMethod.getReturnType(), parameterTypes);
        md.argCount = parameterTypes.length;

        if (methodIds.contains(md.id())) {
          throw new IllegalArgumentException(
            "TurboModule method " + md.id() + " already registered");
        }
        methodIds.add(md.id());
        for (Class paramClass : parameterTypes) {
          // for Backward compatibility as in JavaTurboModule::invokeJavaMethod
          if (paramClass.getName().equals(Promise.class.getName())) {
            md.retKind = MethodDescriptor.MethodValueKind.PromiseKind;
            md.argCount -= 1;
            break;
          }
        }
        methods.add(md);
      }
    }
    return methods;
  }

  static String getSignature(Class ret, Class... params) {
    StringBuilder builder = new StringBuilder();
    builder.append("(");
    for (Class param : params) {
      builder.append(getSignature(param));
    }
    builder.append(")");
    builder.append(getSignature(ret));
    return builder.toString();
  }

  static String getSignature(Class param) {
    StringBuilder builder = new StringBuilder();
    String name = "";
    if (param.isArray()) {
      name = param.getComponentType().getName();
      builder.append("[");
    } else {
      name = param.getName();
    }

    if (PRIMITIVES.containsKey(name)) {
      builder.append(PRIMITIVES.get(name));
    } else {
      builder.append("L").append(name.replace(".", "/")).append(";");
    }

    return builder.toString();
  }

  static MethodDescriptor.MethodValueKind returnTypeToKind(Class returnClass) {
    if (returnClass == boolean.class || returnClass == Boolean.class) {
      return MethodDescriptor.MethodValueKind.BooleanKind;
    } else if (returnClass == int.class || returnClass == Integer.class ||
      returnClass == double.class
      || returnClass == Double.class || returnClass == float.class || returnClass == Float.class
      || returnClass == Long.class || returnClass == long.class) {
      return MethodDescriptor.MethodValueKind.NumberKind;
    } else if (returnClass == String.class) {
      return MethodDescriptor.MethodValueKind.StringKind;
    } else if (returnClass == void.class || returnClass == Void.class) {
      return MethodDescriptor.MethodValueKind.VoidKind;
    } else if (returnClass == WritableMap.class) {
      return MethodDescriptor.MethodValueKind.ObjectKind;
    } else if (returnClass == WritableArray.class) {
      return MethodDescriptor.MethodValueKind.ArrayKind;
    } else if (returnClass == Promise.class) {
      return MethodDescriptor.MethodValueKind.PromiseKind;
    } else {
      return MethodDescriptor.MethodValueKind.FunctionKind;
//      throw new IllegalArgumentException("TurboModule return type (" + returnClass.getName() +
//      ") error");
    }
  }

}
