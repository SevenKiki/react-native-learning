package com.facebook.v8.inspector;

import android.os.Handler;
import java.util.List;
import java.util.ArrayList;

public class TaskQueue {

  private Handler mHandler;
  private int mInterruptInterval;
  private Runnable mInterruptTask;
  private long mNextInterruptTime;
  private List<Runnable> mTasks;
  private boolean mRunLoop = false;
  private boolean mDestroyed = false;
  
  public TaskQueue(Handler handler,
                   int interruptInterval,
                   Runnable interruptTask) {
    mHandler = handler;
    mInterruptInterval = interruptInterval;
    mInterruptTask = interruptTask;
    mNextInterruptTime = System.currentTimeMillis();
    mTasks = new ArrayList<Runnable>();
    mHandler.post(new Runnable() {
      @Override
      public void run() {
        process();
      }
    });
  }

  public void destroy() {
    mDestroyed = true;
  }

  public void post(Runnable task) {
    synchronized(this) {
      mTasks.add(task);
    }
    awake();
  }

  public void loop() {
    mRunLoop = true;
    while (mRunLoop && !mDestroyed) {
      process();
      long now = System.currentTimeMillis();
      if (now < mNextInterruptTime) {
        synchronized(this) {
          try {
            wait(mNextInterruptTime - now);
          } catch (InterruptedException e) {
            return;
          }
        }
      }
    }
  }

  public void cancelLoop() {
    mRunLoop = false;
  }

  public void processInterruptTask() {
    long now = System.currentTimeMillis();
    if (now >= mNextInterruptTime) {
      if (mInterruptTask != null)
        mInterruptTask.run();
      mNextInterruptTime += mInterruptInterval;
    }

    if (now < mNextInterruptTime) {
      mHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
          process();
        }
      }, mNextInterruptTime - now);
    }
  }

  private void awake() {
    synchronized(this) {
      mHandler.post(new Runnable() {
        @Override
        public void run() {
          process();
        }
      });
      notify();
    }
  }

  private void process() {
    if (mDestroyed)
      return;
    List<Runnable> tasks;
    synchronized(this) {
      tasks = mTasks;
      mTasks = new ArrayList<Runnable>();
    }
    for (Runnable task : tasks) {
      task.run();
    }
    processInterruptTask();
  }
};
