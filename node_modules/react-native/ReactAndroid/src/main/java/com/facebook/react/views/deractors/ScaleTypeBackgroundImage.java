/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.react.views.deractors;

import android.graphics.Matrix;
import android.graphics.Rect;
import android.text.TextUtils;

import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.ReadableType;

public class ScaleTypeBackgroundImage extends ScalingUtils.AbstractScaleType {
  private static final int UNSET = 0;
  private static final String POSITION_X = "positionX";
  private static final String POSITION_Y = "positionY";
  private static final String SIZE = "size";
  private static final String WIDTH = "width";
  private static final String HEIGHT = "height";

  private static final String POSITION_LEFT = "left";
  private static final String POSITION_CENTER = "center";
  private static final String POSITION_RIGHT = "right";
  private static final String POSITION_TOP = "top";
  private static final String POSITION_BOTTOM = "bottom";

  private static final String SIZE_COVER = "cover";
  private static final String SIZE_CONTAIN = "contain";
  private static final String SIZE_AUTO = "auto";

  // 背景宽度
  private float mWidth = UNSET;
  private String mWidthString;
  // 背景高度
  private float mHeight = UNSET;
  private String mHeightString;
  private ReadableMap mSource;
  private float mDx;
  private float mDy;

  @Override
  public void getTransformImpl(
    Matrix outTransform,
    Rect parentRect,
    int childWidth,
    int childHeight,
    float focusX,
    float focusY,
    float scaleX,
    float scaleY) {
    mDx = parentRect.left;
    mDy = parentRect.top;
    float scale = 1.0f;
    float sx = 1.0f;
    float sy = 1.0f;
    mWidth = UNSET;
    mHeight = UNSET;
    mWidthString = null;
    mHeightString = null;

    if (mSource.hasKey(SIZE) && mSource.getType(SIZE) == ReadableType.String) {
      if (SIZE_COVER.equals(mSource.getString(SIZE))) {
        scale = Math.max(scaleX, scaleY);
        sx = scale;
        sy = scale;
      }
      if (SIZE_CONTAIN.equals(mSource.getString(SIZE))) {
        scale = Math.min(scaleX, scaleY);
        sx = scale;
        sy = scale;
      }
    }

    if (mSource.hasKey(WIDTH) || mSource.hasKey(HEIGHT)) {
      updateWidth(parentRect);
      updateHeight(parentRect);
      updateWidthAndHeight(childWidth, childHeight);
      sx =  mWidth / (float) childWidth;
      sy =  mHeight / (float) childHeight;
    }

    if (mSource.hasKey(POSITION_X)) {
      if (mSource.getType(POSITION_X) == ReadableType.Number) {
        mDx = (float) mSource.getDouble(POSITION_X);
      } else if (mSource.getType(POSITION_X) == ReadableType.String) {
        String positionXString = mSource.getString(POSITION_X);
        getPositionXByString(positionXString, parentRect, sx, childWidth);
      }
    }

    if (mSource.hasKey(POSITION_Y)) {
      if (mSource.getType(POSITION_Y) == ReadableType.Number) {
        mDy = (float) mSource.getDouble(POSITION_Y);
      } else if (mSource.getType(POSITION_Y) == ReadableType.String) {
        String positionYString = mSource.getString(POSITION_Y);
        getPositionYByString(positionYString, parentRect, sy, childHeight);
      }
    }

    outTransform.setScale(sx, sy);
    outTransform.postTranslate((int) (mDx + 0.5f), (int) (mDy + 0.5f));
  }

  @Override
  public String toString() {
    return "backgroundImageScaleType";
  }

  public void setSource(ReadableMap source) {
    mSource = source;
  }

  private void updateWidthAndHeight(int childWidth, int childHeight) {
    if (SIZE_AUTO.equals(mWidthString) && SIZE_AUTO.equals(mHeightString)) {
      mWidth = childWidth;
      mHeight = childHeight;
    } else if (SIZE_AUTO.equals(mWidthString)) {
      mWidth = mHeight * childWidth / childHeight;
    } else if (SIZE_AUTO.equals(mHeightString)) {
      mHeight = mWidth * childHeight / childWidth;
    }
  }

  private void updateHeight(Rect parentRect) {
    if (mSource.hasKey(HEIGHT)) {
      if (mSource.getType(HEIGHT) == ReadableType.Number) {
        mHeight = mSource.getInt(HEIGHT);
      } else if (mSource.getType(HEIGHT) == ReadableType.String) {
        mHeightString = mSource.getString(HEIGHT);
        mHeight = (parentRect.height() * getPercent(mHeightString) / 100);
      }
    }
  }

  private void updateWidth(Rect parentRect) {
    if (mSource.hasKey(WIDTH)) {
      if (mSource.getType(WIDTH) == ReadableType.Number) {
        mWidth = mSource.getInt(WIDTH);
      } else if (mSource.getType(WIDTH) == ReadableType.String) {
        mWidthString = mSource.getString(WIDTH);
        mWidth = (parentRect.width() * getPercent(mWidthString) / 100);
      }
    }
  }

  private float getPercent(String percentStr) {
    if (TextUtils.isEmpty(percentStr)) {
      return UNSET;
    }
    if (!percentStr.endsWith("%")) {
      return UNSET;
    }

    return Float.parseFloat(percentStr.substring(0, percentStr.length() - 1));
  }

  private void getPositionXByString(String positionXString, Rect parentRect, float scale,
    int childWidth) {
    switch (positionXString) {
      case POSITION_LEFT:
        mDx = parentRect.left;
        break;
      case POSITION_CENTER:
        mDx = parentRect.left + (parentRect.width() - childWidth * scale) * 0.5f;
        break;
      case POSITION_RIGHT:
        mDx = parentRect.left + (parentRect.width() - childWidth * scale);
        break;
      default:
        mDx = (parentRect.width() - (childWidth * scale)) * getPercent(positionXString) / 100;
        break;
    }
  }

  private void getPositionYByString(String positionYString, Rect parentRect, float scale,
    int childHeight) {
    switch (positionYString) {
      case POSITION_TOP:
        mDy = parentRect.top;
        break;
      case POSITION_CENTER:
        mDy = parentRect.top + (parentRect.height() - childHeight * scale) * 0.5f;
        break;
      case POSITION_BOTTOM:
        mDy = parentRect.top + (parentRect.height() - childHeight * scale);
        break;
      default:
        mDy = (parentRect.height() - (childHeight * scale)) * getPercent(positionYString) / 100;
        break;

    }
  }
}
