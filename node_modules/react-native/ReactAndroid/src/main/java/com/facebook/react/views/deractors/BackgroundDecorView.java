package com.facebook.react.views.deractors;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.LinearGradient;
import android.graphics.Paint;
import android.graphics.Shader;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.facebook.react.R;
import com.facebook.react.bridge.JavaOnlyArray;
import com.facebook.react.bridge.JavaOnlyMap;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.ReadableType;
import com.facebook.react.uimanager.ReactStylesDiffMap;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewManager;
import com.facebook.react.uimanager.ViewProps;
import com.facebook.react.views.view.ReactViewGroup;

public class BackgroundDecorView extends ReactViewGroup {
  private static final String TAG = "BackgroundDecorView";
  private static final String GRADIENT_STOPS = "stops";
  private static final String GRADIENT_COLORS = "colors";
  private static final String GRADIENT_DIRECTION = "direction";
  private static final String IMAGE_URI = "uri";
  private static final String KEY_SRC = "src";

  private static final String GRADIENT_TOP_LEFT = "topLeft";
  private static final String GRADIENT_TOP_RIGHT = "topRight";
  private static final String GRADIENT_BOTTOM_LEFT = "bottomLeft";
  private static final String GRADIENT_BOTTOM_RIGHT = "bottomRight";
  // 默认角度从上向下
  private static final int DEFAULT_RADIAN = 180;

  private View mView;
  private ViewManager mImageManager = null;
  private View mImageView = null;
  private Paint mPaint = null;
  private boolean mGradientShow;

  private int[] mColorArray = null;
  private float[] mPositionArray = null;

  // 渐变角度参数
  private int mRadian = DEFAULT_RADIAN;
  private boolean mUseDirectionString;
  private String mDirectionString = null;
  private float[] mDirectionArray = null;

  private ReadableArray mSources;

  public BackgroundDecorView(@NonNull Context context, ViewManager imageManager) {
    super(context);
    setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
      ViewGroup.LayoutParams.WRAP_CONTENT));
    mGradientShow = false;
    mUseDirectionString = false;
    mImageManager = imageManager;
    setBackgroundColor(Color.TRANSPARENT);
  }

  public void bindDecorViewToParent(View view) {
    mView = view;
    mView.setTag(R.id.background_image_view_id, this);
    layout(mView.getLeft(), mView.getTop(), mView.getRight(), mView.getBottom());

    ViewGroup parent = (ViewGroup) mView.getParent();
    int index = 0;
    if (parent != null) {
      index = parent.indexOfChild(mView);
      parent.removeViewAt(index);
    }

    addView(mView, 0);
    if (parent != null) {
      parent.addView(this, index);
    }
  }

  @Override
  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    if (mView != null) {
      mView.layout(0, 0, getWidth(), getHeight());
    }
    if (mImageView != null) {
      mImageView.layout(0, 0, getWidth(), getHeight());
    }
    if (!mGradientShow && mSources != null) {
      updateBackgroundParams(mSources);
    }
  }

  public void setBackgroundParams(@Nullable ReadableArray sources) {
    if (sources == null || sources.size() == 0) {
      return;
    }

    Log.d(TAG, "setBackgroundParams sources = " + sources + " this = " + this);
    // 重置设置
    mPositionArray = null;
    mColorArray = null;
    mDirectionArray = null;
    mRadian = DEFAULT_RADIAN;
    mUseDirectionString = false;
    mGradientShow = false;
    mView.setBackgroundColor(Color.TRANSPARENT);
    setBackgroundColor(Color.TRANSPARENT);
    mSources = sources;
    updateBackgroundParams(mSources);
  }

  public void updateBackgroundParams(@Nullable ReadableArray sources) {

    for (int i = 0; i < sources.size(); ++i) {
      ReadableMap source = sources.getMap(i);
      if (source.hasKey(IMAGE_URI)) {
        updateBackgroundImageParams(source);
      } else {
        if (source.hasKey(GRADIENT_COLORS)) {
          updateGradientColors(source);
        }
        if (source.hasKey(GRADIENT_STOPS)) {
          updateGradientStops(source);
        }
        if (source.hasKey(GRADIENT_DIRECTION)) {
          updateGradientDirection(source);
        }
      }
    }

    if (mGradientShow) {
      gradientParamsUpdated();
    }
  }

  private void updateBackgroundImageParams(@Nullable ReadableMap source) {
    if (mImageManager == null || source == null) {
      return;
    }

    mGradientShow = false;
    if (mImageView == null) {
      createImageView();
    }

    if (mImageView == null) {
      return;
    }

    Log.d(TAG, "updateBackgroundImageParams sources = " + source + " this = " + this);
    mImageManager.updateProperties(mImageView, buildStyles(ViewProps.RESIZE_MODE, "cover"));
    mImageManager.updateProperties(mImageView, buildStyles(KEY_SRC, JavaOnlyArray.of(source)));
    ((BackgroundReactImageView) mImageView).setBackgroundSource(source);
    mImageManager.updateProperties(mImageView, buildStyles(ViewProps.RESIZE_MODE, "backgroundImage"));
  }

  private void createImageView() {
    mImageView =
      mImageManager.createView((ThemedReactContext) getContext(), null, null, null);
    addView(mImageView, 0, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
      ViewGroup.LayoutParams.MATCH_PARENT));
    mImageView.layout(0, 0, getWidth(), getHeight());
    mImageManager.updateProperties(mImageView, buildStyles("fadeDuration", 0));
  }

  private ReactStylesDiffMap buildStyles(Object... keysAndValues) {
    return new ReactStylesDiffMap(JavaOnlyMap.of(keysAndValues));
  }

  private void updateGradientColors(@Nullable ReadableMap source) {
    if (source == null || source.getType(GRADIENT_COLORS) != ReadableType.Array
      || source.getArray(GRADIENT_COLORS).size() <= 1) {
      return;
    }

    mGradientShow = true;
    ReadableArray readableArray = source.getArray(GRADIENT_COLORS);
    mColorArray = new int[readableArray.size()];
    for (int i = 0; i < readableArray.size(); ++i) {
      if (readableArray.getType(i) == ReadableType.Number) {
        mColorArray[i] = (int) readableArray.getDouble(i);
      }
    }
  }

  // 兼容[0, '40%', '80', '100%']
  private void updateGradientStops(@Nullable ReadableMap source) {
    if (source == null || source.getType(GRADIENT_STOPS) != ReadableType.Array
      || source.getArray(GRADIENT_STOPS).size() <= 1
      || source.getArray(GRADIENT_STOPS).size() != mColorArray.length) {
      return;
    }

    mGradientShow = true;
    ReadableArray readableArray = source.getArray(GRADIENT_STOPS);
    mPositionArray = new float[readableArray.size()];
    for (int i = 0; i < readableArray.size(); ++i) {
      float stops = 0;
      if (readableArray.getType(i) == ReadableType.String) {
        String stringStops = readableArray.getString(i);
        stringStops = stringStops.replace("%", "");
        stops = Float.valueOf(stringStops) / 100;
      } else if (readableArray.getType(i) == ReadableType.Number) {
        stops = (float) readableArray.getDouble(i);
      }

      // 兼容后面的位置不小于前面位置
      if (i > 0 && stops < mPositionArray[i - 1]) {
        mPositionArray[i] = mPositionArray[i - 1];
      } else {
        mPositionArray[i] = stops;
      }
    }
  }

  // 兼容弧度和字符串设置
  private void updateGradientDirection(@Nullable ReadableMap source) {
    if (source == null) {
      return;
    }
    mGradientShow = true;
    if (source.getType(GRADIENT_DIRECTION) == ReadableType.Number) {
      mUseDirectionString = false;
      mRadian = (int) source.getDouble(GRADIENT_DIRECTION);
    } else if (source.getType(GRADIENT_DIRECTION) == ReadableType.String) {
      mUseDirectionString = true;
      mDirectionString = source.getString(GRADIENT_DIRECTION);
    }
  }

  private void gradientParamsUpdated() {
    if (mPaint == null) {
      mPaint = new Paint();
    }

    Log.d(TAG, "gradientParamsUpdated this = " + this);
    // 更新完属性需手动刷新
    invalidate();
    if (mImageView != null) {
      removeView(mImageView);
      mImageView = null;
    }
  }

  @Override
  protected void dispatchDraw(Canvas canvas) {
    if (mGradientShow && mPaint != null && mColorArray != null) {

      // 确认渐变方向
      if (mUseDirectionString) {
        mDirectionArray = directionStringToPosition(mDirectionString);
      } else {
        mDirectionArray = radianToPosition(mRadian);
      }

      // 处理Stops默认值
      if (mPositionArray == null) {
        stopsMatchColors();
      }

      if (mPositionArray != null) {
        LinearGradient bgGradient = new LinearGradient(mDirectionArray[0], mDirectionArray[1],
          mDirectionArray[2], mDirectionArray[3], mColorArray, mPositionArray,
          Shader.TileMode.CLAMP);

        mPaint.setShader(bgGradient);
        if (mReactBackgroundDrawable != null &&
          mReactBackgroundDrawable.mInnerClipPathForBorderRadius != null) {
          // 在父view对应的圆角矩形绘制
          canvas.drawPath(mReactBackgroundDrawable.mInnerClipPathForBorderRadius, mPaint);
        } else {
          canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
        }

      }
    }
    super.dispatchDraw(canvas);
  }

  private void stopsMatchColors() {
    for (int i = 0; i < mColorArray.length; i++) {
      float divide = 1 / mColorArray.length;
      if (i == mColorArray.length - 1) {
        mPositionArray[i] = 1;
      } else {
        mPositionArray[i] = (i + 1) * divide;
      }
    }
  }

  private float[] directionStringToPosition(String directionString) {
    if (directionString == null) {
      return new float[]{0, 0, 0, 0};
    }

    float width = getWidth();
    float height = getHeight();
    switch (directionString) {
      case GRADIENT_TOP_LEFT:
        return new float[]{width, height, 0, 0};
      case GRADIENT_TOP_RIGHT:
        return new float[]{0, height, width, 0};
      case GRADIENT_BOTTOM_LEFT:
        return new float[]{width, 0, 0, height};
      case GRADIENT_BOTTOM_RIGHT:
        return new float[]{0, 0, width, height};
    }

    return new float[]{0, 0, 0, 0};
  }

  private float[] radianToPosition(int radian) {
    radian = radian % 360;
    float width = getWidth();
    float height = getHeight();

    switch (radian) {
      case 0:
        return new float[]{0, height, 0, 0};
      case 90:
        return new float[]{0, 0, width, 0};
      case 180:
        return new float[]{0, 0, 0, height};
      case 270:
        return new float[]{width, 0, 0, 0};
    }

    float startX = 0;
    float startY = 0;
    float endX = 0;
    float endY = 0;

    if (radian < 90 && radian > 0) {
      startX = 0;
      startY = height;
      endX = height * (float) Math.tan(getAngle(radian));
      endY = height - width * (float) Math.tan(getAngle(90 - radian));
      if (endX > width) {
        endX = width;
      } else {
        endY = 0;
      }
    } else if (radian > 90 && radian < 180) {
      startX = 0;
      startY = 0;
      endX = height * (float) Math.tan(getAngle(180 - radian));
      endY = width * (float) Math.tan(getAngle(radian - 90));
      if (endY > height) {
        endY = height;
      } else {
        endX = width;
      }
    } else if (radian > 180 && radian < 270) {
      startX = width;
      startY = 0;
      endX = width - height * (float) Math.tan(getAngle(radian - 180));
      endY = width * (float) Math.tan(getAngle(270 - radian));
      if (endX < 0) {
        endX = 0;
      } else {
        endY = height;
      }
    } else if (radian > 270 && radian < 360) {
      startX = width;
      startY = height;
      endX = width - height * (float) Math.tan(getAngle(360 - radian));
      endY = height - width * (float) Math.tan(getAngle(radian - 270));
      if (endX < 0) {
        endX = 0;
      } else {
        endY = 0;
      }
    }

    return new float[]{startX, startY, endX, endY};
  }

  // Border圆角同步设置到ImageView
  public void setBorderRadius(float borderRadius) {
    super.setBorderRadius(borderRadius);
    if (mImageManager != null && mImageView != null) {
      ((BackgroundReactImageView) mImageView).updateBorderRadius(borderRadius);
    }
  }

  // Border圆角同步设置到ImageView
  public void setBorderRadius(float borderRadius, int position) {
    super.setBorderRadius(borderRadius, position);
    if (mImageManager != null && mImageView != null) {
      ((BackgroundReactImageView) mImageView).updateBorderRadius(borderRadius, position);
    }
  }

  // Border圆角同步设置到ImageView
  public void setBorderRadius(float[] mBorderCornerRadii) {
    for (int position = 0; position < mBorderCornerRadii.length; position++) {
      super.setBorderRadius(mBorderCornerRadii[position], position);
    }
    if (mImageManager != null && mImageView != null) {
      ((BackgroundReactImageView) mImageView).updateBorderRadius(mBorderCornerRadii);
    }
  }

  public float getAngle(int radian) {
    return radian * (float) Math.PI / 180;
  }

  public <T extends View> T getOriginView() {
    return (T) mView;
  }

  public void release() {
    mView.setTag(R.id.background_image_view_id, null);
    mView.layout(getLeft(), getTop(), getRight(), getBottom());

    ViewGroup parent = (ViewGroup) getParent();
    if (parent == null) {
      return;
    }
    int index = parent.indexOfChild(this);
    removeAllViews();
    parent.removeViewAt(index);
    parent.addView(mView, index);
  }

  public static BackgroundDecorView fromView(View view) {
    return (BackgroundDecorView) view.getTag(R.id.background_image_view_id);
  }
}
