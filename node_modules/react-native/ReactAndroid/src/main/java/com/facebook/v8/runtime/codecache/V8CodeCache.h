#pragma once

#include "V8CacheOptions.h"
#include "jsi/jsilib.h"
#include "v8.h"

#define CODE_CACHE_DEBUG 0

namespace facebook {

class V8CodeCache final {
 public:
  enum class ProduceCacheOptions {
    kNoProduceCache,
    kSetTimeStamp,
    kProduceCodeCache,
  };

  static std::tuple<
      v8::ScriptCompiler::CompileOptions,
      ProduceCacheOptions,
      v8::ScriptCompiler::NoCacheReason>
  GetCompileOptions(
      const std::string &url,
      V8CacheOptions cacheOptions,
      const jsi::CodeCacheItem &codeCacheItem);

  static void ProduceCache(
      v8::Isolate *,
      v8::Local<v8::Script>,
      const std::string &,
      jsi::CodeCacheItem &codeCacheItem,
      ProduceCacheOptions);

  static bool HasCache(const jsi::CodeCacheItem &codeCacheItem);

  // url for DEBUG only
  static v8::ScriptCompiler::CachedData *CreateCachedData(
      const jsi::CodeCacheItem &codeCacheItem, const std::string &url);

#if CODE_CACHE_DEBUG 
  static bool ReadFile(const std::string &url, uint8_t **data, int &dataSize);
  static bool
  WriteFile(const std::string filePath, const uint8_t *data, int size);
  static bool HasCache(const std::string &url);
  static v8::ScriptCompiler::CachedData *CreateCachedData(
      const std::string &url);
#endif

 private:
  enum NotNullTag { NotNull };

  // STATIC_ONLY
  V8CodeCache() = delete;
  V8CodeCache(const V8CodeCache &) = delete;
  V8CodeCache &operator=(const V8CodeCache &) = delete;
  void *operator new(size_t) = delete;
  void *operator new(size_t, NotNullTag, void *) = delete;
  void *operator new(size_t, void *) = delete;
};

} // namespace facebook
