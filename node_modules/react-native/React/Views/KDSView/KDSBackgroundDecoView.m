//
//  KDSBackgroundDecoView.m
//  React-Core
//
//  Created by joyo on 2021/7/13.
//

#import "KDSBackgroundDecoView.h"
#import "RCTUIManager.h"
#import <React/RCTImageView.h>
#import "RCTImageViewManager.h"
#import <objc/runtime.h>
#import "UIView+React.h"

static NSInteger DEFAULT_RADIAN = 180;
static NSString *GRADIENT_STOPS = @"stops";
static NSString *GRADIENT_COLORS = @"colors";
static NSString *GRADIENT_DIRECTION = @"direction";
static NSString *IMAGE_URI = @"uri";
static NSString *KEY_SRC = @"src";
static NSString *GRADIENT_TOP_LEFT = @"topLeft";
static NSString *GRADIENT_TOP_RIGHT = @"topRight";
static NSString *GRADIENT_BOTTOM_LEFT = @"bottomLeft";
static NSString *GRADIENT_BOTTOM_RIGHT = @"bottomRight";

static NSString *M_VIEW_CORNER_RADIUS = @"self.mView.layer.cornerRadius";

static NSString *M_VIEW_BOUNDS = @"self.mView.bounds";
static NSString *M_VIEW_CENTER = @"self.mView.center";

@implementation UIView (BackgroundDecoView)

- (KDSBackgroundDecoView *)decoView
{
    return objc_getAssociatedObject(self, @selector(decoView));
}

- (void)setDecoView:(KDSBackgroundDecoView *)decoView
{
    objc_setAssociatedObject(self, @selector(decoView), decoView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end

@interface KDSBackgroundDecoView()

@property (nonatomic, weak) RCTView *mView; // 弱引用
@property (nonatomic, strong) UIImageView *imageView;
@property (nonatomic, strong) UIImage *image;
@property (nonatomic, strong) CAGradientLayer *gradientLayer;
@property (nonatomic) NSInteger mRadian;
@property (nonatomic) BOOL mGradientShow;
@property (nonatomic) NSString *mDirectionString;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *mDirectionArray;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *mColorArray;
@property (nonatomic, strong) NSMutableArray<NSNumber *> *mPositionArray;
@property (nonatomic) CGFloat mCornerRadius;
@property (nonatomic) CGFloat mCornerWidth;
@property (nonatomic) CGColorRef mCornerColor;
@property (nonatomic, strong) CAShapeLayer *borderLayer;

@property (nonatomic) CGRect mBounds;
@property (nonatomic) CGPoint mCenter;
@property (nonatomic) BOOL mBoundsShouldDisplay;
@property (nonatomic) BOOL mCenterShouldDisplay;

@end

@implementation KDSBackgroundDecoView

-(void)dealloc
{
    [self removeObserver:self forKeyPath:M_VIEW_CORNER_RADIUS];
    [self removeObserver:self forKeyPath:M_VIEW_BOUNDS];
    [self removeObserver:self forKeyPath:M_VIEW_CENTER];
}

- (void)releaseDecoViewFromParent
{
    UIView *originalSuperview = self.superview;
    if (!originalSuperview || !_mView) {
        return;
    }
    NSUInteger originalIndex = [originalSuperview.subviews indexOfObjectIdenticalTo:self];
    self.imageView.image = nil;
    [self.imageView removeFromSuperview];
    self.imageView = nil;
    _mView.frame = self.frame;
    [originalSuperview insertSubview:_mView atIndex:originalIndex];
    self.userInteractionEnabled = NO;
    [self removeFromSuperview];
    _mView.decoView = nil;
}

- (instancetype)initWithView:(RCTView *)view
{
    if (!view) {
        return nil;
    }
    self = [super init];
    if (self) {
        self.frame = CGRectZero;
        _mView = view;
    }
    return self;
}

- (void)layoutSubviews
{
    [super layoutSubviews];
    if ([self.subviews containsObject:self.mView] &&
        (self.mView.frame.origin.x != 0 || self.mView.frame.origin.y != 0))
    {
        self.mView.frame = self.mView.bounds;
    }
}

- (void)startUp
{
    self.backgroundColor = [UIColor clearColor];
    self.mGradientShow = NO;
    self.mCornerRadius = 0;
    self.mRadian = DEFAULT_RADIAN;
    self.mColorArray = [NSMutableArray new];
    self.mPositionArray = [NSMutableArray new];
    self.mDirectionArray = [[NSMutableArray alloc] initWithArray:@[@0, @0, @0, @1]];
    self.mBounds = CGRectZero;
    self.mCenter = CGPointZero;
    self.mBoundsShouldDisplay = NO;
    self.mCenterShouldDisplay = NO;
}

- (void)bindDecoViewToParent:(RCTView *)view
{
    if (!view) {
        return;
    }
    // 绑定 mView与self
    _mView.decoView = self;
    _mView = view;
    self.frame = _mView.frame;
    UIView *parentView = view.superview;
    NSInteger index = 0;
    if (parentView) {
        index = [parentView.subviews indexOfObject:view];
        [view removeFromSuperview];
    }
    _mView.frame = _mView.bounds;
    if (!_mView) {
        return;
    }
    [self insertSubview:_mView atIndex:0];
    if (parentView) {
        [parentView insertSubview:self atIndex:index];
    }
    
    NSKeyValueObservingOptions options = (NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld);
    [self addObserver:self forKeyPath:M_VIEW_CORNER_RADIUS options:options context:nil];
    [self addObserver:self forKeyPath:M_VIEW_BOUNDS options:options context:nil];
    [self addObserver:self forKeyPath:M_VIEW_CENTER options:options context:nil];
    
    __weak __typeof(view) weakView = view;
    view.updateReactSubviewBlock = ^(UIView *fatherView) {
        __strong typeof(weakView) strongView = weakView;
        NSInteger index = [fatherView.subviews indexOfObject:strongView];
        RCTView *decoView = strongView.decoView;
        [fatherView insertSubview:decoView atIndex:index];
    };
    
    view.removeReactSubviewBlock = ^(UIView *fatherView) {
        __strong typeof(weakView) strongView = weakView;
        RCTView *decoView = strongView.decoView;
        [decoView removeFromSuperview];
    };
}

/// 监听初始View的圆角和边框属性，同步给imageView
-(void)observeValueForKeyPath:(NSString *)keyPath
                     ofObject:(id)object
                       change:(NSDictionary<NSKeyValueChangeKey,id> *)change
                      context:(void *)context
{
    if ([keyPath isEqualToString:M_VIEW_BOUNDS]) {
        CGRect bounds = [[change objectForKey:@"new"] CGRectValue];
        // Avoid crashes due to nan coords
        if (isnan(bounds.origin.x) || isnan(bounds.origin.y) ||
            isnan(bounds.size.width) || isnan(bounds.size.height)) {
            return;
        }
        self.mBounds = bounds;
        self.mBoundsShouldDisplay = YES;
        [self calculateAndSetFrameWithCenter:self.mCenter bounds:self.mBounds];
    }
    if ([keyPath isEqualToString:M_VIEW_CENTER]) {
        CGPoint center = [[change objectForKey:@"new"] CGPointValue];
        // Avoid crashes due to nan coords
        if (isnan(center.x) || isnan(center.y)) {
            return;
        }
        self.mCenter = center;
        self.mCenterShouldDisplay = YES;
        [self calculateAndSetFrameWithCenter:self.mCenter bounds:self.mBounds];
    }
    if ([keyPath isEqualToString:M_VIEW_CORNER_RADIUS]) {
        CGFloat value = [[change objectForKey:@"new"] floatValue];
        self.mCornerRadius = value;
        CGSize size = CGSizeMake(value, value);
        CAShapeLayer *maskLayer = [self addCornersRadius:UIRectCornerAllCorners
                                                  bounds:self.imageView.bounds
                                                   radii:size];
        self.imageView.layer.mask = maskLayer;
    }
}

- (void)setBackGroundImageProps:(NSArray<NSDictionary *> *)backgroundImages
{
    if (!backgroundImages || backgroundImages.count == 0) {
        return;
    }
    
    [self startUp];
    
    __block BOOL shouldShowImage = NO;
    __block BOOL shouldResetColors = YES;
    __block BOOL shouldResetStops = YES;
    __block BOOL shouldResetDirections = YES;
    [backgroundImages enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        // 目前背景图与渐变色不支持同时使用
        if ([obj objectForKey:IMAGE_URI]) {
            [self createImageView:obj];
            shouldShowImage = YES;
            *stop = YES;
        } else {
            if ([obj objectForKey:GRADIENT_COLORS]) {
                [self updateGradientColors:obj];
                shouldResetColors = NO;
            }
            if ([obj objectForKey:GRADIENT_STOPS]) {
                [self updateGradientStops:obj];
                if (_mPositionArray.count == 0 || !_mPositionArray) {
                    [self stopsMatchColors];
                }
                shouldResetStops = NO;
            }
            if ([obj objectForKey:GRADIENT_DIRECTION]) {
                [self updateGradientDirection:obj];
                shouldResetDirections = NO;
            }
        }
    }];
    
    if (shouldResetColors) {
        self.mColorArray = [NSMutableArray new];
    }
    if (shouldResetStops) {
        self.mPositionArray = [NSMutableArray new];
    }
    if (shouldResetDirections) {
        self.mDirectionArray = [[NSMutableArray alloc] initWithArray:@[@0, @0, @0, @1]];
    }
    
    if (shouldShowImage) {
        [CATransaction begin];
        [CATransaction setDisableActions:YES];
        self.gradientLayer.frame = CGRectZero;
        self.gradientLayer = nil;
        [CATransaction commit];
        [self.gradientLayer setNeedsLayout];
        [self.gradientLayer layoutIfNeeded];
    }
    // 更新完属性需手动刷新
    if (_mGradientShow) {
        [self dispalyGradientLayer];
        if (!shouldShowImage && [self.subviews containsObject:self.imageView]) {
            self.imageView.image = nil;
            [self.imageView setNeedsLayout];
            [self.imageView layoutIfNeeded];
        }
    }
    
    if (![self.subviews containsObject:_imageView]) {
        self.imageView.frame = self.bounds;
        [self insertSubview:self.imageView atIndex:0];
    }
    
    [self didUpdateReactSubviews];
}

#pragma mark - private method

// 更新布局信息
- (void)calculateAndSetFrameWithCenter:(CGPoint)center bounds:(CGRect)bounds
{
    // Avoid crashes due to nan coords
    if (isnan(center.x) || isnan(center.y) ||
        isnan(bounds.origin.x) || isnan(bounds.origin.y) ||
        isnan(bounds.size.width) || isnan(bounds.size.height)) {
        return;
    }
    if (self.shouldSetFrame) {
        CGFloat x = self.mCenter.x - self.mBounds.size.width / 2;
        CGFloat y = self.mCenter.y - self.mBounds.size.height / 2;
        [self changedFrame:CGRectMake(x, y, self.mBounds.size.width, self.mBounds.size.height)];
        self.mBoundsShouldDisplay = NO;
        self.mCenterShouldDisplay = NO;
    }
}

- (BOOL)shouldSetFrame
{
    return self.mBounds.size.height >= 0 && self.mBounds.size.width >= 0 && self.mBoundsShouldDisplay && self.mCenterShouldDisplay;
}

// 更新视图大小
- (void)changedFrame:(CGRect)frame
{
    self.frame = frame;
    if (self.imageView) {
        self.imageView.frame = self.bounds;
    }
    self.mView.frame = self.bounds;
    if (self.gradientLayer) {
        self.gradientLayer.frame = self.imageView.bounds;
    }
}

// 处理渐变色
- (void)dispalyGradientLayer
{
    if (_mColorArray.count <= 0 ||
        _mPositionArray.count <= 0 ||
        _mColorArray.count != _mPositionArray.count ||
        !_mGradientShow)
    {
        self.gradientLayer = nil;
        [self.gradientLayer removeFromSuperlayer];
        [self setNeedsLayout];
        return;
    }
    // 设置渐变颜色数组
    NSMutableArray *colorsTemp = [NSMutableArray new];
    for (NSInteger i = 0; i < [[_mColorArray copy] count]; i++) {
        UIColor *co = [self fromSonarValue:_mColorArray[i]];
        [colorsTemp addObject:(__bridge id)co.CGColor];
    }
    self.gradientLayer.colors = [colorsTemp copy];
    
    // 设置渐变起始点和结束点
    if (_mDirectionArray.count == 4) {
        self.gradientLayer.startPoint = CGPointMake([_mDirectionArray[0] floatValue], [_mDirectionArray[1] floatValue]);
        self.gradientLayer.endPoint = CGPointMake([_mDirectionArray[2] floatValue], [_mDirectionArray[3] floatValue]);
    }
    
    // 设置渐变颜色分布区间
    self.gradientLayer.locations = [_mPositionArray copy];
    
    if (![self.imageView.layer.sublayers containsObject:_gradientLayer]) {
        [self.imageView.layer addSublayer:_gradientLayer];
    }
    
    if (![self.subviews containsObject:_imageView]) {
        self.imageView.frame = self.bounds;
        [self insertSubview:self.imageView atIndex:0];
    }
}

// 获取背景图
- (void)createImageView:(NSDictionary *)params
{
    NSString *url = [params objectForKey:@"uri"];
    if (!url || url.length <= 0) {
        return;
    }
    NSURL *URL = [NSURL URLWithString:url];
    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:URL]];
    if (image && image != _image) {
        _mGradientShow = NO;
        self.imageView.image = image;
        _image = image;
        self.imageView.frame = self.bounds;
    }
}

// 渐变色颜色
- (void)updateGradientColors:(NSDictionary *)dict
{
    if (!dict ||
        ![[dict objectForKey:GRADIENT_COLORS] isKindOfClass:[NSArray class]] ||
        [[dict objectForKey:GRADIENT_COLORS] count] <= 1)
    {
        return;
    }
    _mGradientShow = YES;
    NSArray *colors = [dict objectForKey:GRADIENT_COLORS];
    [colors enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if ([obj isKindOfClass:[NSNumber class]]) {
            [_mColorArray addObject:obj];
        }
    }];
}

// 兼容[0, '40%', '80', '100%']
- (void)updateGradientStops:(NSDictionary *)dict
{
    if (!dict
        || ![[dict objectForKey:GRADIENT_STOPS] isKindOfClass:[NSArray class]]
        || [[dict objectForKey:GRADIENT_STOPS] count] <= 1
        || [[dict objectForKey:GRADIENT_STOPS] count] != _mColorArray.count)
    {
        return;
    }
    _mGradientShow = YES;
    NSArray *stops = [dict objectForKey:GRADIENT_STOPS];
    CGFloat preValue = 0;
    for (NSInteger i = 0; i < stops.count; i++) {
        CGFloat cur = 0;
        if (stops[i] && [stops[i] isKindOfClass:[NSString class]]) {
            NSString *stopString = [(NSString *)stops[i] stringByReplacingOccurrencesOfString:@"%" withString:@""];
            CGFloat stopInt = [stopString floatValue];
            cur = stopInt / 100.0;
        } else if (stops[i] && [stops[i] isKindOfClass:[NSNumber class]]) {
            cur = [stops[i] floatValue];
        }
        if (i > 0 && cur < preValue ) {
            [_mPositionArray addObject:@(preValue)];
        } else {
            [_mPositionArray addObject:@(cur)];
        }
        preValue = cur;
    }
}

- (void)stopsMatchColors
{
    for (NSInteger i = 0; i < [[_mColorArray copy] count]; i++) {
        CGFloat divide = 1 / _mColorArray.count;
        if (i == _mColorArray.count - 1) {
            _mPositionArray[i] = @(1);
        } else {
            _mPositionArray[i] = @((i + 1) * divide);
        }
    }
}

// 兼容角度和字符串设置
- (void)updateGradientDirection:(NSDictionary *)dict
{
    if (dict == nil ||
        [dict count] == 0 ||
        ![dict objectForKey:GRADIENT_DIRECTION])
    {
        return;
    }
    _mGradientShow = YES;
    if ([[dict objectForKey:GRADIENT_DIRECTION] isKindOfClass:[NSNumber class]]) {
        _mRadian = [[dict objectForKey:GRADIENT_DIRECTION] integerValue];
        _mDirectionArray = [self radianToPosition:_mRadian];
    } else if ([[dict objectForKey:GRADIENT_DIRECTION] isKindOfClass:[NSString class]]) {
        _mDirectionString = [[dict objectForKey:GRADIENT_DIRECTION] stringValue];
        _mDirectionArray = [self directionStringToPosition:_mDirectionString];
    }
}

// 处理渐变色方向
- (NSMutableArray *)directionStringToPosition:(NSString *)directionString
{
    if (directionString == nil || directionString.length == 0) {
        return [[NSMutableArray alloc] initWithArray:@[@0, @0, @0, @1]];
    }
    if ([directionString isEqualToString:GRADIENT_TOP_LEFT]) {
        return [[NSMutableArray alloc] initWithArray:@[@1, @1, @0, @0]];
    } else if ([directionString isEqualToString:GRADIENT_TOP_RIGHT]) {
        return [[NSMutableArray alloc] initWithArray:@[@0, @1, @1, @0]];
    } else if ([directionString isEqualToString:GRADIENT_BOTTOM_LEFT]) {
        return [[NSMutableArray alloc] initWithArray:@[@1, @0, @0, @1]];
    } else if ([directionString isEqualToString:GRADIENT_BOTTOM_RIGHT]) {
        return [[NSMutableArray alloc] initWithArray:@[@0, @0, @1, @1]];
    }
    return [[NSMutableArray alloc] initWithArray:@[@0, @0, @0, @1]];
}

// 渐变色角度转换为起始坐标点
- (NSMutableArray<NSNumber *>*)radianToPosition:(NSInteger )radian
{
    radian = radian % 360;
    switch (radian) {
        case 0:
            return [[NSMutableArray alloc] initWithArray:@[@0, @1, @0, @0]];
        case 90:
            return [[NSMutableArray alloc] initWithArray:@[@0, @0, @1, @0]];
        case 180:
            return [[NSMutableArray alloc] initWithArray:@[@1, @0, @1, @1]];
        case 270:
            return [[NSMutableArray alloc] initWithArray:@[@1, @1, @0, @1]];
    }
    
    CGFloat width = 100;
    CGFloat height = 100;
    CGFloat startX = 0;
    CGFloat startY = 0;
    CGFloat endX = 0;
    CGFloat endY = 0;
    
    if (radian < 90 && radian > 0) {
        startX = 0;
        startY = height;
        endX = height * (CGFloat)tan([self getAngle:radian]);
        endY = height - width * (CGFloat)tan([self getAngle:(90 - radian)]);
        if (endX > width) {
            endX = width;
        } else {
            endY = 0;
        }
    } else if (radian > 90 && radian < 180) {
        startX = 0;
        startY = 0;
        endX = height * (CGFloat)tan([self getAngle:(180 - radian)]);
        endY = width * (CGFloat)tan([self getAngle:(radian - 90)]);
        if (endY > height) {
            endY = height;
        } else {
            endX = width;
        }
    } else if (radian > 180 && radian < 270) {
        startX = width;
        startY = 0;
        endX = width - height * (CGFloat)tan([self getAngle:(radian - 180)]);
        endY = height - width * (CGFloat)tan([self getAngle:(270 - radian)]);
        if (endX < 0) {
            endX = 0;
        } else {
            endY = height;
        }
    } else if (radian > 270 && radian < 360) {
        startX = width;
        startY = height;
        endX = width - height * (CGFloat)tan([self getAngle:(360 - radian)]);
        endY = height - width * (CGFloat)tan([self getAngle:(radian - 270)]);
        if (endX < 0) {
            endX = 0;
        } else {
            endY = 0;
        }
    }
    
    return [[NSMutableArray alloc] initWithArray:@[@(startX / width), @(startY / height), @(endX / width), @(endY / height)]];
}

- (CGFloat )getAngle:(NSInteger )radian
{
    return radian * (CGFloat)M_PI / 180;
}

- (UIColor *)fromSonarValue:(NSNumber *)sonarValue
{
    NSUInteger intColor = [sonarValue integerValue];
    CGFloat r, g, b, a;
    b = (CGFloat)(intColor & 0xFF) / 255;
    g = (CGFloat)((intColor >> 8) & 0xFF) / 255;
    r = (CGFloat)((intColor >> 16) & 0xFF) / 255;
    a = (CGFloat)((intColor >> 24) & 0xFF) / 255;
    
    return [[UIColor alloc] initWithRed: r green: g blue: b alpha: a];
}

- (CAShapeLayer *)addCornersRadius:(UIRectCorner)corners
                            bounds:(CGRect)bounds
                             radii:(CGSize)radii
{
    CAShapeLayer* shapeLayer = [CAShapeLayer layer];
    shapeLayer.frame = bounds;
    shapeLayer.backgroundColor = (__bridge CGColorRef _Nullable)([UIColor whiteColor]);
    shapeLayer.path = [UIBezierPath bezierPathWithRoundedRect:bounds byRoundingCorners:corners cornerRadii:radii].CGPath;
    return shapeLayer;
}

# pragma mark - getter method

- (UIImageView *)imageView
{
    if (!_imageView) {
        _imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)];
        _imageView.contentMode = UIViewContentModeScaleAspectFill;
        _imageView.clipsToBounds = YES;
        if (![self.subviews containsObject:_imageView]) {
            _imageView.frame = self.bounds;
            [self insertSubview:self.imageView atIndex:0];
        }
    }
    return _imageView;
}

- (CAGradientLayer *)gradientLayer
{
    if (!_gradientLayer) {
        _gradientLayer = [CAGradientLayer layer];
        _gradientLayer.frame = self.imageView.bounds;
    }
    if (![self.imageView.layer.sublayers containsObject:_gradientLayer]) {
        [self.imageView.layer insertSublayer:_gradientLayer atIndex:0];
    }
    return _gradientLayer;
}

@end
