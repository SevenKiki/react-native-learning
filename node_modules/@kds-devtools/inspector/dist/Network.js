"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Inspector_1 = __importDefault(require("./Inspector"));
class NetworkInspector extends Inspector_1.default {
    constructor() {
        super({
            name: 'Network',
            type: 'Network',
        });
        this.REQUEST_ID = 0;
        const originOpen = XMLHttpRequest.prototype.open;
        const _this = this;
        const originSend = XMLHttpRequest.prototype.send;
        XMLHttpRequest.prototype.send = function send(body) {
            if (body) {
                // @ts-ignore
                this['KDS_NETWORK'].body = body;
            }
            originSend.call(this, body);
        };
        // @ts-ignore
        XMLHttpRequest.prototype.open = function (...args) {
            // @ts-ignore
            this._xmlItem = { openData: args };
            const id = _this.REQUEST_ID++;
            Object.defineProperty(this, 'KDS_NETWORK', {
                enumerable: false,
                configurable: false,
                writable: false,
                value: {
                    id: `XHR_${id}`,
                    connectID: id,
                    method: args[0],
                    url: args[1],
                    headers: {},
                    body: {},
                    startTime: Date.now(),
                },
            });
            this.addEventListener('readystatechange', async () => {
                switch (this.readyState) {
                    case this.DONE: {
                        const { headers } = _this.getXHRResHeaders(this);
                        let mimeType = this.getResponseHeader('Content-Type')?.split(';')[0] || '';
                        if (!mimeType) {
                            if (this.responseType === 'json') {
                                mimeType = 'application/json';
                            }
                            else if (this.responseType === 'document') {
                                mimeType = 'text/html';
                            }
                        }
                        const { text, size } = await _this.getXHRResAndEncodedSize(this);
                        // TODO: 原生这里有BUG需要修复
                        // delete headers.location;
                        _this.sendMessage({
                            type: 'notification',
                            data: {
                                method: 'Network.responseReceived',
                                params: {
                                    // @ts-ignore
                                    requestId: this['KDS_NETWORK'].id,
                                    // @ts-ignore
                                    url: this['KDS_NETWORK'].url,
                                    status: this.status,
                                    statusText: this.statusText || '',
                                    headers,
                                    // @ts-ignore
                                    method: this['KDS_NETWORK'].method,
                                    mimeType,
                                    // @ts-ignore
                                    requestHeaders: this['KDS_NETWORK'].headers,
                                    // @ts-ignore
                                    connectionId: this['KDS_NETWORK'].connectID,
                                    encodedDataLength: size,
                                    // @ts-ignore
                                    body: this['KDS_NETWORK'].body,
                                    // @ts-ignore
                                    responseTime: Date.now() - this['KDS_NETWORK'].startTime,
                                    responseText: text,
                                },
                            },
                        });
                        break;
                    }
                }
            });
            this.addEventListener('error', async () => {
                const { text } = await _this.getXHRResAndEncodedSize(this);
                _this.sendMessage({
                    type: 'notification',
                    data: {
                        method: 'Network.loadingFailed',
                        data: {
                            // @ts-ignore
                            requestId: this['KDS_NETWORK'].id,
                            type: 'XHR',
                            // @ts-ignore
                            responseTime: Date.now() - this['KDS_NETWORK'].startTime,
                            errorText: text,
                        },
                    },
                });
            });
            // @ts-ignore
            originOpen.apply(this, args);
        };
        const originXHR = XMLHttpRequest.prototype.setRequestHeader;
        XMLHttpRequest.prototype.setRequestHeader = function setRequestHeader(name, value) {
            // @ts-ignore
            this['KDS_NETWORK'].headers[name] = value;
            originXHR.call(this, name, value);
        };
    }
    async getXHRResAndEncodedSize(xhr) {
        const contentLength = xhr.getResponseHeader('Content-Length');
        let size = NaN;
        if (contentLength?.length) {
            size = Number(contentLength);
        }
        if (xhr.response === null) {
            return { tex: '', size: 0 };
        }
        if (Number.isNaN(size)) {
            switch (xhr.responseType) {
                case 'arraybuffer':
                    size = xhr.response.byteLength;
                    break;
                case 'blob':
                    size = xhr.response.size;
                    break;
                case 'document':
                    // warn('XMLHttpRequest respond with document is not supported in KDS DevTools.');
                    size = 0;
                    break;
                case 'json':
                    size = new Blob([JSON.stringify(xhr.response)]).size;
                    break;
                case 'text':
                default:
                    size = new Blob([xhr.responseText]).size;
                    break;
            }
        }
        let text = '';
        if (xhr.responseType === 'arraybuffer' || xhr.responseType === 'blob') {
            text = await new Promise(resolve => {
                const blob = xhr.responseType === 'blob' ? xhr.response : new Blob([xhr.response]);
                if (blob.text) {
                    return resolve(blob.text());
                }
                const timeout = setTimeout(() => {
                    resolve(`Cannot read Blob data (type: ${blob.type}, size: ${blob.size})`);
                }, 5e3);
                const reader = new FileReader();
                reader.onload = () => {
                    clearTimeout(timeout);
                    resolve(reader.result);
                };
                reader.readAsText(blob);
            });
        }
        else if (xhr.responseType === 'document') {
            console.warn('XMLHttpRequest respond with document is not supported in KDS DevTools.');
        }
        else if (xhr.responseType === 'json') {
            text = JSON.stringify(xhr.response, null, 2);
        }
        else {
            text = xhr.responseText;
        }
        return { text, size };
    }
    getXHRResHeaders(xhr) {
        const headersText = xhr.getAllResponseHeaders();
        const headers = {};
        for (const line of headersText?.split(/\r?\n/) || []) {
            const trimmed = line.trim();
            const index = trimmed.indexOf(':');
            if (index >= 0) {
                headers[trimmed.substr(0, index).trim()] = trimmed.substr(index + 1).trim();
            }
        }
        return { headers, headersText };
    }
}
exports.default = NetworkInspector;
