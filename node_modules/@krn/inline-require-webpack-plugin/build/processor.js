"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processSource = processSource;
const importPattern = /var (\w+_WEBPACK_[A-Z]+_MODULE_\w+) = ([/*#\w]*)(__webpack_require__[^;,]+);/g;
function checkSideEffectFree(sideEffectFree, requireExpression) {
  // check if module has sideEffects false
  const [, importedModule] = requireExpression.match(/["']([^"']+)["']/) || requireExpression.match(/__webpack_require__\((\d+)\)/) || [];
  return sideEffectFree.get(importedModule) || false;
}
function collectRequires(src, sideEffectFree) {
  // Collect require variables
  const requireVariables = new Map();
  const matches = src.matchAll(importPattern);
  for (const match of matches) {
    const variableName = match[1];
    let requireExpression = match[3];

    // if referencing another require var, inline it
    requireExpression = requireExpression.replace(/\w+_WEBPACK_[A-Z]+_MODULE_\w+/, s => requireVariables.get(s) || s);
    if (!checkSideEffectFree(sideEffectFree, requireExpression)) {
      continue;
    }
    requireVariables.set(variableName, requireExpression);
  }
  return requireVariables;
}
function processSource(originalSource, sideEffectFree, options) {
  let newSource = originalSource;
  const requireVariables = collectRequires(originalSource, sideEffectFree);
  if (requireVariables.size === 0) {
    return null;
  }
  let replaceModuleSource;
  const {
    useSourceMap,
    originalModuleSource,
    moduleId,
    webpack
  } = options;

  // 有 sourcemap 的情况下，需要替换原始的 source
  if (useSourceMap) {
    replaceModuleSource = new webpack.sources.ReplaceSource(originalModuleSource, moduleId);
  }

  // Replace variable names.
  for (const [variableName, requireExpression] of requireVariables.entries()) {
    const varDeclarationRegx = new RegExp(`var ${variableName}[^\\w]([^;]+);`);
    const referenceRegx = new RegExp(`([^\\w])${variableName}([^\\w])`, 'g');

    // strip top level var declarations
    const declarationlessOutput = newSource.replace(varDeclarationRegx, (m, p0) => `// (inlined) ${(p0.match(/"([^"]+)/) || [])[1]}`);
    if (replaceModuleSource) {
      const varDeclarationMatch = originalSource.match(varDeclarationRegx);
      let varDeclarationIndex = -1;
      let varDeclarationLength = 0;
      if (varDeclarationMatch) {
        varDeclarationIndex = varDeclarationMatch.index || -1;
        varDeclarationLength = varDeclarationMatch[0].length;
      }
      let referenceMatch;
      let isUsed = false;
      while ((referenceMatch = referenceRegx.exec(originalSource)) !== null) {
        const referenceIndex = referenceMatch.index;
        if (varDeclarationMatch && referenceIndex - (varDeclarationMatch.index || -1) === 3) {
          continue;
        }
        isUsed = true; // 说明引用到了
        const referenceLength = referenceMatch[0].length - 1;
        const replaceValue = `${referenceMatch[1]}(${requireExpression})${referenceMatch[2]}`;
        replaceModuleSource.replace(referenceIndex, referenceIndex + referenceLength, replaceValue);
      }

      // 只有在引用到的情况下才会替换变量声明
      if (isUsed && varDeclarationMatch) {
        const replaceValue = `// (inlined) ${(varDeclarationMatch[1].match(/"([^"]+)/) || [])[1]}`;
        replaceModuleSource.replace(varDeclarationIndex, varDeclarationIndex + varDeclarationLength - 1, replaceValue);
      }
    }

    // replace inline variable references with require expression
    const reflessOutput = declarationlessOutput.replace(referenceRegx, `$1(${requireExpression})$2`);
    if (reflessOutput !== declarationlessOutput) {
      // import var is being used somewhere, confirm replacements
      newSource = reflessOutput;
    }
  }

  // nothing has changed
  if (newSource === originalSource) {
    return null;
  }
  return {
    source: newSource,
    map: replaceModuleSource ? replaceModuleSource.map() : null
  };
}