"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InlineRequireWebpackPlugin = void 0;
var _processor = require("./processor");
const PLUGIN_NAME = 'InlineRequireWebpackPlugin';
class InlineRequireWebpackPlugin {
  sideEffectFree = new Map();
  constructor(options = {}) {
    this.options = {
      ...options
    };
  }
  collectSideEffects(compiler, compilation, modules) {
    for (const m of modules) {
      const id = compilation.chunkGraph ? compilation.chunkGraph.getModuleId(m) : m.id;
      if (id != null && !this.sideEffectFree.has(id) && 'libIdent' in m) {
        const ident = m.libIdent({
          context: compiler.options.context
        });
        if (ident == null) {
          continue;
        }

        // either the dependency has explicit sideEffect
        // or we assume only local js/ts modules being sideEffect free
        const factoryMeta = m.factoryMeta;
        const isFree = factoryMeta && factoryMeta.sideEffectFree != null ? factoryMeta.sideEffectFree : !ident.includes('node_modules') && /\.[jt]sx?$/.test(ident);
        this.sideEffectFree.set(String(id), isFree);
      }
    }
  }
  apply(compiler) {
    const webpack = compiler.webpack || require('webpack');
    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
      compilation.hooks.afterOptimizeModuleIds.tap(PLUGIN_NAME, this.collectSideEffects.bind(this, compiler, compilation));
      compilation.moduleTemplates.javascript.hooks.package.tap(PLUGIN_NAME, (moduleSource, module) => {
        const sourceMap = this.options.sourceMap !== false;
        const original = sourceMap && moduleSource.sourceAndMap ? moduleSource.sourceAndMap() : {
          source: moduleSource.source(),
          map: sourceMap && typeof moduleSource.map === 'function' ? moduleSource.map() : null
        };
        const processResult = (0, _processor.processSource)(original.source, this.sideEffectFree, {
          useSourceMap: !!original.map,
          originalModuleSource: moduleSource,
          moduleId: module.id,
          webpack
        });
        if (processResult === null) {
          return moduleSource;
        }
        const {
          source: newSource,
          map: newSourceMap
        } = processResult;
        return original.map ? new webpack.sources.SourceMapSource(newSource, module.id, newSourceMap || original.map, original.source, original.map) : new webpack.sources.RawSource(newSource);
      });
    });
  }
}
exports.InlineRequireWebpackPlugin = InlineRequireWebpackPlugin;