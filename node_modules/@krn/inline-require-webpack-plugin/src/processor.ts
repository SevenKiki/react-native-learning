import type { SideEffectFree } from './types';
import type webpackTypes from 'webpack';
import type { SourceAndMapResult } from 'webpack-sources';

const importPattern =
  /var (\w+_WEBPACK_[A-Z]+_MODULE_\w+) = ([/*#\w]*)(__webpack_require__[^;,]+);/g;

function checkSideEffectFree(sideEffectFree: SideEffectFree, requireExpression: string) {
  // check if module has sideEffects false
  const [, importedModule] =
    requireExpression.match(/["']([^"']+)["']/) ||
    requireExpression.match(/__webpack_require__\((\d+)\)/) ||
    [];
  return sideEffectFree.get(importedModule) || false;
}

function collectRequires(src: string, sideEffectFree: SideEffectFree) {
  // Collect require variables
  const requireVariables = new Map<string, string>();

  const matches = src.matchAll(importPattern);
  for (const match of matches) {
    const variableName = match[1];
    let requireExpression = match[3];

    // if referencing another require var, inline it
    requireExpression = requireExpression.replace(
      /\w+_WEBPACK_[A-Z]+_MODULE_\w+/,
      (s) => requireVariables.get(s) || s
    );

    if (!checkSideEffectFree(sideEffectFree, requireExpression)) {
      continue;
    }

    requireVariables.set(variableName, requireExpression);
  }
  return requireVariables;
}

type ProessedSource = null | SourceAndMapResult;
export function processSource(
  originalSource: string,
  sideEffectFree: SideEffectFree,
  options: {
    useSourceMap: boolean;
    originalModuleSource: webpackTypes.sources.Source;
    moduleId: string;
    webpack: typeof webpackTypes;
  }
): ProessedSource {
  let newSource = originalSource;
  const requireVariables = collectRequires(originalSource, sideEffectFree);

  if (requireVariables.size === 0) {
    return null;
  }

  let replaceModuleSource: webpackTypes.sources.ReplaceSource | undefined;

  const { useSourceMap, originalModuleSource, moduleId, webpack } = options;

  // 有 sourcemap 的情况下，需要替换原始的 source
  if (useSourceMap) {
    replaceModuleSource = new webpack.sources.ReplaceSource(originalModuleSource, moduleId);
  }

  // Replace variable names.
  for (const [variableName, requireExpression] of requireVariables.entries()) {
    const varDeclarationRegx = new RegExp(`var ${variableName}[^\\w]([^;]+);`);
    const referenceRegx = new RegExp(`([^\\w])${variableName}([^\\w])`, 'g');

    // strip top level var declarations
    const declarationlessOutput = newSource.replace(
      varDeclarationRegx,
      (m, p0) => `// (inlined) ${(p0.match(/"([^"]+)/) || [])[1]}`
    );

    if (replaceModuleSource) {
      const varDeclarationMatch = originalSource.match(varDeclarationRegx);
      let varDeclarationIndex = -1;
      let varDeclarationLength = 0;
      if (varDeclarationMatch) {
        varDeclarationIndex = varDeclarationMatch.index || -1;
        varDeclarationLength = varDeclarationMatch[0].length;
      }
      let referenceMatch;
      let isUsed = false;
      while ((referenceMatch = referenceRegx.exec(originalSource)) !== null) {
        const referenceIndex = referenceMatch.index;
        if (varDeclarationMatch && referenceIndex - (varDeclarationMatch.index || -1) === 3) {
          continue;
        }
        isUsed = true; // 说明引用到了
        const referenceLength = referenceMatch[0].length - 1;
        const replaceValue = `${referenceMatch[1]}(${requireExpression})${referenceMatch[2]}`;
        replaceModuleSource.replace(referenceIndex, referenceIndex + referenceLength, replaceValue);
      }

      // 只有在引用到的情况下才会替换变量声明
      if (isUsed && varDeclarationMatch) {
        const replaceValue = `// (inlined) ${(varDeclarationMatch[1].match(/"([^"]+)/) || [])[1]}`;
        replaceModuleSource.replace(
          varDeclarationIndex,
          varDeclarationIndex + varDeclarationLength - 1,
          replaceValue
        );
      }
    }

    // replace inline variable references with require expression
    const reflessOutput = declarationlessOutput.replace(
      referenceRegx,
      `$1(${requireExpression})$2`
    );

    if (reflessOutput !== declarationlessOutput) {
      // import var is being used somewhere, confirm replacements
      newSource = reflessOutput;
    }
  }

  // nothing has changed
  if (newSource === originalSource) {
    return null;
  }

  return {
    source: newSource,
    map: replaceModuleSource ? replaceModuleSource.map() : null,
  };
}
