import type webpackTypes from 'webpack';
import { processSource } from './processor';
import type { SideEffectFree } from './types';

const PLUGIN_NAME = 'InlineRequireWebpackPlugin';

export interface InlineRequireWebpackPluginOptions {
  sourceMap?: boolean;
  cache?: boolean;
}

class InlineRequireWebpackPlugin {
  private readonly options: InlineRequireWebpackPluginOptions;

  private readonly sideEffectFree: SideEffectFree = new Map();

  constructor(options: Partial<InlineRequireWebpackPluginOptions> = {}) {
    this.options = { ...options };
  }

  collectSideEffects(
    compiler: webpackTypes.Compiler,
    compilation: webpackTypes.Compilation,
    modules: Iterable<webpackTypes.Module>
  ) {
    for (const m of modules) {
      const id = compilation.chunkGraph ? compilation.chunkGraph.getModuleId(m) : m.id;
      if (id != null && !this.sideEffectFree.has(id) && 'libIdent' in m) {
        const ident: string | null = m.libIdent({
          context: compiler.options.context as string,
        });

        if (ident == null) {
          continue;
        }

        // either the dependency has explicit sideEffect
        // or we assume only local js/ts modules being sideEffect free
        const factoryMeta = m.factoryMeta as undefined | { sideEffectFree: boolean };
        const isFree =
          factoryMeta && factoryMeta.sideEffectFree != null
            ? factoryMeta.sideEffectFree
            : !ident.includes('node_modules') && /\.[jt]sx?$/.test(ident);

        this.sideEffectFree.set(String(id), isFree);
      }
    }
  }

  apply(compiler: webpackTypes.Compiler) {
    const webpack = compiler.webpack || require('webpack');
    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
      compilation.hooks.afterOptimizeModuleIds.tap(
        PLUGIN_NAME,
        this.collectSideEffects.bind(this, compiler, compilation)
      );

      compilation.moduleTemplates.javascript.hooks.package.tap(
        PLUGIN_NAME,
        (moduleSource: webpackTypes.sources.SourceMapSource, module: webpackTypes.Module) => {
          const sourceMap = this.options.sourceMap !== false;
          const original =
            sourceMap && moduleSource.sourceAndMap
              ? moduleSource.sourceAndMap()
              : {
                  source: moduleSource.source() as string,
                  map:
                    sourceMap && typeof moduleSource.map === 'function' ? moduleSource.map() : null,
                };
          const processResult = processSource(original.source as string, this.sideEffectFree, {
            useSourceMap: !!original.map,
            originalModuleSource: moduleSource,
            moduleId: module.id as string,
            webpack,
          });
          if (processResult === null) {
            return moduleSource;
          }
          const { source: newSource, map: newSourceMap } = processResult;
          return original.map
            ? new webpack.sources.SourceMapSource(
                newSource,
                module.id as string,
                newSourceMap || original.map,
                original.source,
                original.map
              )
            : new webpack.sources.RawSource(newSource);
        }
      );
    });
  }
}

export { InlineRequireWebpackPlugin };
