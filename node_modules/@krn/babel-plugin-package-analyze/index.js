const path = require('path');
const { weblog } = require('@krn/cli-shared');

const packageMatches = [
    {
        test: /^@kds/,
    },
    {
        test: /^@react-/,
    },
    {
        test: /^@krn/,
    },
    {
        test: /^react-(?!native).*/,
    },
    {
        test: /^react-native-/,
    },
    {
        packageName: '@kid-ui/krn',
    },
    {
        packageName: '@kwaishop/kwaishop-component',
    },
    {
        packageName: '@es/kprom-data-radar',
    },
    {
        packageName: '@es/kprom-rate-satisfaction-score',
    },
    {
        packageName: '@es/kprom-common-sticky',
    },
    {
        packageName: '@es/kprom-common-logistics-trace',
    },
    {
        packageName: '@mfe/krn-produce-components',
    },
];

module.exports = function () {
    return {
        name: 'package-analyze',
        pre() {
            this.importedPackages = new Map();
            this.filename = '';
        },
        visitor: {
            Program(programePath, state) {
                const filename = state.file.opts.filename;

                // 暂时不统计 node_modules 下的文件
                if (filename.indexOf('node_modules') !== -1) {
                    return;
                }

                this.filename = filename;

                const packages =
                    filename.match(
                        /.*node_modules\/(@[^\/]+\/[^\/]+|[^\/]+)/,
                    ) || [];
                const parentPackage = packages[1];
                let parentPackageVersion = '-';
                if (parentPackage) {
                    try {
                        parentPackageVersion = require(`${packages[0]}/package.json`)
                            .version;
                    } catch (err) {
                        console.log('查找父级版本号失败', err);
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const self = this;
                //通用
                state.hasRecordedPath = new Set();
                state.importedNames = new Map();
                state.refs = [];
                try {
                    programePath.traverse({
                        ImportDeclaration(outerPath) {
                            if (state.hasRecordedPath.has(outerPath)) {
                                return;
                            }
                            state.hasRecordedPath.add(outerPath);

                            const source = outerPath.get('source').node.value;

                            if (
                                source.startsWith('.') ||
                                source.startsWith('..')
                            ) {
                                return;
                            }

                            const packageName = (source.match(
                                /@[^\/]+\/[^\/]+|[^\/]+/,
                            ) || [])[0];

                            if (!packageName) {
                                return;
                            }

                            if (
                                !packageMatches.some((match) => {
                                    if (match.test) {
                                        return match.test.test(packageName);
                                    }
                                    return match.packageName === packageName;
                                })
                            ) {
                                return;
                            }

                            let packageVersion = '';

                            try {
                                packageVersion = require.resolve(
                                    `${packageName}/package.json`,
                                    {
                                        paths: [path.dirname(filename)],
                                    },
                                );
                            } catch (err) {
                                console.log(
                                    `'查找当前模块: ${packageName} 版本号失败'`,
                                    err,
                                );
                            }

                            const isExist = self.importedPackages.has(
                                packageName,
                            );

                            if (!isExist) {
                                self.importedPackages.set(packageName, {
                                    imported: new Map(),
                                    references: {},
                                    calls: new Set(),
                                    parent: parentPackage || '-',
                                    parentVersion: parentPackageVersion,
                                    version: packageVersion
                                        ? require(packageVersion).version
                                        : '-',
                                });
                            }
                            const packageInfo = self.importedPackages.get(
                                packageName,
                            );
                            outerPath.traverse({
                                ImportSpecifier(innerPath) {
                                    if (state.hasRecordedPath.has(innerPath)) {
                                        return;
                                    }
                                    state.hasRecordedPath.add(innerPath);

                                    const importedName = innerPath.get(
                                        'imported',
                                    ).node.name;
                                    let localName = importedName;
                                    if (
                                        innerPath.get('local') &&
                                        innerPath.get('local').node.name
                                    ) {
                                        localName = innerPath.get('local').node
                                            .name;
                                    }

                                    packageInfo.imported.set(
                                        localName,
                                        importedName,
                                    );
                                    state.importedNames.set(
                                        localName,
                                        packageName,
                                    );
                                },
                                ImportDefaultSpecifier(innerPath) {
                                    if (state.hasRecordedPath.has(innerPath)) {
                                        return;
                                    }
                                    state.hasRecordedPath.add(innerPath);

                                    const localName = innerPath.get('local')
                                        .node.name;

                                    packageInfo.imported.set(
                                        localName,
                                        'default',
                                    );
                                    state.importedNames.set(
                                        localName,
                                        packageName,
                                    );
                                },
                            });
                        },
                        JSXOpeningElement(outerPath) {
                            if (state.hasRecordedPath.has(outerPath)) {
                                return;
                            }
                            state.hasRecordedPath.add(outerPath);

                            if (!state.importedNames.size) {
                                return;
                            }

                            const component = outerPath.get('name').node.name;

                            if (!state.importedNames.has(component)) {
                                return;
                            }

                            const importedPackageName = state.importedNames.get(
                                component,
                            );

                            const packageInfo = self.importedPackages.get(
                                importedPackageName,
                            );

                            if (!packageInfo) {
                                return;
                            }

                            const importedName = packageInfo.imported.get(
                                component,
                            );

                            if (!importedName) {
                                return;
                            }

                            if (!packageInfo.references[importedName]) {
                                packageInfo.references[importedName] = {
                                    props: new Set(),
                                    methods: new Set(),
                                };
                            }

                            const referenceProps =
                                packageInfo.references[importedName].props;

                            if (outerPath.get('attributes').length === 0) {
                                return;
                            }

                            // 分析 JSX 的属性
                            outerPath.traverse({
                                JSXAttribute(innerPath) {
                                    if (state.hasRecordedPath.has(innerPath)) {
                                        return;
                                    }
                                    state.hasRecordedPath.add(innerPath);

                                    const attrName = innerPath.get('name').node
                                        .name;

                                    referenceProps.add(attrName);

                                    if (attrName === 'ref') {
                                        const attrValue =
                                            innerPath.get('value') &&
                                            innerPath.get('value.expression') &&
                                            innerPath.get(
                                                'value.expression.name',
                                            ) &&
                                            innerPath.get(
                                                'value.expression.name',
                                            ).node;

                                        if (attrValue) {
                                            const scopeId =
                                                innerPath.get(
                                                    'value.expression',
                                                ).scope &&
                                                innerPath.get(
                                                    'value.expression',
                                                ).scope.uid;
                                            state.refs.push({
                                                name: attrValue,
                                                importedName: component,
                                                scopeId,
                                            });
                                        }
                                    }
                                },
                            });
                            // 追踪 ref 的引用，目前只能追踪 函数式组件的 useRef 调用
                            programePath.traverse({
                                CallExpression(outerPath) {
                                    if (state.hasRecordedPath.has(outerPath)) {
                                        return;
                                    }

                                    if (!state.importedNames.size) {
                                        return;
                                    }

                                    const getCallChain = (node, paths = []) => {
                                        if (node.type === 'MemberExpression') {
                                            paths.unshift(node.property.name);
                                            return getCallChain(
                                                node.object,
                                                paths,
                                            );
                                        }
                                        if (node.type === 'Identifier') {
                                            paths.unshift(node.name);
                                            return paths;
                                        }
                                        return paths;
                                    };

                                    const callPaths = getCallChain(
                                        outerPath.get('callee').node,
                                    );

                                    const getScopeChain = (
                                        scope,
                                        scopes = [],
                                    ) => {
                                        if (scope) {
                                            scopes.unshift(scope.uid);
                                            return getScopeChain(
                                                scope.parent,
                                                scopes,
                                            );
                                        }
                                        return scopes;
                                    };

                                    const callName = callPaths[0];

                                    const scopeChain = getScopeChain(
                                        outerPath.get('callee').scope,
                                    );

                                    const importedRef = state.refs.find(
                                        ({ name, scopeId }) => {
                                            return (
                                                name === callName &&
                                                scopeChain.indexOf(scopeId) !==
                                                    -1
                                            );
                                        },
                                    );

                                    if (!importedRef) {
                                        return;
                                    }

                                    state.hasRecordedPath.add(outerPath);

                                    if (!importedRef) {
                                        return;
                                    }
                                    const localName = importedRef.importedName;
                                    const importedPackageName = state.importedNames.get(
                                        localName,
                                    );
                                    const packageInfo = self.importedPackages.get(
                                        importedPackageName,
                                    );
                                    if (packageInfo) {
                                        const importedName = packageInfo.imported.get(
                                            localName,
                                        );
                                        if (
                                            !packageInfo.references[
                                                importedName
                                            ]
                                        ) {
                                            packageInfo.references[
                                                importedName
                                            ] = {
                                                props: new Set(),
                                                methods: new Set(),
                                            };
                                        }
                                        const referenceMethods =
                                            packageInfo.references[importedName]
                                                .methods;
                                        referenceMethods.add(
                                            callPaths.slice(2).join('.'),
                                        );
                                    }
                                },
                            });
                        },
                        CallExpression(outerPath) {
                            // 分析导入的函数调用
                            if (state.hasRecordedPath.has(outerPath)) {
                                return;
                            }

                            if (!state.importedNames.size) {
                                return;
                            }

                            // 获取调用函数链，例如 a.b.c()
                            const getCallChain = (node, paths = []) => {
                                if (node.type === 'MemberExpression') {
                                    paths.unshift(node.property.name);
                                    return getCallChain(node.object, paths);
                                }
                                if (node.type === 'Identifier') {
                                    paths.unshift(node.name);
                                    return paths;
                                }
                                return paths;
                            };

                            const callPaths = getCallChain(
                                outerPath.get('callee').node,
                            );

                            const callName = callPaths[0];

                            if (!state.importedNames.has(callName)) {
                                return;
                            }

                            state.hasRecordedPath.add(outerPath);

                            if (state.importedNames.has(callName)) {
                                const importedPackageName = state.importedNames.get(
                                    callName,
                                );
                                const packageInfo = self.importedPackages.get(
                                    importedPackageName,
                                );
                                const importedName = packageInfo.imported.get(
                                    callName,
                                );
                                if (packageInfo) {
                                    packageInfo.calls.add(
                                        [
                                            importedName,
                                            ...callPaths.slice(1),
                                        ].join('.'),
                                    );
                                }
                                return;
                            }
                        },
                    });
                } catch (err) {
                    console.log('分析 npm 包用法失败', err);
                }
            },
        },
        post() {
            try {
                const {
                    bundleId,
                    version: versionCode,
                    platform,
                    ['use-webpack']: useWebpack,
                } = this.opts;
                const filePath = path.relative(
                    process.cwd(),
                    this.filename || '.',
                );
                if (this.importedPackages.size) {
                    const packages = [];
                    this.importedPackages.forEach((packageInfo, name) => {
                        let existPackage = packages.find(
                            ({
                                packageName: currentPackageName,
                                version: currentVersion,
                                parent: currentParent,
                                parentVersion: currentParentVersion,
                            }) => {
                                return (
                                    currentPackageName === name &&
                                    currentVersion === packageInfo.version &&
                                    currentParent === packageInfo.parent &&
                                    currentParentVersion ===
                                        packageInfo.parentVersion
                                );
                            },
                        );
                        if (!existPackage) {
                            existPackage = {
                                packageName: name,
                                components: [],
                                methods: [],
                                version: packageInfo.version,
                                parent: packageInfo.parent,
                                parentVersion: packageInfo.parentVersion,
                            };
                            packages.push(existPackage);
                        }
                        existPackage.methods = [
                            ...new Set([
                                ...existPackage.methods,
                                ...packageInfo.calls,
                            ]),
                        ];
                        Object.keys(packageInfo.references).forEach(
                            (componentName) => {
                                const currentComponent =
                                    packageInfo.references[componentName];
                                let component = existPackage.components.find(
                                    ({
                                        componentName: currentComponentName,
                                    }) => {
                                        return (
                                            currentComponentName ===
                                            componentName
                                        );
                                    },
                                );
                                if (!component) {
                                    component = {
                                        componentName,
                                        props: [],
                                        methods: [],
                                    };
                                    existPackage.components.push(component);
                                }
                                component.props = [
                                    ...new Set([
                                        ...component.props,
                                        ...currentComponent.props,
                                    ]),
                                ];
                                component.methods = [
                                    ...new Set([
                                        ...component.methods,
                                        ...currentComponent.methods,
                                    ]),
                                ];
                            },
                        );
                    });
                    // 暂时先直接上报当前文件的信息，后续可以考虑上报整个项目的信息
                    const reportInfos = [];
                    packages.forEach((item) => {
                        const {
                            components,
                            methods,
                            ...otherPackageInfo
                        } = item;
                        const reportInfo = {
                            bundleId,
                            versionCode,
                            platform,
                            useWebpack,
                            filePath,
                            ...otherPackageInfo,
                        };
                        if (components.length) {
                            components.forEach((component) => {
                                const {
                                    componentName,
                                    props,
                                    methods,
                                } = component;
                                props.forEach((prop) => {
                                    reportInfos.push({
                                        ...reportInfo,
                                        type: 'component',
                                        componentName,
                                        prop,
                                    });
                                });
                                methods.forEach((method) => {
                                    reportInfos.push({
                                        ...reportInfo,
                                        type: 'component',
                                        componentName,
                                        method,
                                    });
                                });
                                if (!props.length && !methods.length) {
                                    reportInfos.push({
                                        ...reportInfo,
                                        type: 'component',
                                        componentName,
                                        prop: '-',
                                    });
                                }
                            });
                        }
                        if (methods.length) {
                            methods.forEach((method) => {
                                reportInfos.push({
                                    ...reportInfo,
                                    type: 'method',
                                    method,
                                });
                            });
                        }
                    });

                    if (!reportInfos.length) {
                        return;
                    }

                    // 上报 npm 依赖使用分析信息，用于 QA 的精准测试时使用
                    reportInfos.forEach(({ bundleId, ...otherInfo }) => {
                        weblog.sendImmediately('CLICK', {
                            action: `KEEP_NPM_PACKAGE_USAGE_ANALYSIS`,
                            params: {
                                page: bundleId,
                                ...otherInfo,
                            },
                        });
                    });
                }
            } catch (err) {
                console.log('上报 npm 包用法失败', err);
            }
        },
    };
};
