const subscriptions = {};
const getNextUniqueId = getIdGenerator();
function getIdGenerator() {
    let lastId = Date.now();
    return function getNextUniqueId() {
        lastId += 1;
        return lastId;
    };
}
global.__NATIVE_MODULES_PROXY__ = {
    on: (eventType, callback) => {
        const id = getNextUniqueId();
        if (!subscriptions[eventType]) {
            subscriptions[eventType] = {};
        }
        subscriptions[eventType][id] = callback;
        return {
            unsubscribe: () => {
                delete subscriptions[eventType][id];
                if (Object.keys(subscriptions[eventType]).length === 0) {
                    delete subscriptions[eventType];
                }
            },
        };
    },
    emit: (eventType, arg) => {
        if (subscriptions[eventType]) {
            Object.keys(subscriptions[eventType]).forEach((id) => {
                return subscriptions[eventType][id](arg);
            });
        }
    },
};
function isObj(target) {
    return Object.prototype.toString.call(target) === '[object Object]';
}
function isFunction(target) {
    return Object.prototype.toString.call(target) === '[object Function]';
}
function function2String(fn) {
    return `[Function ${fn.name || 'anonymous'}]`;
}
function Hook(modulePaths, callback) {
    const originalDefine = global.__d;
    global.__d = function overrideDefine(factory, ...args) {
        const modulePath = args[2];
        modulePaths
            .filter((path) => modulePath.includes(path))
            .forEach(function (path) {
                const originalFactory = factory;
                factory = function overrideFactory(...factoryArgs) {
                    const moduleObject = factoryArgs[4];
                    factoryArgs[4] = new Proxy(moduleObject, {
                        set: function (target, prop, moduleImpl) {
                            if (prop === 'exports') {
                                target[prop] = callback(
                                    path,
                                    moduleObject,
                                    moduleImpl,
                                );
                            }
                            return true;
                        },
                    });
                    return originalFactory.call(
                        originalFactory,
                        ...factoryArgs,
                    );
                };
            });
        return originalDefine.call(originalDefine, factory, ...args);
    };
}
const moduleMap = {
    NativeModules: '/Libraries/BatchedBridge/NativeModules.js',
    NativeEventEmitter: '/Libraries/EventEmitter/NativeEventEmitter.js',
};
const emitCallback = function (callbackId, bridgeType, res, error) {
    global.__NATIVE_MODULES_PROXY__.emit('callback', {
        id: callbackId,
        params: res,
        bridgeType,
        timestamp: Date.now(),
        error,
    });
};
const emitInvoke = function (
    callbackId,
    bridgeType,
    namespace,
    methodName,
    params,
    multiParams,
) {
    global.__NATIVE_MODULES_PROXY__.emit('invoke', {
        id: callbackId,
        bridgeType,
        namespace,
        methodName,
        params,
        multiParams,
        timestamp: Date.now(),
    });
};
Hook(
    Object.values(moduleMap),
    function callback(modulePath, moduleObject, moduleImpl) {
        // 拦截NativeEventEmitter
        if (moduleMap.NativeEventEmitter === modulePath) {
            const originalAddListener = moduleImpl.prototype.addListener;
            const blackList = [
                'websocketMessage',
                'websocketOpen',
                'websocketClosed',
                'websocketFailed',
            ];
            moduleImpl.prototype.addListener = function (
                eventType,
                listener,
                context,
            ) {
                if (blackList.includes(eventType)) {
                    return originalAddListener.call(
                        this,
                        eventType,
                        listener,
                        context,
                    );
                }
                const callbackId = getNextUniqueId();
                emitInvoke(
                    callbackId,
                    'Callback',
                    'eventEmitter',
                    'addListener',
                    { eventType },
                    false,
                );
                return originalAddListener.call(
                    this,
                    eventType,
                    function (...args) {
                        emitCallback(callbackId, 'Callback', args);
                        return listener.call(listener, ...args);
                    },
                    context,
                );
            };
            return moduleImpl;
        }
        // 拦截NativeModules
        if (moduleMap.NativeModules === modulePath) {
            const blackList = [
                'WebSocketModule',
                'Timing',
                'UIManager',
                'SourceCode',
                'DevSettings',
            ];
            function proxy(target, lastProp) {
                return new Proxy(target, {
                    get: function (obj, prop) {
                        let nmsModule = obj[prop];
                        if (isObj(nmsModule) && !blackList.includes(prop)) {
                            return proxy(nmsModule, prop);
                        }
                        if (isFunction(nmsModule)) {
                            const originFunc = nmsModule;
                            nmsModule = function (...args) {
                                const callbackId = getNextUniqueId();
                                const isMultipleParams = args.length > 1;
                                const requestParams = !isMultipleParams
                                    ? args[0]
                                    : args.map((arg) => {
                                          if (isFunction(arg)) {
                                              return function2String(arg);
                                          }
                                          return arg;
                                      });
                                const hasCallback = args.some((a) =>
                                    isFunction(a),
                                );
                                // promise规范的bridge接口
                                // @see /react-native/Libraries/BatchedBridge/NativeModules.js#L149
                                const isPromise = originFunc.type === 'promise';
                                let bridgeType = '';
                                if (isPromise) {
                                    bridgeType = 'Promise';
                                } else if (hasCallback) {
                                    bridgeType = 'Callback';
                                } else {
                                    bridgeType = 'Sync';
                                }
                                // 上报bridge调用
                                emitInvoke(
                                    callbackId,
                                    bridgeType,
                                    lastProp,
                                    prop,
                                    requestParams,
                                    isMultipleParams,
                                );
                                if (isPromise) {
                                    return originFunc
                                        .call(originFunc, ...args)
                                        .then((res) => {
                                            emitCallback(
                                                callbackId,
                                                bridgeType,
                                                res,
                                            );
                                            return Promise.resolve(res);
                                        })
                                        .catch((err) => {
                                            emitCallback(
                                                callbackId,
                                                bridgeType,
                                                null,
                                                err,
                                            );
                                            return Promise.reject(err);
                                        });
                                }
                                // 一般的bridge接口
                                else {
                                    // 带有callback的bridge调用
                                    if (hasCallback) {
                                        args.forEach((arg, index) => {
                                            if (isFunction(arg)) {
                                                const originalCallback =
                                                    args[index];
                                                args[index] = function (
                                                    ...callbackArgs
                                                ) {
                                                    emitCallback(
                                                        callbackId,
                                                        bridgeType,
                                                        callbackArgs,
                                                    );
                                                    return originalCallback.call(
                                                        originalCallback,
                                                        ...callbackArgs,
                                                    );
                                                };
                                            }
                                            return arg;
                                        });
                                    }
                                    try {
                                        const res = originFunc.call(
                                            originFunc,
                                            ...args,
                                        );
                                        if (!hasCallback) {
                                            emitCallback(
                                                callbackId,
                                                bridgeType,
                                                res,
                                            );
                                        }
                                        return res;
                                    } catch (err) {
                                        emitCallback(
                                            callbackId,
                                            bridgeType,
                                            null,
                                            err,
                                        );
                                    }
                                }
                            };
                        }
                        return nmsModule;
                    },
                });
            }
            return proxy(moduleImpl);
        }
    },
);
