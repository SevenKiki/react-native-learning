"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const child_process_1 = require("child_process");
const command_1 = require("@oclif/command");
const inquirer = require("inquirer");
const fs = require("fs-extra");
const md5 = require("md5");
const utils_1 = require("../utils");
const bundle_stats_1 = require("../utils/bundle-stats");
const chalk = require("chalk");
const patch_1 = require("../patch");
const lodash_1 = require("lodash");
const command_2 = require("./command");
const cli_shared_1 = require("@krn/cli-shared");
const bundle_cipher_1 = require("@kds/bundle-cipher");
const compat_grammar_check_1 = require("@kds/compat-grammar-check");
const binUp = require('bin-up');
const qrcode = require('qrcode-terminal');
var BUILD_PLATFORM;
(function (BUILD_PLATFORM) {
    BUILD_PLATFORM["IOS"] = "ios";
    BUILD_PLATFORM["ANDROID"] = "android";
})(BUILD_PLATFORM || (BUILD_PLATFORM = {}));
const RNCliFlags = {
    platform: command_1.flags.string({
        char: 'p',
        helpValue: 'ios',
        description: 'ÊâìÂåÖÂπ≥Âè∞',
        default: '',
        required: true,
    }),
    dev: command_1.flags.string({
        char: 'd',
        helpValue: 'true',
        description: 'ÊâìDEBUGÂåÖ',
        default: 'false',
    }),
    minify: command_1.flags.string({
        helpValue: 'true',
        description: 'ÊòØÂê¶ÂéãÁº©bundle',
        default: 'true',
    }),
    config: command_1.flags.string({
        helpValue: './metro.config.js',
        description: 'metroÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑ',
        default: '',
    }),
    'reset-cache': command_1.flags.boolean({
        char: 'r',
        description: 'ÊòØÂê¶Ê∏ÖÈô§ÊâìÂåÖÁºìÂ≠ò',
        default: false,
    }),
    verbose: command_1.flags.boolean({
        description: 'ÊòØÂê¶ËæìÂá∫ÊâìÂåÖÊó•Âøó',
        default: false,
    }),
    'use-webpack': command_1.flags.boolean({
        description: '‰ΩøÁî®webpackÊûÑÂª∫',
        default: false,
    }),
    deploy: command_1.flags.boolean({
        description: 'Êú¨Âú∞ÈÉ®ÁΩ≤È¢ÑËßàÔºåÂè™ËÉΩÁî®‰∫éÊú¨Âú∞ÊµãËØï‰ΩøÁî®',
        default: false,
    }),
    'deploy-scheme': command_1.flags.string({
        description: 'ÈÉ®ÁΩ≤ÂêéÔºåÊâ´Á†Å‰∏ãËΩΩÁöÑËá™ÂÆö‰πâË∑≥ËΩ¨ÂèÇÊï∞ÔºåÁ±ª‰ºº Keep ÊâìÂåÖÊó∂ÁöÑÂèÇÊï∞ÔºåÈªòËÆ§ÂÄº‰∏∫ kwai://krn?bundleId=$BUNDLE_ID&componentName=ÔºåÂÖ∂‰∏≠ $BUNDLE_ID ‰ºöÂú®ÁîüÊàê‰∫åÁª¥Á†ÅÁöÑÊó∂ÂÄôËá™Âä®ÊõøÊç¢‰∏∫ÂÆûÈôÖÁöÑ bundleId',
        default: '',
    }),
    'accurate-test-istanbul': command_1.flags.boolean({
        description: 'Á≤æÂáÜÊµãËØï‰ª£Á†ÅÊèíÊ°©',
        default: false,
    }),
    'auto-test-id': command_1.flags.boolean({
        description: 'Ëá™Âä®ÊèíÂÖ• testID',
        default: false,
    }),
};
const handleCLIVersion = () => {
    const packageJson = fs.readJSONSync('./package.json');
    packageJson.resolutions = packageJson.resolutions || {};
    packageJson.resolutions['@react-native-community/cli'] = '4.13.1';
    packageJson.resolutions['react-native'] = '0.62.2';
    fs.writeJsonSync('./package.json', packageJson, {
        spaces: '  ',
    });
    (0, child_process_1.execSync)('yarn');
};
const handleAccurateTestIstanbul = () => {
    const packageJson = fs.readJSONSync('./package.json');
    packageJson.devDependencies = packageJson.devDependencies || {};
    packageJson.devDependencies['@kds/babel-plugin-istanbul'] = '^6.1.2';
    fs.writeJsonSync('./package.json', packageJson, {
        spaces: '  ',
    });
    (0, child_process_1.execSync)('yarn');
};
const handleCIDiagnose = async () => {
    await (0, utils_1.diagnose)(true);
};
class Build extends command_2.default {
    getFlags() {
        const { flags } = this.parse(Build);
        return flags;
    }
    async selectPlatform() {
        const flags = this.getFlags();
        if (flags.platform) {
            return flags.platform;
        }
        const responses = await inquirer.prompt({
            name: 'platform',
            message: 'ËØ∑ÈÄâÊã©ÊâìÂåÖÂπ≥Âè∞',
            type: 'list',
            choices: [
                { name: BUILD_PLATFORM.IOS },
                { name: BUILD_PLATFORM.ANDROID },
            ],
        });
        return responses.platform;
    }
    async inputVersion() {
        const flags = this.getFlags();
        // ÁâàÊú¨ÂøÖÈ°ª > 0
        if ((0, lodash_1.isNumber)(flags.version) && flags.version > 0) {
            return flags.version;
        }
        const responses = await inquirer.prompt({
            name: 'version',
            message: 'ËØ∑ËæìÂÖ•ÁâàÊú¨Âè∑',
            type: 'input',
            validate: (value) => {
                if (/\d+/.test(value)) {
                    return true;
                }
                return 'ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑÁâàÊú¨Âè∑';
            },
        });
        return responses.version;
    }
    async inputBundleId() {
        const flags = this.getFlags();
        if (flags.bundleId) {
            return flags.bundleId;
        }
        const krnConfig = this.getKrnConfig();
        if ((0, lodash_1.isPlainObject)(krnConfig.entry)) {
            const choices = Object.keys(krnConfig.entry).map((key) => {
                return {
                    name: key,
                };
            });
            const responses = await inquirer.prompt({
                name: 'bundleId',
                message: 'ËØ∑ÈÄâÊã©BundleId',
                type: 'list',
                choices,
            });
            return responses.bundleId;
        }
        const responses = await inquirer.prompt({
            name: 'bundleId',
            message: 'ËØ∑ËæìÂÖ•BundleId',
            type: 'input',
        });
        return responses.bundleId;
    }
    getKrnConfig() {
        const krnConfigPath = path.resolve('./krn.config.json');
        return fs.existsSync(krnConfigPath)
            ? fs.readJSONSync(krnConfigPath)
            : {};
    }
    async getRegisterComponentNames(entry) {
        if (entry && fs.existsSync(entry)) {
            const entryFile = fs.readFileSync(entry).toString();
            const registerComponents = entryFile.match(/(?<=AppRegistry\.registerComponent\((\n|\r|\s)*?('|")).*?(?=('|"))/g) || [];
            return registerComponents;
        }
        return [];
    }
    async getEntryFilePath(entry, bundleId) {
        let entryFilePath;
        if (!entry) {
            // Ê≤°ÊúâentryËµ∞Ëá™Âä®ÂåπÈÖç
            const entryFilePaths = ['./index.ts', './index.js'].filter(fs.existsSync);
            entryFilePath = entryFilePaths[0] || entryFilePaths[1];
            if (entryFilePath) {
                utils_1.Logger.warn(`Warning: Êâæ‰∏çÂà∞ entry, Â∑≤Ëá™Âä®ÂåπÈÖç \`${entryFilePath}\` Êñá‰ª∂`);
                return entryFilePath;
            }
        }
        else if ((0, lodash_1.isString)(entry)) {
            entryFilePath = entry;
        }
        else if ((0, lodash_1.isPlainObject)(entry)) {
            // Â§öÂÖ•Âè£ÁöÑÊÉÖÂÜµ
            entryFilePath = entry[bundleId];
        }
        if (entryFilePath && fs.existsSync(entryFilePath)) {
            return entryFilePath;
        }
        else {
            throw new Error('entry Êñá‰ª∂‰∏çÂ≠òÂú®');
        }
    }
    async ensureBusinessParams() {
        // ÂèÇÊï∞ËæìÂÖ•
        const platform = await this.selectPlatform();
        const version = await this.inputVersion();
        const bundleId = await this.inputBundleId();
        const krnConfig = this.getKrnConfig();
        const entry = await this.getEntryFilePath(krnConfig.entry, bundleId);
        const workspaceContext = krnConfig.workspace;
        const productsPath = path.resolve('./products', platform, bundleId, version.toString());
        // ‰∏¥Êó∂ÁöÑÊâìÂåÖÁõÆÂΩï
        const outputDirPath = path.resolve(productsPath, './output');
        const tmpDirPath = path.resolve(productsPath, './tmp');
        const bundleDirPath = path.resolve(productsPath, './bundle');
        const internalPath = path.resolve(bundleDirPath, './internal');
        const webpackAssetsDirPath = path.resolve(bundleDirPath, './webpack-assets');
        // ÊâìÂåÖ‰∫ßÁâ©
        const bundleFilePath = `${bundleDirPath}/index.${platform}.bundle`;
        const staticImgPath = path.resolve(utils_1.rootDir, './assets/assets_player_like_active.png');
        const sourceMapFilename = `${platform}_${bundleId}_${version}.sourcemap.js.map`;
        const sourcemapPath = `${bundleDirPath}/${sourceMapFilename}`;
        const imgFilePath = `${tmpDirPath}/a.png`;
        const componentNamesJsonFilePath = `${bundleDirPath}/component-names.json`;
        const accurateTestDataFilePath = `${bundleDirPath}/accurate-test-result.json`;
        const accurateTestCsvDataFilePath = `${bundleDirPath}/accurate-test-result.csv`;
        const bachedBridgeRegisterCheckFilePath = `${tmpDirPath}/batch-bridge-register-check-result.json`;
        (0, utils_1.rmAndMkdir)(outputDirPath);
        (0, utils_1.rmAndMkdir)(tmpDirPath);
        (0, utils_1.rmAndMkdir)(bundleDirPath);
        (0, utils_1.rmAndMkdir)(internalPath);
        (0, utils_1.rmAndMkdir)(webpackAssetsDirPath);
        fs.copyFileSync(staticImgPath, imgFilePath);
        return {
            version,
            platform,
            bundleId,
            entry,
            outputDirPath,
            tmpDirPath,
            bundleDirPath,
            bundleFilePath,
            internalPath,
            webpackAssetsDirPath,
            sourceMapFilename,
            sourcemapPath,
            componentNamesJsonFilePath,
            accurateTestDataFilePath,
            accurateTestCsvDataFilePath,
            bachedBridgeRegisterCheckFilePath,
            workspaceContext,
        };
    }
    async buildBusinessBundle({ platform, bundleId, version, entry, outputDirPath, bundleDirPath, bundleFilePath, webpackAssetsDirPath, sourceMapFilename, sourcemapPath, workspaceContext, }) {
        const flags = this.getFlags();
        utils_1.Logger.log('üöÄüöÄüöÄÂºÄÂßãÊâìÂπ≥Âè∞‰∏∫', chalk.bold(platform), ', bundleId‰∏∫', chalk.bold(bundleId), ', ÁâàÊú¨Âè∑‰∏∫', chalk.bold(version.toString()), ', dev‰∏∫', chalk.bold(flags.dev), 'ÁöÑÂåÖ...');
        utils_1.Logger.log(`ÊâìÂåÖÁöÑÊñá‰ª∂ÂÖ•Âè£:`, entry);
        // ÂºÄÂßãÊâìÂåÖ
        utils_1.Logger.loading('Ê≠£Âú®ÊâìÂåÖ‰∏≠');
        const logPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.txt`;
        const entryPath = path.resolve(entry);
        const originalFileContent = fs.readFileSync(entryPath, 'utf-8');
        try {
            const reactNativeCliPath = (0, utils_1.getReactNativeCLI)();
            const projectRoot = process.cwd();
            if (!fs.existsSync(reactNativeCliPath)) {
                return Promise.reject(new Error('ËØ∑Á°ÆËÆ§Â∑≤ÂÆâË£Ö‰æùËµñ'));
            }
            if ((0, cli_shared_1.isCIEnvironment)()) {
                await handleCIDiagnose();
                handleCLIVersion();
            }
            if (this.isAccurateTest()) {
                handleAccurateTestIstanbul();
                const insertContent = `import '@kds/accurate-test/runtime';`;
                if (originalFileContent.indexOf(insertContent) === -1) {
                    const originalContent = originalFileContent.split(/\r\n|\r|\n/gm);
                    originalContent.unshift(insertContent);
                    fs.writeFileSync(entryPath, originalContent.join('\n'));
                }
            }
            const minify = flags.dev === 'true' ? 'false' : flags.minify;
            const useWebpack = !!flags['use-webpack'];
            const cliArgs = [];
            let configPath = '';
            if (useWebpack) {
                const webpackCLI = (0, utils_1.getWebpackCLI)();
                configPath =
                    flags.config || path.resolve('./webpack.config.js');
                cliArgs.push(...[
                    webpackCLI,
                    'build',
                    '--entry',
                    path.resolve(projectRoot, entry),
                    '--config',
                    path.resolve(__dirname, '../webpack-config/base.config.js'),
                    '--env',
                    `platform=${platform}`,
                ]);
            }
            else {
                configPath = flags.config || path.resolve('./metro.config.js');
                cliArgs.push(...[
                    reactNativeCliPath,
                    'bundle',
                    '--platform',
                    platform,
                    '--entry-file',
                    entry,
                    '--assets-dest',
                    outputDirPath,
                    '--config',
                    require.resolve('@krn/metro-config'),
                    '--sourcemap-output',
                    sourcemapPath,
                    '--bundle-output',
                    bundleFilePath,
                    '--dev',
                    flags.dev,
                    '--minify',
                    minify,
                ]);
                if (flags['reset-cache']) {
                    cliArgs.push('--reset-cache');
                }
                // Á≤æÂáÜÊµãËØïÊó∂ÔºåÂçïËøõÁ®ãÊâìÂåÖ
                if (this.isAccurateTest()) {
                    cliArgs.push('--max-workers', '1');
                }
            }
            utils_1.Logger.log('ÊâìÂåÖÂèÇÊï∞:', ...cliArgs.slice(1, cliArgs.length));
            process.env.KRN_ENV = 'BUSINESS';
            process.env.KRN_BUNDLE_ID = bundleId;
            process.env.KRN_BUILD_TYPE = useWebpack ? 'WEBPACK' : 'METRO';
            process.env.KRN_DEV_BUILD_MODE = flags.dev;
            process.env.KRN_BUNDLE_DIR_PATH = bundleDirPath;
            process.env.KRN_BUNDLE_OUTPUT_DIR_PATH = outputDirPath;
            process.env.KRN_BUNDLE_WEBPACK_ASSET_DIR_PATH = webpackAssetsDirPath;
            process.env.KRN_SOURCE_MAP_FILE_NAME = sourceMapFilename;
            process.env.KRN_PLATFORM = platform;
            process.env.KRN_PROJECT_ROOT = projectRoot;
            process.env.KRN_WORKSPACE_CONTEXT = workspaceContext || '';
            process.env.KRN_PACKAGE_MANAGER = (0, utils_1.getPackageManager)(projectRoot);
            process.env.KRN_ENTRY = entry;
            process.env.KRN_CONFIG_PATH = configPath;
            process.env.WEBPACK_CLI_SKIP_IMPORT_LOCAL = cli_shared_1.isInstalledGlobally;
            const buildInChildProcess = () => {
                return new Promise((resolve, reject) => {
                    var _a, _b;
                    const childProcess = (0, child_process_1.spawn)('node', cliArgs, {
                        env: process.env,
                    });
                    const writeStream = fs.createWriteStream(logPath);
                    (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(writeStream);
                    (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.pipe(writeStream);
                    childProcess.on('close', () => {
                        writeStream === null || writeStream === void 0 ? void 0 : writeStream.close();
                    });
                    childProcess.on('error', reject);
                    childProcess.on('close', (code) => {
                        if (code === 0) {
                            resolve();
                        }
                        else {
                            reject();
                        }
                    });
                });
            };
            await buildInChildProcess();
            if (flags['verbose']) {
                utils_1.Logger.log(fs.readFileSync(logPath).toString());
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`ÊâìÂåÖÊó•ÂøóÂ∑≤ÁîüÊàê:`, logPath);
        }
        catch (error) {
            utils_1.Logger.stop();
            return Promise.reject(error || new Error(fs.readFileSync(logPath).toString()));
        }
        finally {
            // ÊÅ¢Â§çÁ≤æÂáÜÊµãËØïÁîüÊàêÁöÑ‰∏¥Êó∂ÂÖ•Âè£Êñá‰ª∂
            if (this.isAccurateTest()) {
                fs.writeFileSync(entryPath, originalFileContent);
            }
        }
    }
    async handleBusinessBundle({ platform, bundleId, version, outputDirPath, tmpDirPath, bundleDirPath, bundleFilePath, internalPath, webpackAssetsDirPath, componentNamesJsonFilePath, bachedBridgeRegisterCheckFilePath, sourcemapPath, }) {
        var _a, _b, _c;
        const flags = this.getFlags();
        const md5Str = md5(fs.readFileSync(bundleFilePath));
        const { size: bundleSize } = fs.statSync(bundleFilePath);
        const packageInfo = require(path.resolve('./package.json'));
        const krnConfig = this.getKrnConfig();
        let componentNames = [];
        // ‰ªé babel Êèí‰ª∂‰∏≠Ëé∑ÂèñÊâÄÊúâÁöÑ componentNames
        if (fs.existsSync(componentNamesJsonFilePath)) {
            const { throwError, list = [] } = fs.readJSONSync(componentNamesJsonFilePath) || {
                throwError: false,
                list: [],
            };
            if (!throwError) {
                componentNames = list;
            }
        }
        // ‰ªé batchedBridgeRegisterCheck ‰∏≠Ê£ÄÊü•ÊòØÂê¶ÊúâÈáçÂ§çÊ≥®ÂÜå
        if (fs.existsSync(bachedBridgeRegisterCheckFilePath)) {
            const checkResult = fs.readJSONSync(bachedBridgeRegisterCheckFilePath);
            if (checkResult.length) {
                const summary = {};
                checkResult.forEach((item) => {
                    if (!summary[item.key]) {
                        summary[item.key] = 0;
                    }
                    summary[item.key] += 1;
                });
                for (const key in summary) {
                    const count = summary[key];
                    cli_shared_1.weblog.sendImmediately('CLICK', {
                        action: `REACT_NATIVE_BATCHED_BRIDGE_REGISTER`,
                        params: {
                            page: flags.bundleId,
                            versionCode: flags.version,
                            key,
                            count,
                        },
                    });
                    if (count > 1) {
                        utils_1.Logger.warn(`Â≠òÂú®ÈáçÂ§çÁöÑ react-native/BatchedBridge Ê≥®ÂÜå Key: ${key}
‰ª£Á†Å‰ΩçÁΩÆ: ${checkResult
                            .filter((item) => item.key === key)
                            .map((item) => item.filename)
                            .join(', ')}`);
                        // ÂêéÁª≠ÈúÄË¶ÅÊäõÂá∫ÂºÇÂ∏∏ÔºåÂπ∂‰∏îÁªôÂá∫ÊñáÊ°£ÈìæÊé•
                    }
                }
            }
        }
        const config = {
            'react-native': ((_a = packageInfo.dependencies) === null || _a === void 0 ? void 0 : _a['react-native']) ||
                ((_b = packageInfo.peerDependencies) === null || _b === void 0 ? void 0 : _b['react-native']) ||
                ((_c = packageInfo.devDependencies) === null || _c === void 0 ? void 0 : _c['react-native']),
            framework: 'react',
            language: krnConfig.language,
            platform,
            bundleId,
            versionCode: version,
            version: `0.0.${version}`,
            md5: md5Str,
            bundleSize,
            frameworkBaseVersion: krnConfig.frameworkBaseVersion || '~0.0.1',
            componentNames,
        };
        utils_1.Logger.log(`bundleÊñá‰ª∂ÁöÑmd5ÂÄº:`, md5Str);
        const metaFilePath = path.resolve(outputDirPath, 'meta.json');
        const manifestFilePath = path.resolve(outputDirPath, 'manifest.json');
        const manifest = {
            'resource.tex': md5Str,
        };
        await (0, utils_1.writeJsonFile)(manifestFilePath, manifest);
        await (0, utils_1.writeJsonFile)(metaFilePath, config);
        await fs.copyFile(bundleFilePath, `${internalPath}/${bundleId}_${md5Str}_${version}_${platform}.bundle`);
        // Â§çÂà∂ webpack ËµÑÊ∫êÂà∞ outputDirPath
        if (flags['use-webpack']) {
            await fs.copy(webpackAssetsDirPath, outputDirPath);
        }
        await fs.copy(outputDirPath, internalPath);
        await fs.copyFile(bundleFilePath, `${outputDirPath}/resource.tex`);
        utils_1.Logger.loading('ÂéãÁº© internal ÁõÆÂΩï‰∏≠');
        (0, utils_1.zip)({
            path: internalPath,
            destPath: internalPath + `/${bundleId}.zip`,
        });
        utils_1.Logger.loading('ÂéãÁº© output ÁõÆÂΩï‰∏≠');
        (0, utils_1.zip)({
            path: outputDirPath,
            destPath: outputDirPath + '/output.zip',
        });
        utils_1.Logger.loading('Â∞ÜbundleÂéãÁº©Âπ∂Â∞ÅË£ÖËøõpngÊñá‰ª∂');
        const bundlePngFileName = `${platform}_${bundleId}_${md5Str}_${version}.png`;
        const productBundlePngPath = `${bundleDirPath}/${bundlePngFileName}`;
        await (0, utils_1.execAsync)(`cat ${tmpDirPath}/a.png ./output.zip >${productBundlePngPath}`, { cwd: outputDirPath });
        const pngMd5Str = md5(fs.readFileSync(productBundlePngPath));
        const cryPng = [];
        if (platform === 'ios') {
            // ios10 ËØ≠Ê≥ïÊ£ÄÊµã
            try {
                await (0, compat_grammar_check_1.default)({
                    filePath: bundleFilePath,
                    sourcemapPath: sourcemapPath,
                    ignoreRules: krnConfig.grammarCheckIngore || [],
                });
            }
            catch (err) {
                console.log(err);
                cli_shared_1.weblog.sendImmediately('CLICK', {
                    action: `IOSGrammar`,
                    params: {
                        page: bundleId,
                        error: err.message.split('\n').length - 2,
                        versionCode: version,
                        framework: 'KRN',
                    },
                });
            }
            try {
                // xor Âä†ÂØÜ‰∫ßÁâ©
                const bundleXorPngFileName = `${platform}_${bundleId}_${md5Str}_${version}_cry1.png`;
                const productBundleXorPngPath = `${bundleDirPath}/${bundleXorPngFileName}`;
                const xorResult = (0, bundle_cipher_1.encrypt)({
                    type: bundle_cipher_1.EncryptType.XOR,
                    pngPath: productBundlePngPath,
                    bundleFileName: 'resource.tex',
                    output: {
                        pngPath: productBundleXorPngPath,
                    },
                });
                const cry1Png = {
                    cryType: bundle_cipher_1.EncryptType.XOR,
                    pngSize: xorResult.pngSize,
                    bundleSize: xorResult.bundleSize,
                    md5: xorResult.md5,
                    bundleFile: bundleXorPngFileName,
                };
                cryPng.push(cry1Png);
            }
            catch (error) {
                throw new Error(`ÁîüÊàê IOS Âä†ÂØÜ png ‰∫ßÁâ©Â§±Ë¥•: error`);
            }
        }
        utils_1.Logger.stop();
        const { size } = fs.statSync(productBundlePngPath);
        const fileSize = Math.round(size / 1024);
        utils_1.Logger.log('ÂΩìÂâçbundleÂ§ßÂ∞è:', fileSize + 'KB');
        if (fileSize > 500 && flags.dev !== 'true' && flags['ignore-size']) {
            throw new Error(`bundleÂ§ßÂ∞è‰∏çËÉΩË∂ÖËøá500KBÔºåËØ∑Â∞ùËØï: \n1. Â∞ÜÂõæÁâáÊàñËÄÖÂÖ∂‰ªñÈùôÊÄÅÊñá‰ª∂‰∏ä‰º†CDN„ÄÇ\n2. importÁ¨¨‰∏âÊñπÂ∫ìÊó∂ÈááÁî®Ë∑ØÂæÑÂºïÁî®ÁöÑÊñπÂºèÔºåÊØîÂ¶Çimport merge from 'lodash/merge'„ÄÇ`);
        }
        const bundleConfigFilePath = path.resolve(bundleDirPath, 'config.json');
        await (0, utils_1.writeJsonFile)(bundleConfigFilePath, Object.assign(Object.assign(Object.assign({ pngSize: size }, config), (platform === 'ios' ? { cryPng } : {})), { bundleFile: bundlePngFileName }));
        utils_1.Logger.log('ÊâìÂåÖ‰ø°ÊÅØÊñá‰ª∂Â∑≤ÁîüÊàê:', path.relative(process.cwd(), bundleConfigFilePath));
        return {
            productBundlePngPath,
            md5Str,
            pngMd5Str,
            bundleConfigFilePath,
            bundleSize: size,
        };
    }
    async uploadProducts({ platform, bundleId, md5Str, version, productBundlePngPath, bundleDirPath, }) {
        const uploadCdn = async (src, text) => {
            utils_1.Logger.loading(text);
            const { stdout, stderr } = await (0, utils_1.execAsync)(`node \
                    ${utils_1.rootDir}/node_modules/.bin/kcdn-upload ${src} \
                    --cdn-dir ${bundleId} \
                    --pid KRN \
                    --token 10398_62ef3ba964d26fafd51b03a58f018566 \
                    --allow-rewrite \
                `);
            if (stderr) {
                utils_1.Logger.error(`${text}Â§±Ë¥•`);
                return Promise.reject(new Error(stderr));
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`${text}Âà∞CDNÁöÑÁªìÊûú:`);
            utils_1.Logger.log(stdout);
        };
        try {
            const logPath = `${bundleDirPath}/${platform}_${bundleId}_${md5Str}_${version}.txt`;
            const sourcemapPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.sourcemap.js.map`;
            await fs.rename(`${bundleDirPath}/${platform}_${bundleId}_${version}.txt`, logPath);
            await uploadCdn(productBundlePngPath, '‰∏ä‰º†bundleÊñá‰ª∂');
            await uploadCdn(logPath, 'Ê≠£Âú®‰∏ä‰º†logÊñá‰ª∂');
            await uploadCdn(sourcemapPath, 'Ê≠£Âú®‰∏ä‰º†sourcemapÊñá‰ª∂');
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async deployCDN({ platform, bundleId, version, productBundlePngPath, bundleFilePath, bundleDirPath, md5Str, }) {
        const uploadCdn = async (src, text) => {
            const dir = `kds-react-cli/deploy-test/${bundleId}/${platform}/${version}`;
            utils_1.Logger.loading(text);
            const { stdout, stderr } = await (0, utils_1.execAsync)(`node \
                    ${utils_1.rootDir}/node_modules/.bin/kcdn-upload ${src} \
                    --cdn-dir ${dir} \
                    --pid KDS \
                    --token 11256_bdc6bd128e75948dfae5291541ed6330 \
                    --allow-rewrite \
                `);
            if (stderr) {
                utils_1.Logger.error(`${text}Â§±Ë¥•`);
                return Promise.reject(new Error(stderr));
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`${text}Âà∞CDNÁöÑÁªìÊûú:`);
            utils_1.Logger.log(stdout);
            const filename = path.basename(src);
            return `https://s2-11256.kwimgs.com/kos/nlav11256/kds-react-cli/deploy-test/${bundleId}/${platform}/${version}/${filename}`;
        };
        const uploadAnalysis = async () => {
            const analysisHtmlPath = path.join(bundleDirPath, `analysis-${md5Str}.html`);
            const { stderr } = await (0, utils_1.execAsync)(`node \
                    ${binUp('source-map-explorer')} ${bundleFilePath} \
                    --html ${analysisHtmlPath}
                `);
            if (stderr && !stderr.includes('Unable to map')) {
                utils_1.Logger.error('ÁîüÊàê‰æùËµñÂàÜÊûêÂõæÂ§±Ë¥•', stderr);
                return Promise.reject(new Error(stderr));
            }
            const url = await uploadCdn(analysisHtmlPath, '‰∏ä‰º†‰æùËµñÂàÜÊûêÂõæ');
            fs.unlinkSync(analysisHtmlPath);
            return url;
        };
        try {
            const sourcemapPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.sourcemap.js.map`;
            const bundleCdnUrl = await uploadCdn(productBundlePngPath, 'ÈÉ®ÁΩ≤ bundle Êñá‰ª∂');
            await uploadCdn(sourcemapPath, 'ÈÉ®ÁΩ≤ sourcemap Êñá‰ª∂');
            let analysisHtmlUrl = '';
            try {
                analysisHtmlUrl = await uploadAnalysis();
            }
            catch (error) {
                utils_1.Logger.error('ÁîüÊàê‰æùËµñÂàÜÊûêÂõæÂ§±Ë¥•', error);
            }
            return {
                bundleCdnUrl,
                analysisHtmlUrl,
            };
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async runBuildBusinessBunlde() {
        var _a, _b;
        const flags = this.getFlags();
        const timestemp = Date.now();
        try {
            await this.runHook('prebuild');
            const businessParams = await this.ensureBusinessParams();
            const { outputDirPath, tmpDirPath, bundleDirPath, webpackAssetsDirPath, bundleId, version, platform, } = businessParams;
            const useWebpack = !!flags['use-webpack'];
            if (useWebpack && !this.isIntegratedWebpack()) {
                return Promise.reject(new Error('È°πÁõÆËøòÊú™ÈõÜÊàê webpack ÊâìÂåÖÔºåËØ∑ÊåâÁÖß http://ksurl.cn/nrpRH57X ÊñáÊ°£ÈõÜÊàêÂêéÂºÄÂêØ webpack ÊûÑÂª∫ÔºåÂ¶ÇÊûúÈ°πÁõÆÂ∑≤ÁªèÈõÜÊàêËøáÔºåËØ∑ËÅîÁ≥ª lixuan12 Â§ÑÁêÜ'));
            }
            // ÊèíÂÖ•ÈªòËÆ§ÁöÑ babel Êèí‰ª∂
            await this.insertBabelConfig(businessParams);
            await this.buildBusinessBundle(businessParams);
            await this.runHook('prepack');
            const { productBundlePngPath, md5Str, bundleSize, bundleConfigFilePath, pngMd5Str, } = await this.handleBusinessBundle(businessParams);
            // ‰∏ä‰º†ÊâìÂåÖÁöÑ‰∫ßÁâ©
            if (flags.upload) {
                await this.uploadProducts(Object.assign(Object.assign({}, businessParams), { md5Str,
                    productBundlePngPath }));
            }
            // ÈÉ®ÁΩ≤Âà∞ÊµãËØï CDN
            let deployResult = null;
            if (!(0, cli_shared_1.isCIEnvironment)() &&
                (flags.deploy || flags['deploy-scheme'])) {
                deployResult = await this.deployCDN(Object.assign(Object.assign({}, businessParams), { md5Str,
                    productBundlePngPath }));
            }
            // ‰∏äÊä•ÊâìÂåÖ‰ø°ÊÅØ
            await this.reportBuildInfo({
                start: timestemp,
                success: true,
                businessParams,
                bundleSize,
                bundleConfigFilePath,
            });
            await this.runHook('postbuild');
            // Âà†Èô§‰∏¥Êó∂ÁöÑÊâìÂåÖÁõÆÂΩï;
            fs.removeSync(outputDirPath);
            fs.removeSync(tmpDirPath);
            fs.removeSync(webpackAssetsDirPath);
            utils_1.Logger.log('ÊâìÂåÖÁõÆÂΩï‰ΩçÁΩÆ:', bundleDirPath);
            if (deployResult) {
                // ÁîüÊàêÈ¢ÑËßà‰∫åÁª¥Á†Å
                const { bundleCdnUrl, analysisHtmlUrl } = deployResult;
                const previewUrl = (((_a = flags['deploy-scheme']) === null || _a === void 0 ? void 0 : _a.trim()) ||
                    'kwai://krn?bundleId=$BUNDLE_ID&componentName=').replace('$BUNDLE_ID', bundleId);
                utils_1.Logger.success('Ëá™ÂÆö‰πâË∑≥ËΩ¨ÂèÇÊï∞:', previewUrl);
                const scheme = (_b = previewUrl.match(/^\w+?:\/\//)) !== null && _b !== void 0 ? _b : 'kwai://';
                qrcode.generate(`${scheme}kds/download/react?data=${JSON.stringify({
                    md5: md5Str,
                    zipMd5: pngMd5Str,
                    url: bundleCdnUrl,
                    bundleId,
                    rnVersion: '0.62.2',
                    version: `0.0.${version}`,
                    versionCode: isNaN(+version) ? version : +version,
                    scheme: encodeURIComponent(previewUrl),
                    platform,
                })}`, { small: true }, (code) => {
                    utils_1.Logger.log('Êâ´Êèè‰∫åÁª¥Á†ÅËøõË°åÈ¢ÑËßà:');
                    console.log(code);
                    utils_1.Logger.log('ÊèêÁ§∫: IOS ÈúÄ‰ΩøÁî®Á≥ªÁªüÁõ∏Êú∫Êâ´Á†Å');
                    utils_1.Logger.success('Êü•Áúã‰æùËµñÂàÜÊûêÔºö', analysisHtmlUrl);
                });
            }
        }
        catch (error) {
            await this.reportBuildInfo({
                start: timestemp,
                success: false,
            });
            return Promise.reject(error);
        }
    }
    async reportBuildInfo({ start, success, businessParams, bundleSize, bundleConfigFilePath, }) {
        const flags = this.getFlags();
        const isCI = (0, cli_shared_1.isCIEnvironment)();
        const existReactNativeDuplicateMsg = 'React Native ÁâàÊú¨Â≠òÂú®ÂÜ≤Á™ÅÔºå‰ºöÂØºËá¥ÂåÖ‰ΩìÁßØÂèòÂ§ßÊàñÊó†Ê≥ïÊ≠£Â∏∏ËøêË°åÔºåËØ∑ÂèÇËÄÉ http://ksurl.cn/oHB93KHw ËøõË°å‰øÆÂ§ç';
        try {
            if (isCI && flags.dev !== 'true') {
                const componentNames = await this.getRegisterComponentNames((businessParams === null || businessParams === void 0 ? void 0 : businessParams.entry) || '');
                const data = {
                    time: Date.now() - start,
                    page: flags.bundleId,
                    CLIVersion: this.config.version,
                    type: success ? 'SUCCESS' : 'FAILED',
                    versionCode: flags.version,
                    buildType: flags['use-webpack'] ? 'WEBPACK' : 'METRO',
                };
                if (data.type === 'SUCCESS') {
                    await new Promise((res) => setTimeout(res, 500));
                    const { packages, summary, kidComponents, } = await (0, bundle_stats_1.bundleStats)(Object.assign(Object.assign({}, businessParams), { bundleSize: bundleSize || 0 }));
                    const isExistReactNativeDuplicate = packages.some((item) => {
                        return (item.name === 'react-native' &&
                            (item.duplicateCount > 0 || item.value > 200000));
                    });
                    if (isExistReactNativeDuplicate) {
                        throw new Error(existReactNativeDuplicateMsg);
                    }
                    Object.assign(data, summary);
                    // ÂÜôËøõ config.json ‰∏≠
                    if (bundleConfigFilePath) {
                        const config = await fs.readJSONSync(bundleConfigFilePath);
                        config.buildSummary = summary;
                        await (0, utils_1.writeJsonFile)(bundleConfigFilePath, config);
                    }
                    packages.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_PACKAGES`,
                            params: Object.assign({ page: flags.bundleId }, val),
                        });
                    });
                    kidComponents.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_KID_UI_COMPONENTS`,
                            params: Object.assign({ page: flags.bundleId }, val),
                        });
                    });
                }
                // ÂèëÈÄÅ KEEP_COMPONENT_NAMES
                if (componentNames.length) {
                    componentNames.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_COMPONENT_NAMES`,
                            params: {
                                page: flags.bundleId,
                                versionCode: flags.version,
                                component: val,
                            },
                        });
                    });
                }
                // ÂèëÈÄÅ KEEP_BUILD‰ø°ÊÅØ
                cli_shared_1.weblog.sendImmediately('CLICK', {
                    action: `KEEP_BUILD`,
                    params: data,
                });
                utils_1.Logger.log('ÂüãÁÇπÊâìÁÇπ‰∏ä‰º†...');
                await new Promise((res) => setTimeout(res, 10 * 1000));
                utils_1.Logger.log('ÂüãÁÇπ‰∏ä‰º†ÊàêÂäü');
            }
        }
        catch (err) {
            console.log(err);
            if (((err === null || err === void 0 ? void 0 : err.toString()) || '').includes(existReactNativeDuplicateMsg)) {
                throw err;
            }
            utils_1.Logger.error('ÁªüËÆ°ÊâìÂåÖ‰ø°ÊÅØÂ§±Ë¥•', err);
        }
    }
    async runHook(name) {
        const { hooks } = this.getKrnConfig();
        if (!hooks) {
            return;
        }
        const hook = hooks[name];
        if (!hook) {
            return;
        }
        const text = `ÊâßË°åÈí©Â≠ê: ${name}Ôºå${hook}`;
        const exitError = `${text}ÔºåÁªàÊ≠¢ÊâìÂåÖÊµÅÁ®ã`;
        try {
            utils_1.Logger.log(text);
            await new Promise((resolve, reject) => {
                const cp = (0, child_process_1.spawn)(hook, [], {
                    shell: true,
                    stdio: 'inherit',
                });
                const closeHander = (code) => {
                    if (code === 33) {
                        reject(new Error(exitError));
                    }
                    else {
                        resolve();
                    }
                };
                cp.on('close', closeHander);
                cp.on('exit', closeHander);
            });
            utils_1.Logger.success(`${text}ÊàêÂäü`);
        }
        catch (err) {
            const stderr = err.toString();
            if (stderr.includes(exitError)) {
                throw new Error(exitError);
            }
            utils_1.Logger.error(`${text}Â§±Ë¥•Ôºö`);
            utils_1.Logger.error(stderr);
        }
    }
    isAccurateTest() {
        const flags = this.getFlags();
        const krnConfig = this.getKrnConfig();
        return (flags['accurate-test-istanbul'] || !!krnConfig.accurateTestIstanbul);
    }
    isAutoTestId() {
        const flags = this.getFlags();
        const krnConfig = this.getKrnConfig();
        return flags['auto-test-id'] || !!krnConfig.autoTestId;
    }
    isNeedInsertBabelConfig() {
        return ((0, cli_shared_1.isCIEnvironment)() ||
            this.isAccurateTest() ||
            this.isAutoTestId() ||
            this.isEnableBatchedBridgeRegisterCheck());
    }
    isEnableBatchedBridgeRegisterCheck() {
        const krnConfig = this.getKrnConfig();
        return !krnConfig.ignoreBatchedBridgeRegisterCheck;
    }
    async insertBabelConfig(businessParams) {
        if (!this.isNeedInsertBabelConfig()) {
            return;
        }
        const flags = await this.getFlags();
        const { accurateTestDataFilePath, accurateTestCsvDataFilePath, bachedBridgeRegisterCheckFilePath, } = businessParams;
        const accurateTestPlugins = [
            [
                '@kds/istanbul',
                {
                    exclude: ['@kds/accurate-test-plugin/runtime'],
                    accurateTestOptions: {
                        bundleId: flags.bundleId,
                        platform: flags.platform,
                        dataFilePath: accurateTestDataFilePath,
                        csvDataFilePath: accurateTestCsvDataFilePath,
                    },
                },
            ],
        ];
        const ciPlugins = [
            [
                require.resolve('@krn/babel-plugin-react-native-usage-analyze'),
                Object.assign({}, this.getFlags()),
            ],
            [
                require.resolve('@krn/babel-plugin-kid-penetration-analyze'),
                Object.assign({}, this.getFlags()),
            ],
            [
                require.resolve('@krn/babel-plugin-package-analyze'),
                Object.assign({}, this.getFlags()),
            ],
        ];
        const buildPlugins = [
            [
                require.resolve('@krn/babel-plugin-react-native-get-component-names'),
                {
                    outputFilePath: businessParams.componentNamesJsonFilePath,
                },
            ],
        ];
        const prodPlugins = [...ciPlugins, ...buildPlugins];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const defaultPlugins = [];
        if (this.isAccurateTest()) {
            defaultPlugins.push(...accurateTestPlugins);
        }
        if (this.isAutoTestId()) {
            defaultPlugins.push([
                require.resolve('@krn/babel-plugin-auto-test-id'),
                Object.assign({}, this.getFlags()),
            ]);
        }
        if (this.isEnableBatchedBridgeRegisterCheck()) {
            defaultPlugins.push([
                require.resolve('@krn/babel-plugin-react-native-batch-bridge-register-check'),
                Object.assign(Object.assign({}, this.getFlags()), { outputFilePath: bachedBridgeRegisterCheckFilePath }),
            ]);
        }
        const babelConfigFilePath = path.resolve(process.cwd(), 'babel.config.js');
        if (!fs.existsSync(babelConfigFilePath)) {
            return;
        }
        const oldBabelConfigFilePath = path.resolve(process.cwd(), 'babel.config.old.js');
        if (fs.existsSync(oldBabelConfigFilePath)) {
            return;
        }
        fs.copySync(babelConfigFilePath, oldBabelConfigFilePath);
        const newBabelConfigContent = `const oldConfig = require('${oldBabelConfigFilePath}');
const productionPlugins = ${JSON.stringify(prodPlugins)};
const defaultPlugins = ${JSON.stringify(defaultPlugins)};
if (!oldConfig.env) {
    oldConfig.env = {};
}
if (!oldConfig.env.production) {
    oldConfig.env.production = {};
}
if (!oldConfig.env.production.plugins) {
    oldConfig.env.production.plugins = [];
}
oldConfig.env.production.plugins = [
    ...productionPlugins,
    ...oldConfig.env.production.plugins
];
if (!oldConfig.plugins) {
    oldConfig.plugins = [];
}
oldConfig.plugins = [
    ...defaultPlugins,
    ...oldConfig.plugins
];
module.exports = oldConfig;
`;
        fs.writeFileSync(babelConfigFilePath, newBabelConfigContent);
    }
    restoreBabelConfig() {
        if (!this.isNeedInsertBabelConfig()) {
            return;
        }
        const oldBabelConfigFilePath = path.resolve(process.cwd(), 'babel.config.old.js');
        if (!fs.existsSync(oldBabelConfigFilePath)) {
            return;
        }
        const babelConfigFilePath = path.resolve(process.cwd(), 'babel.config.js');
        fs.copySync(oldBabelConfigFilePath, babelConfigFilePath);
        fs.removeSync(oldBabelConfigFilePath);
    }
    isIntegratedWebpack() {
        const isExistBabelWebpackConfig = fs.existsSync(path.resolve('babel-webpack.config.js'));
        if (isExistBabelWebpackConfig) {
            return true;
        }
        const isExistWebpackConfig = fs.existsSync(path.resolve('webpack.config.js'));
        if (isExistWebpackConfig) {
            return true;
        }
        const babelConfigFilePath = path.resolve('babel.config.js');
        if (fs.existsSync(babelConfigFilePath)) {
            const babelConfigContent = fs.readFileSync(babelConfigFilePath, {
                encoding: 'utf-8',
            });
            return babelConfigContent.includes('disableImportExportTransform'); // ÊâãÂä®ÊåáÂÆö‰∫ÜËøô‰∏™ÈÄâÈ°πÔºåËØ¥ÊòéËá™Â∑±ÈõÜÊàê‰∫Ü webpack ÊâìÂåÖ
        }
        return false;
    }
    async run() {
        var _a;
        try {
            await super.run();
            await (0, patch_1.default)();
            await this.runBuildBusinessBunlde();
            const currentFlags = this.getFlags();
            this.runAnalytics(Object.assign(Object.assign({ id: this.id }, currentFlags), { page: currentFlags.bundleId, CLIVersion: this.config.version }));
            // ÊÅ¢Â§ç babel ÈÖçÁΩÆ‰∏∫‰πãÂâçÁöÑ
            this.restoreBabelConfig();
        }
        catch (error) {
            utils_1.Logger.stop();
            utils_1.Logger.log('Oops~ÊâìÂåÖÂ§±Ë¥•');
            this.restoreBabelConfig();
            await (0, utils_1.diagnoseWithBuildErrorMessage)(((_a = error === null || error === void 0 ? void 0 : error.toString) === null || _a === void 0 ? void 0 : _a.call(error)) || '');
            await this.runHook('failbuild');
            utils_1.Logger.error(error);
            process.exit(1);
        }
    }
}
exports.default = Build;
Build.hidden = false;
Build.description = 'ÊâìÂåÖÂëΩ‰ª§';
Build.examples = [
    `krn build --bundleId=Demo --dev=true --platform=ios --version=1 --upload`,
];
Build.flags = Object.assign({ version: command_1.flags.integer({
        char: 'v',
        helpValue: '1',
        description: 'ÁâàÊú¨Âè∑',
        default: 0,
        required: true,
    }), bundleId: command_1.flags.string({
        char: 'b',
        helpValue: 'Demo',
        description: 'BundleId',
        default: '',
        required: true,
    }), upload: command_1.flags.boolean({
        char: 'u',
        description: 'ÊòØÂê¶‰∏ä‰º†bundle',
        default: false,
    }), 'ignore-size': command_1.flags.boolean({
        char: 'i',
        description: 'ÊòØÂê¶ÂøΩÁï•Êñá‰ª∂‰ΩìÁßØÁöÑÈôêÂà∂',
        default: false,
    }) }, RNCliFlags);
