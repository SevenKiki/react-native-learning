"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const child_process_1 = require("child_process");
const command_1 = require("@oclif/command");
const inquirer = require("inquirer");
const fs = require("fs-extra");
const md5 = require("md5");
const utils_1 = require("../utils");
const bundle_stats_1 = require("../utils/bundle-stats");
const chalk = require("chalk");
const patch_1 = require("../patch");
const lodash_1 = require("lodash");
const command_2 = require("./command");
const cli_shared_1 = require("@krn/cli-shared");
const bundle_cipher_1 = require("@kds/bundle-cipher");
const compat_grammar_check_1 = require("@kds/compat-grammar-check");
const binUp = require('bin-up');
const qrcode = require('qrcode-terminal');
var BUILD_PLATFORM;
(function (BUILD_PLATFORM) {
    BUILD_PLATFORM["IOS"] = "ios";
    BUILD_PLATFORM["ANDROID"] = "android";
})(BUILD_PLATFORM || (BUILD_PLATFORM = {}));
const RNCliFlags = {
    platform: command_1.flags.string({
        char: 'p',
        helpValue: 'ios',
        description: '打包平台',
        default: '',
        required: true,
    }),
    dev: command_1.flags.string({
        char: 'd',
        helpValue: 'true',
        description: '打DEBUG包',
        default: 'false',
    }),
    minify: command_1.flags.string({
        helpValue: 'true',
        description: '是否压缩bundle',
        default: 'true',
    }),
    config: command_1.flags.string({
        helpValue: './metro.config.js',
        description: 'metro配置文件路径',
        default: '',
    }),
    'reset-cache': command_1.flags.boolean({
        char: 'r',
        description: '是否清除打包缓存',
        default: false,
    }),
    verbose: command_1.flags.boolean({
        description: '是否输出打包日志',
        default: false,
    }),
    'use-webpack': command_1.flags.boolean({
        description: '使用webpack构建',
        default: false,
    }),
    deploy: command_1.flags.boolean({
        description: '本地部署预览，只能用于本地测试使用',
        default: false,
    }),
    'deploy-scheme': command_1.flags.string({
        description: '部署后，扫码下载的自定义跳转参数，类似 Keep 打包时的参数，默认值为 kwai://krn?bundleId=$BUNDLE_ID&componentName=，其中 $BUNDLE_ID 会在生成二维码的时候自动替换为实际的 bundleId',
        default: '',
    }),
    'accurate-test-istanbul': command_1.flags.boolean({
        description: '精准测试代码插桩',
        default: false,
    }),
    'auto-test-id': command_1.flags.boolean({
        description: '自动插入 testID',
        default: false,
    }),
};
const handleCLIVersion = () => {
    const packageJson = fs.readJSONSync('./package.json');
    packageJson.resolutions = packageJson.resolutions || {};
    packageJson.resolutions['@react-native-community/cli'] = '4.13.1';
    packageJson.resolutions['react-native'] = '0.62.2';
    fs.writeJsonSync('./package.json', packageJson, {
        spaces: '  ',
    });
    (0, child_process_1.execSync)('yarn');
};
const handleAccurateTestIstanbul = () => {
    const packageJson = fs.readJSONSync('./package.json');
    packageJson.devDependencies = packageJson.devDependencies || {};
    packageJson.devDependencies['@kds/babel-plugin-istanbul'] = '^6.1.2';
    fs.writeJsonSync('./package.json', packageJson, {
        spaces: '  ',
    });
    (0, child_process_1.execSync)('yarn');
};
const handleCIDiagnose = async () => {
    await (0, utils_1.diagnose)(true);
};
class Build extends command_2.default {
    getFlags() {
        const { flags } = this.parse(Build);
        return flags;
    }
    async selectPlatform() {
        const flags = this.getFlags();
        if (flags.platform) {
            return flags.platform;
        }
        const responses = await inquirer.prompt({
            name: 'platform',
            message: '请选择打包平台',
            type: 'list',
            choices: [
                { name: BUILD_PLATFORM.IOS },
                { name: BUILD_PLATFORM.ANDROID },
            ],
        });
        return responses.platform;
    }
    async inputVersion() {
        const flags = this.getFlags();
        // 版本必须 > 0
        if ((0, lodash_1.isNumber)(flags.version) && flags.version > 0) {
            return flags.version;
        }
        const responses = await inquirer.prompt({
            name: 'version',
            message: '请输入版本号',
            type: 'input',
            validate: (value) => {
                if (/\d+/.test(value)) {
                    return true;
                }
                return '请输入正确的版本号';
            },
        });
        return responses.version;
    }
    async inputBundleId() {
        const flags = this.getFlags();
        if (flags.bundleId) {
            return flags.bundleId;
        }
        const krnConfig = this.getKrnConfig();
        if ((0, lodash_1.isPlainObject)(krnConfig.entry)) {
            const choices = Object.keys(krnConfig.entry).map((key) => {
                return {
                    name: key,
                };
            });
            const responses = await inquirer.prompt({
                name: 'bundleId',
                message: '请选择BundleId',
                type: 'list',
                choices,
            });
            return responses.bundleId;
        }
        const responses = await inquirer.prompt({
            name: 'bundleId',
            message: '请输入BundleId',
            type: 'input',
        });
        return responses.bundleId;
    }
    getKrnConfig() {
        const krnConfigPath = path.resolve('./krn.config.json');
        return fs.existsSync(krnConfigPath)
            ? fs.readJSONSync(krnConfigPath)
            : {};
    }
    async getRegisterComponentNames(entry) {
        if (entry && fs.existsSync(entry)) {
            const entryFile = fs.readFileSync(entry).toString();
            const registerComponents = entryFile.match(/(?<=AppRegistry\.registerComponent\((\n|\r|\s)*?('|")).*?(?=('|"))/g) || [];
            return registerComponents;
        }
        return [];
    }
    async getEntryFilePath(entry, bundleId) {
        let entryFilePath;
        if (!entry) {
            // 没有entry走自动匹配
            const entryFilePaths = ['./index.ts', './index.js'].filter(fs.existsSync);
            entryFilePath = entryFilePaths[0] || entryFilePaths[1];
            if (entryFilePath) {
                utils_1.Logger.warn(`Warning: 找不到 entry, 已自动匹配 \`${entryFilePath}\` 文件`);
                return entryFilePath;
            }
        }
        else if ((0, lodash_1.isString)(entry)) {
            entryFilePath = entry;
        }
        else if ((0, lodash_1.isPlainObject)(entry)) {
            // 多入口的情况
            entryFilePath = entry[bundleId];
        }
        if (entryFilePath && fs.existsSync(entryFilePath)) {
            return entryFilePath;
        }
        else {
            throw new Error('entry 文件不存在');
        }
    }
    async ensureBusinessParams() {
        // 参数输入
        const platform = await this.selectPlatform();
        const version = await this.inputVersion();
        const bundleId = await this.inputBundleId();
        const krnConfig = this.getKrnConfig();
        const entry = await this.getEntryFilePath(krnConfig.entry, bundleId);
        const workspaceContext = krnConfig.workspace;
        const productsPath = path.resolve('./products', platform, bundleId, version.toString());
        // 临时的打包目录
        const outputDirPath = path.resolve(productsPath, './output');
        const tmpDirPath = path.resolve(productsPath, './tmp');
        const bundleDirPath = path.resolve(productsPath, './bundle');
        const internalPath = path.resolve(bundleDirPath, './internal');
        const webpackAssetsDirPath = path.resolve(bundleDirPath, './webpack-assets');
        // 打包产物
        const bundleFilePath = `${bundleDirPath}/index.${platform}.bundle`;
        const staticImgPath = path.resolve(utils_1.rootDir, './assets/assets_player_like_active.png');
        const sourceMapFilename = `${platform}_${bundleId}_${version}.sourcemap.js.map`;
        const sourcemapPath = `${bundleDirPath}/${sourceMapFilename}`;
        const imgFilePath = `${tmpDirPath}/a.png`;
        const componentNamesJsonFilePath = `${bundleDirPath}/component-names.json`;
        const accurateTestDataFilePath = `${bundleDirPath}/accurate-test-result.json`;
        const accurateTestCsvDataFilePath = `${bundleDirPath}/accurate-test-result.csv`;
        const bachedBridgeRegisterCheckFilePath = `${tmpDirPath}/batch-bridge-register-check-result.json`;
        (0, utils_1.rmAndMkdir)(outputDirPath);
        (0, utils_1.rmAndMkdir)(tmpDirPath);
        (0, utils_1.rmAndMkdir)(bundleDirPath);
        (0, utils_1.rmAndMkdir)(internalPath);
        (0, utils_1.rmAndMkdir)(webpackAssetsDirPath);
        fs.copyFileSync(staticImgPath, imgFilePath);
        return {
            version,
            platform,
            bundleId,
            entry,
            outputDirPath,
            tmpDirPath,
            bundleDirPath,
            bundleFilePath,
            internalPath,
            webpackAssetsDirPath,
            sourceMapFilename,
            sourcemapPath,
            componentNamesJsonFilePath,
            accurateTestDataFilePath,
            accurateTestCsvDataFilePath,
            bachedBridgeRegisterCheckFilePath,
            workspaceContext,
        };
    }
    async buildBusinessBundle({ platform, bundleId, version, entry, outputDirPath, bundleDirPath, bundleFilePath, webpackAssetsDirPath, sourceMapFilename, sourcemapPath, workspaceContext, }) {
        const flags = this.getFlags();
        utils_1.Logger.log('🚀🚀🚀开始打平台为', chalk.bold(platform), ', bundleId为', chalk.bold(bundleId), ', 版本号为', chalk.bold(version.toString()), ', dev为', chalk.bold(flags.dev), '的包...');
        utils_1.Logger.log(`打包的文件入口:`, entry);
        // 开始打包
        utils_1.Logger.loading('正在打包中');
        const logPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.txt`;
        const entryPath = path.resolve(entry);
        const originalFileContent = fs.readFileSync(entryPath, 'utf-8');
        try {
            const reactNativeCliPath = (0, utils_1.getReactNativeCLI)();
            const projectRoot = process.cwd();
            if (!fs.existsSync(reactNativeCliPath)) {
                return Promise.reject(new Error('请确认已安装依赖'));
            }
            if ((0, cli_shared_1.isCIEnvironment)()) {
                await handleCIDiagnose();
                handleCLIVersion();
            }
            if (this.isAccurateTest()) {
                handleAccurateTestIstanbul();
                const insertContent = `import '@kds/accurate-test/runtime';`;
                if (originalFileContent.indexOf(insertContent) === -1) {
                    const originalContent = originalFileContent.split(/\r\n|\r|\n/gm);
                    originalContent.unshift(insertContent);
                    fs.writeFileSync(entryPath, originalContent.join('\n'));
                }
            }
            const minify = flags.dev === 'true' ? 'false' : flags.minify;
            const useWebpack = !!flags['use-webpack'];
            const cliArgs = [];
            let configPath = '';
            if (useWebpack) {
                const webpackCLI = (0, utils_1.getWebpackCLI)();
                configPath =
                    flags.config || path.resolve('./webpack.config.js');
                cliArgs.push(...[
                    webpackCLI,
                    'build',
                    '--entry',
                    path.resolve(projectRoot, entry),
                    '--config',
                    path.resolve(__dirname, '../webpack-config/base.config.js'),
                    '--env',
                    `platform=${platform}`,
                ]);
            }
            else {
                configPath = flags.config || path.resolve('./metro.config.js');
                cliArgs.push(...[
                    reactNativeCliPath,
                    'bundle',
                    '--platform',
                    platform,
                    '--entry-file',
                    entry,
                    '--assets-dest',
                    outputDirPath,
                    '--config',
                    require.resolve('@krn/metro-config'),
                    '--sourcemap-output',
                    sourcemapPath,
                    '--bundle-output',
                    bundleFilePath,
                    '--dev',
                    flags.dev,
                    '--minify',
                    minify,
                ]);
                if (flags['reset-cache']) {
                    cliArgs.push('--reset-cache');
                }
                // 精准测试时，单进程打包
                if (this.isAccurateTest()) {
                    cliArgs.push('--max-workers', '1');
                }
            }
            utils_1.Logger.log('打包参数:', ...cliArgs.slice(1, cliArgs.length));
            process.env.KRN_ENV = 'BUSINESS';
            process.env.KRN_BUNDLE_ID = bundleId;
            process.env.KRN_BUILD_TYPE = useWebpack ? 'WEBPACK' : 'METRO';
            process.env.KRN_DEV_BUILD_MODE = flags.dev;
            process.env.KRN_BUNDLE_DIR_PATH = bundleDirPath;
            process.env.KRN_BUNDLE_OUTPUT_DIR_PATH = outputDirPath;
            process.env.KRN_BUNDLE_WEBPACK_ASSET_DIR_PATH = webpackAssetsDirPath;
            process.env.KRN_SOURCE_MAP_FILE_NAME = sourceMapFilename;
            process.env.KRN_PLATFORM = platform;
            process.env.KRN_PROJECT_ROOT = projectRoot;
            process.env.KRN_WORKSPACE_CONTEXT = workspaceContext || '';
            process.env.KRN_PACKAGE_MANAGER = (0, utils_1.getPackageManager)(projectRoot);
            process.env.KRN_ENTRY = entry;
            process.env.KRN_CONFIG_PATH = configPath;
            process.env.WEBPACK_CLI_SKIP_IMPORT_LOCAL = cli_shared_1.isInstalledGlobally;
            const buildInChildProcess = () => {
                return new Promise((resolve, reject) => {
                    var _a, _b;
                    const childProcess = (0, child_process_1.spawn)('node', cliArgs, {
                        env: process.env,
                    });
                    const writeStream = fs.createWriteStream(logPath);
                    (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(writeStream);
                    (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.pipe(writeStream);
                    childProcess.on('close', () => {
                        writeStream === null || writeStream === void 0 ? void 0 : writeStream.close();
                    });
                    childProcess.on('error', reject);
                    childProcess.on('close', (code) => {
                        if (code === 0) {
                            resolve();
                        }
                        else {
                            reject();
                        }
                    });
                });
            };
            await buildInChildProcess();
            if (flags['verbose']) {
                utils_1.Logger.log(fs.readFileSync(logPath).toString());
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`打包日志已生成:`, logPath);
        }
        catch (error) {
            utils_1.Logger.stop();
            return Promise.reject(error || new Error(fs.readFileSync(logPath).toString()));
        }
        finally {
            // 恢复精准测试生成的临时入口文件
            if (this.isAccurateTest()) {
                fs.writeFileSync(entryPath, originalFileContent);
            }
        }
    }
    async handleBusinessBundle({ platform, bundleId, version, outputDirPath, tmpDirPath, bundleDirPath, bundleFilePath, internalPath, webpackAssetsDirPath, componentNamesJsonFilePath, bachedBridgeRegisterCheckFilePath, sourcemapPath, }) {
        var _a, _b, _c;
        const flags = this.getFlags();
        const md5Str = md5(fs.readFileSync(bundleFilePath));
        const { size: bundleSize } = fs.statSync(bundleFilePath);
        const packageInfo = require(path.resolve('./package.json'));
        const krnConfig = this.getKrnConfig();
        let componentNames = [];
        // 从 babel 插件中获取所有的 componentNames
        if (fs.existsSync(componentNamesJsonFilePath)) {
            const { throwError, list = [] } = fs.readJSONSync(componentNamesJsonFilePath) || {
                throwError: false,
                list: [],
            };
            if (!throwError) {
                componentNames = list;
            }
        }
        // 从 batchedBridgeRegisterCheck 中检查是否有重复注册
        if (fs.existsSync(bachedBridgeRegisterCheckFilePath)) {
            const checkResult = fs.readJSONSync(bachedBridgeRegisterCheckFilePath);
            if (checkResult.length) {
                const summary = {};
                checkResult.forEach((item) => {
                    if (!summary[item.key]) {
                        summary[item.key] = 0;
                    }
                    summary[item.key] += 1;
                });
                for (const key in summary) {
                    const count = summary[key];
                    cli_shared_1.weblog.sendImmediately('CLICK', {
                        action: `REACT_NATIVE_BATCHED_BRIDGE_REGISTER`,
                        params: {
                            page: flags.bundleId,
                            versionCode: flags.version,
                            key,
                            count,
                        },
                    });
                    if (count > 1) {
                        utils_1.Logger.warn(`存在重复的 react-native/BatchedBridge 注册 Key: ${key}
代码位置: ${checkResult
                            .filter((item) => item.key === key)
                            .map((item) => item.filename)
                            .join(', ')}`);
                        // 后续需要抛出异常，并且给出文档链接
                    }
                }
            }
        }
        const config = {
            'react-native': ((_a = packageInfo.dependencies) === null || _a === void 0 ? void 0 : _a['react-native']) ||
                ((_b = packageInfo.peerDependencies) === null || _b === void 0 ? void 0 : _b['react-native']) ||
                ((_c = packageInfo.devDependencies) === null || _c === void 0 ? void 0 : _c['react-native']),
            framework: 'react',
            language: krnConfig.language,
            platform,
            bundleId,
            versionCode: version,
            version: `0.0.${version}`,
            md5: md5Str,
            bundleSize,
            frameworkBaseVersion: krnConfig.frameworkBaseVersion || '~0.0.1',
            componentNames,
        };
        utils_1.Logger.log(`bundle文件的md5值:`, md5Str);
        const metaFilePath = path.resolve(outputDirPath, 'meta.json');
        const manifestFilePath = path.resolve(outputDirPath, 'manifest.json');
        const manifest = {
            'resource.tex': md5Str,
        };
        await (0, utils_1.writeJsonFile)(manifestFilePath, manifest);
        await (0, utils_1.writeJsonFile)(metaFilePath, config);
        await fs.copyFile(bundleFilePath, `${internalPath}/${bundleId}_${md5Str}_${version}_${platform}.bundle`);
        // 复制 webpack 资源到 outputDirPath
        if (flags['use-webpack']) {
            await fs.copy(webpackAssetsDirPath, outputDirPath);
        }
        await fs.copy(outputDirPath, internalPath);
        await fs.copyFile(bundleFilePath, `${outputDirPath}/resource.tex`);
        utils_1.Logger.loading('压缩 internal 目录中');
        (0, utils_1.zip)({
            path: internalPath,
            destPath: internalPath + `/${bundleId}.zip`,
        });
        utils_1.Logger.loading('压缩 output 目录中');
        (0, utils_1.zip)({
            path: outputDirPath,
            destPath: outputDirPath + '/output.zip',
        });
        utils_1.Logger.loading('将bundle压缩并封装进png文件');
        const bundlePngFileName = `${platform}_${bundleId}_${md5Str}_${version}.png`;
        const productBundlePngPath = `${bundleDirPath}/${bundlePngFileName}`;
        await (0, utils_1.execAsync)(`cat ${tmpDirPath}/a.png ./output.zip >${productBundlePngPath}`, { cwd: outputDirPath });
        const pngMd5Str = md5(fs.readFileSync(productBundlePngPath));
        const cryPng = [];
        if (platform === 'ios') {
            // ios10 语法检测
            try {
                await (0, compat_grammar_check_1.default)({
                    filePath: bundleFilePath,
                    sourcemapPath: sourcemapPath,
                    ignoreRules: krnConfig.grammarCheckIngore || [],
                });
            }
            catch (err) {
                console.log(err);
                cli_shared_1.weblog.sendImmediately('CLICK', {
                    action: `IOSGrammar`,
                    params: {
                        page: bundleId,
                        error: err.message.split('\n').length - 2,
                        versionCode: version,
                        framework: 'KRN',
                    },
                });
            }
            try {
                // xor 加密产物
                const bundleXorPngFileName = `${platform}_${bundleId}_${md5Str}_${version}_cry1.png`;
                const productBundleXorPngPath = `${bundleDirPath}/${bundleXorPngFileName}`;
                const xorResult = (0, bundle_cipher_1.encrypt)({
                    type: bundle_cipher_1.EncryptType.XOR,
                    pngPath: productBundlePngPath,
                    bundleFileName: 'resource.tex',
                    output: {
                        pngPath: productBundleXorPngPath,
                    },
                });
                const cry1Png = {
                    cryType: bundle_cipher_1.EncryptType.XOR,
                    pngSize: xorResult.pngSize,
                    bundleSize: xorResult.bundleSize,
                    md5: xorResult.md5,
                    bundleFile: bundleXorPngFileName,
                };
                cryPng.push(cry1Png);
            }
            catch (error) {
                throw new Error(`生成 IOS 加密 png 产物失败: error`);
            }
        }
        utils_1.Logger.stop();
        const { size } = fs.statSync(productBundlePngPath);
        const fileSize = Math.round(size / 1024);
        utils_1.Logger.log('当前bundle大小:', fileSize + 'KB');
        if (fileSize > 500 && flags.dev !== 'true' && flags['ignore-size']) {
            throw new Error(`bundle大小不能超过500KB，请尝试: \n1. 将图片或者其他静态文件上传CDN。\n2. import第三方库时采用路径引用的方式，比如import merge from 'lodash/merge'。`);
        }
        const bundleConfigFilePath = path.resolve(bundleDirPath, 'config.json');
        await (0, utils_1.writeJsonFile)(bundleConfigFilePath, Object.assign(Object.assign(Object.assign({ pngSize: size }, config), (platform === 'ios' ? { cryPng } : {})), { bundleFile: bundlePngFileName }));
        utils_1.Logger.log('打包信息文件已生成:', path.relative(process.cwd(), bundleConfigFilePath));
        return {
            productBundlePngPath,
            md5Str,
            pngMd5Str,
            bundleConfigFilePath,
            bundleSize: size,
        };
    }
    async uploadProducts({ platform, bundleId, md5Str, version, productBundlePngPath, bundleDirPath, }) {
        const uploadCdn = async (src, text) => {
            utils_1.Logger.loading(text);
            const { stdout, stderr } = await (0, utils_1.execAsync)(`node \
                    ${utils_1.rootDir}/node_modules/.bin/kcdn-upload ${src} \
                    --cdn-dir ${bundleId} \
                    --pid KRN \
                    --token 10398_62ef3ba964d26fafd51b03a58f018566 \
                    --allow-rewrite \
                `);
            if (stderr) {
                utils_1.Logger.error(`${text}失败`);
                return Promise.reject(new Error(stderr));
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`${text}到CDN的结果:`);
            utils_1.Logger.log(stdout);
        };
        try {
            const logPath = `${bundleDirPath}/${platform}_${bundleId}_${md5Str}_${version}.txt`;
            const sourcemapPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.sourcemap.js.map`;
            await fs.rename(`${bundleDirPath}/${platform}_${bundleId}_${version}.txt`, logPath);
            await uploadCdn(productBundlePngPath, '上传bundle文件');
            await uploadCdn(logPath, '正在上传log文件');
            await uploadCdn(sourcemapPath, '正在上传sourcemap文件');
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async deployCDN({ platform, bundleId, version, productBundlePngPath, bundleFilePath, bundleDirPath, md5Str, }) {
        const uploadCdn = async (src, text) => {
            const dir = `kds-react-cli/deploy-test/${bundleId}/${platform}/${version}`;
            utils_1.Logger.loading(text);
            const { stdout, stderr } = await (0, utils_1.execAsync)(`node \
                    ${utils_1.rootDir}/node_modules/.bin/kcdn-upload ${src} \
                    --cdn-dir ${dir} \
                    --pid KDS \
                    --token 11256_bdc6bd128e75948dfae5291541ed6330 \
                    --allow-rewrite \
                `);
            if (stderr) {
                utils_1.Logger.error(`${text}失败`);
                return Promise.reject(new Error(stderr));
            }
            utils_1.Logger.stop();
            utils_1.Logger.log(`${text}到CDN的结果:`);
            utils_1.Logger.log(stdout);
            const filename = path.basename(src);
            return `https://s2-11256.kwimgs.com/kos/nlav11256/kds-react-cli/deploy-test/${bundleId}/${platform}/${version}/${filename}`;
        };
        const uploadAnalysis = async () => {
            const analysisHtmlPath = path.join(bundleDirPath, `analysis-${md5Str}.html`);
            const { stderr } = await (0, utils_1.execAsync)(`node \
                    ${binUp('source-map-explorer')} ${bundleFilePath} \
                    --html ${analysisHtmlPath}
                `);
            if (stderr && !stderr.includes('Unable to map')) {
                utils_1.Logger.error('生成依赖分析图失败', stderr);
                return Promise.reject(new Error(stderr));
            }
            const url = await uploadCdn(analysisHtmlPath, '上传依赖分析图');
            fs.unlinkSync(analysisHtmlPath);
            return url;
        };
        try {
            const sourcemapPath = `${bundleDirPath}/${platform}_${bundleId}_${version}.sourcemap.js.map`;
            const bundleCdnUrl = await uploadCdn(productBundlePngPath, '部署 bundle 文件');
            await uploadCdn(sourcemapPath, '部署 sourcemap 文件');
            let analysisHtmlUrl = '';
            try {
                analysisHtmlUrl = await uploadAnalysis();
            }
            catch (error) {
                utils_1.Logger.error('生成依赖分析图失败', error);
            }
            return {
                bundleCdnUrl,
                analysisHtmlUrl,
            };
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async runBuildBusinessBunlde() {
        var _a, _b;
        const flags = this.getFlags();
        const timestemp = Date.now();
        try {
            await this.runHook('prebuild');
            const businessParams = await this.ensureBusinessParams();
            const { outputDirPath, tmpDirPath, bundleDirPath, webpackAssetsDirPath, bundleId, version, platform, } = businessParams;
            const useWebpack = !!flags['use-webpack'];
            if (useWebpack && !this.isIntegratedWebpack()) {
                return Promise.reject(new Error('项目还未集成 webpack 打包，请按照 http://ksurl.cn/nrpRH57X 文档集成后开启 webpack 构建，如果项目已经集成过，请联系 lixuan12 处理'));
            }
            // 插入默认的 babel 插件
            await this.insertBabelConfig(businessParams);
            await this.buildBusinessBundle(businessParams);
            await this.runHook('prepack');
            const { productBundlePngPath, md5Str, bundleSize, bundleConfigFilePath, pngMd5Str, } = await this.handleBusinessBundle(businessParams);
            // 上传打包的产物
            if (flags.upload) {
                await this.uploadProducts(Object.assign(Object.assign({}, businessParams), { md5Str,
                    productBundlePngPath }));
            }
            // 部署到测试 CDN
            let deployResult = null;
            if (!(0, cli_shared_1.isCIEnvironment)() &&
                (flags.deploy || flags['deploy-scheme'])) {
                deployResult = await this.deployCDN(Object.assign(Object.assign({}, businessParams), { md5Str,
                    productBundlePngPath }));
            }
            // 上报打包信息
            await this.reportBuildInfo({
                start: timestemp,
                success: true,
                businessParams,
                bundleSize,
                bundleConfigFilePath,
            });
            await this.runHook('postbuild');
            // 删除临时的打包目录;
            fs.removeSync(outputDirPath);
            fs.removeSync(tmpDirPath);
            fs.removeSync(webpackAssetsDirPath);
            utils_1.Logger.log('打包目录位置:', bundleDirPath);
            if (deployResult) {
                // 生成预览二维码
                const { bundleCdnUrl, analysisHtmlUrl } = deployResult;
                const previewUrl = (((_a = flags['deploy-scheme']) === null || _a === void 0 ? void 0 : _a.trim()) ||
                    'kwai://krn?bundleId=$BUNDLE_ID&componentName=').replace('$BUNDLE_ID', bundleId);
                utils_1.Logger.success('自定义跳转参数:', previewUrl);
                const scheme = (_b = previewUrl.match(/^\w+?:\/\//)) !== null && _b !== void 0 ? _b : 'kwai://';
                qrcode.generate(`${scheme}kds/download/react?data=${JSON.stringify({
                    md5: md5Str,
                    zipMd5: pngMd5Str,
                    url: bundleCdnUrl,
                    bundleId,
                    rnVersion: '0.62.2',
                    version: `0.0.${version}`,
                    versionCode: isNaN(+version) ? version : +version,
                    scheme: encodeURIComponent(previewUrl),
                    platform,
                })}`, { small: true }, (code) => {
                    utils_1.Logger.log('扫描二维码进行预览:');
                    console.log(code);
                    utils_1.Logger.log('提示: IOS 需使用系统相机扫码');
                    utils_1.Logger.success('查看依赖分析：', analysisHtmlUrl);
                });
            }
        }
        catch (error) {
            await this.reportBuildInfo({
                start: timestemp,
                success: false,
            });
            return Promise.reject(error);
        }
    }
    async reportBuildInfo({ start, success, businessParams, bundleSize, bundleConfigFilePath, }) {
        const flags = this.getFlags();
        const isCI = (0, cli_shared_1.isCIEnvironment)();
        const existReactNativeDuplicateMsg = 'React Native 版本存在冲突，会导致包体积变大或无法正常运行，请参考 http://ksurl.cn/oHB93KHw 进行修复';
        try {
            if (isCI && flags.dev !== 'true') {
                const componentNames = await this.getRegisterComponentNames((businessParams === null || businessParams === void 0 ? void 0 : businessParams.entry) || '');
                const data = {
                    time: Date.now() - start,
                    page: flags.bundleId,
                    CLIVersion: this.config.version,
                    type: success ? 'SUCCESS' : 'FAILED',
                    versionCode: flags.version,
                    buildType: flags['use-webpack'] ? 'WEBPACK' : 'METRO',
                };
                if (data.type === 'SUCCESS') {
                    await new Promise((res) => setTimeout(res, 500));
                    const { packages, summary, kidComponents, } = await (0, bundle_stats_1.bundleStats)(Object.assign(Object.assign({}, businessParams), { bundleSize: bundleSize || 0 }));
                    const isExistReactNativeDuplicate = packages.some((item) => {
                        return (item.name === 'react-native' &&
                            (item.duplicateCount > 0 || item.value > 200000));
                    });
                    if (isExistReactNativeDuplicate) {
                        throw new Error(existReactNativeDuplicateMsg);
                    }
                    Object.assign(data, summary);
                    // 写进 config.json 中
                    if (bundleConfigFilePath) {
                        const config = await fs.readJSONSync(bundleConfigFilePath);
                        config.buildSummary = summary;
                        await (0, utils_1.writeJsonFile)(bundleConfigFilePath, config);
                    }
                    packages.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_PACKAGES`,
                            params: Object.assign({ page: flags.bundleId }, val),
                        });
                    });
                    kidComponents.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_KID_UI_COMPONENTS`,
                            params: Object.assign({ page: flags.bundleId }, val),
                        });
                    });
                }
                // 发送 KEEP_COMPONENT_NAMES
                if (componentNames.length) {
                    componentNames.forEach((val) => {
                        cli_shared_1.weblog.sendImmediately('CLICK', {
                            action: `KEEP_COMPONENT_NAMES`,
                            params: {
                                page: flags.bundleId,
                                versionCode: flags.version,
                                component: val,
                            },
                        });
                    });
                }
                // 发送 KEEP_BUILD信息
                cli_shared_1.weblog.sendImmediately('CLICK', {
                    action: `KEEP_BUILD`,
                    params: data,
                });
                utils_1.Logger.log('埋点打点上传...');
                await new Promise((res) => setTimeout(res, 10 * 1000));
                utils_1.Logger.log('埋点上传成功');
            }
        }
        catch (err) {
            console.log(err);
            if (((err === null || err === void 0 ? void 0 : err.toString()) || '').includes(existReactNativeDuplicateMsg)) {
                throw err;
            }
            utils_1.Logger.error('统计打包信息失败', err);
        }
    }
    async runHook(name) {
        const { hooks } = this.getKrnConfig();
        if (!hooks) {
            return;
        }
        const hook = hooks[name];
        if (!hook) {
            return;
        }
        const text = `执行钩子: ${name}，${hook}`;
        const exitError = `${text}，终止打包流程`;
        try {
            utils_1.Logger.log(text);
            await new Promise((resolve, reject) => {
                const cp = (0, child_process_1.spawn)(hook, [], {
                    shell: true,
                    stdio: 'inherit',
                });
                const closeHander = (code) => {
                    if (code === 33) {
                        reject(new Error(exitError));
                    }
                    else {
                        resolve();
                    }
                };
                cp.on('close', closeHander);
                cp.on('exit', closeHander);
            });
            utils_1.Logger.success(`${text}成功`);
        }
        catch (err) {
            const stderr = err.toString();
            if (stderr.includes(exitError)) {
                throw new Error(exitError);
            }
            utils_1.Logger.error(`${text}失败：`);
            utils_1.Logger.error(stderr);
        }
    }
    isAccurateTest() {
        const flags = this.getFlags();
        const krnConfig = this.getKrnConfig();
        return (flags['accurate-test-istanbul'] || !!krnConfig.accurateTestIstanbul);
    }
    isAutoTestId() {
        const flags = this.getFlags();
        const krnConfig = this.getKrnConfig();
        return flags['auto-test-id'] || !!krnConfig.autoTestId;
    }
    isNeedInsertBabelConfig() {
        return ((0, cli_shared_1.isCIEnvironment)() ||
            this.isAccurateTest() ||
            this.isAutoTestId() ||
            this.isEnableBatchedBridgeRegisterCheck());
    }
    isEnableBatchedBridgeRegisterCheck() {
        const krnConfig = this.getKrnConfig();
        return !krnConfig.ignoreBatchedBridgeRegisterCheck;
    }
    async insertBabelConfig(businessParams) {
        if (!this.isNeedInsertBabelConfig()) {
            return;
        }
        const flags = await this.getFlags();
        const { accurateTestDataFilePath, accurateTestCsvDataFilePath, bachedBridgeRegisterCheckFilePath, } = businessParams;
        const accurateTestPlugins = [
            [
                '@kds/istanbul',
                {
                    exclude: ['@kds/accurate-test-plugin/runtime'],
                    accurateTestOptions: {
                        bundleId: flags.bundleId,
                        platform: flags.platform,
                        dataFilePath: accurateTestDataFilePath,
                        csvDataFilePath: accurateTestCsvDataFilePath,
                    },
                },
            ],
        ];
        const ciPlugins = [
            [
                require.resolve('@krn/babel-plugin-react-native-usage-analyze'),
                Object.assign({}, this.getFlags()),
            ],
            [
                require.resolve('@krn/babel-plugin-kid-penetration-analyze'),
                Object.assign({}, this.getFlags()),
            ],
            [
                require.resolve('@krn/babel-plugin-package-analyze'),
                Object.assign({}, this.getFlags()),
            ],
        ];
        const buildPlugins = [
            [
                require.resolve('@krn/babel-plugin-react-native-get-component-names'),
                {
                    outputFilePath: businessParams.componentNamesJsonFilePath,
                },
            ],
        ];
        const prodPlugins = [...ciPlugins, ...buildPlugins];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const defaultPlugins = [];
        if (this.isAccurateTest()) {
            defaultPlugins.push(...accurateTestPlugins);
        }
        if (this.isAutoTestId()) {
            defaultPlugins.push([
                require.resolve('@krn/babel-plugin-auto-test-id'),
                Object.assign({}, this.getFlags()),
            ]);
        }
        if (this.isEnableBatchedBridgeRegisterCheck()) {
            defaultPlugins.push([
                require.resolve('@krn/babel-plugin-react-native-batch-bridge-register-check'),
                Object.assign(Object.assign({}, this.getFlags()), { outputFilePath: bachedBridgeRegisterCheckFilePath }),
            ]);
        }
        const babelConfigFilePath = path.resolve(process.cwd(), 'babel.config.js');
        if (!fs.existsSync(babelConfigFilePath)) {
            return;
        }
        const oldBabelConfigFilePath = path.resolve(process.cwd(), 'babel.config.old.js');
        if (fs.existsSync(oldBabelConfigFilePath)) {
            return;
        }
        fs.copySync(babelConfigFilePath, oldBabelConfigFilePath);
        const newBabelConfigContent = `const oldConfig = require('${oldBabelConfigFilePath}');
const productionPlugins = ${JSON.stringify(prodPlugins)};
const defaultPlugins = ${JSON.stringify(defaultPlugins)};
if (!oldConfig.env) {
    oldConfig.env = {};
}
if (!oldConfig.env.production) {
    oldConfig.env.production = {};
}
if (!oldConfig.env.production.plugins) {
    oldConfig.env.production.plugins = [];
}
oldConfig.env.production.plugins = [
    ...productionPlugins,
    ...oldConfig.env.production.plugins
];
if (!oldConfig.plugins) {
    oldConfig.plugins = [];
}
oldConfig.plugins = [
    ...defaultPlugins,
    ...oldConfig.plugins
];
module.exports = oldConfig;
`;
        fs.writeFileSync(babelConfigFilePath, newBabelConfigContent);
    }
    restoreBabelConfig() {
        if (!this.isNeedInsertBabelConfig()) {
            return;
        }
        const oldBabelConfigFilePath = path.resolve(process.cwd(), 'babel.config.old.js');
        if (!fs.existsSync(oldBabelConfigFilePath)) {
            return;
        }
        const babelConfigFilePath = path.resolve(process.cwd(), 'babel.config.js');
        fs.copySync(oldBabelConfigFilePath, babelConfigFilePath);
        fs.removeSync(oldBabelConfigFilePath);
    }
    isIntegratedWebpack() {
        const isExistBabelWebpackConfig = fs.existsSync(path.resolve('babel-webpack.config.js'));
        if (isExistBabelWebpackConfig) {
            return true;
        }
        const isExistWebpackConfig = fs.existsSync(path.resolve('webpack.config.js'));
        if (isExistWebpackConfig) {
            return true;
        }
        const babelConfigFilePath = path.resolve('babel.config.js');
        if (fs.existsSync(babelConfigFilePath)) {
            const babelConfigContent = fs.readFileSync(babelConfigFilePath, {
                encoding: 'utf-8',
            });
            return babelConfigContent.includes('disableImportExportTransform'); // 手动指定了这个选项，说明自己集成了 webpack 打包
        }
        return false;
    }
    async run() {
        var _a;
        try {
            await super.run();
            await (0, patch_1.default)();
            await this.runBuildBusinessBunlde();
            const currentFlags = this.getFlags();
            this.runAnalytics(Object.assign(Object.assign({ id: this.id }, currentFlags), { page: currentFlags.bundleId, CLIVersion: this.config.version }));
            // 恢复 babel 配置为之前的
            this.restoreBabelConfig();
        }
        catch (error) {
            utils_1.Logger.stop();
            utils_1.Logger.log('Oops~打包失败');
            this.restoreBabelConfig();
            await (0, utils_1.diagnoseWithBuildErrorMessage)(((_a = error === null || error === void 0 ? void 0 : error.toString) === null || _a === void 0 ? void 0 : _a.call(error)) || '');
            await this.runHook('failbuild');
            utils_1.Logger.error(error);
            process.exit(1);
        }
    }
}
exports.default = Build;
Build.hidden = false;
Build.description = '打包命令';
Build.examples = [
    `krn build --bundleId=Demo --dev=true --platform=ios --version=1 --upload`,
];
Build.flags = Object.assign({ version: command_1.flags.integer({
        char: 'v',
        helpValue: '1',
        description: '版本号',
        default: 0,
        required: true,
    }), bundleId: command_1.flags.string({
        char: 'b',
        helpValue: 'Demo',
        description: 'BundleId',
        default: '',
        required: true,
    }), upload: command_1.flags.boolean({
        char: 'u',
        description: '是否上传bundle',
        default: false,
    }), 'ignore-size': command_1.flags.boolean({
        char: 'i',
        description: '是否忽略文件体积的限制',
        default: false,
    }) }, RNCliFlags);
