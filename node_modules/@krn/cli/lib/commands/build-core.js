"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const child_process_1 = require("child_process");
const command_1 = require("@oclif/command");
const fs = require("fs-extra");
const md5 = require("md5");
const utils_1 = require("../utils");
const patch_1 = require("../patch");
const command_2 = require("./command");
var BUILD_PLATFORM;
(function (BUILD_PLATFORM) {
    BUILD_PLATFORM["IOS"] = "ios";
    BUILD_PLATFORM["ANDROID"] = "android";
})(BUILD_PLATFORM || (BUILD_PLATFORM = {}));
const RNCliFlags = {
    dev: command_1.flags.string({
        char: 'd',
        helpValue: 'true',
        description: 'ÊâìDEBUGÂåÖ',
        default: 'false',
    }),
    minify: command_1.flags.string({
        helpValue: 'true',
        description: 'ÊòØÂê¶ÂéãÁº©bundle',
        default: 'true',
    }),
};
class BuildCore extends command_2.default {
    getFlags() {
        const { flags } = this.parse(BuildCore);
        return flags;
    }
    getBuildBundleParams(platform) {
        const productsPath = path.resolve(process.cwd(), `./lib/${platform}`);
        const bundlePath = path.resolve(productsPath);
        const logPath = path.resolve(bundlePath, './bundle.txt');
        const assetsPath = path.resolve(productsPath, 'assets');
        const sourcemapPath = `${bundlePath}/platform.${platform}.bundle.sourcemap.js.map`;
        const outputFilePath = path.resolve(bundlePath, `./platform.${platform}.bundle`);
        return {
            productsPath,
            bundlePath,
            logPath,
            assetsPath,
            outputFilePath,
            sourcemapPath,
        };
    }
    async runBuildPlatformBundle(platform) {
        const { bundlePath, logPath, assetsPath, outputFilePath, sourcemapPath, } = this.getBuildBundleParams(platform);
        const flags = this.getFlags();
        const reactNativeCliPath = (0, utils_1.getReactNativeCLI)();
        const entryFilePath = path.resolve(process.cwd(), flags.entry);
        const projectRoot = process.cwd();
        if (!fs.existsSync(reactNativeCliPath)) {
            return Promise.reject(new Error('ËØ∑Á°ÆËÆ§Â∑≤ÂÆâË£Ö‰æùËµñ'));
        }
        if (!fs.existsSync(entryFilePath)) {
            return Promise.reject(new Error('Entry file not found.'));
        }
        (0, utils_1.rmAndMkdir)(bundlePath);
        utils_1.Logger.loading(`üöÄüöÄüöÄ ÂºÄÂßãÊâì ${platform} Âü∫Á°ÄÂåÖ`);
        try {
            const buildInChildProcess = () => {
                return new Promise((resolve, reject) => {
                    var _a, _b;
                    const minify = flags.dev === 'true' ? 'false' : flags.minify;
                    const cliArgs = [
                        reactNativeCliPath,
                        'bundle',
                        '--dev',
                        flags.dev,
                        '--minify',
                        minify,
                        '--reset-cache',
                        '--entry-file',
                        entryFilePath,
                        '--sourcemap-output',
                        sourcemapPath,
                        '--config',
                        require.resolve('@krn/metro-config'),
                        '--platform',
                        platform,
                        '--bundle-output',
                        outputFilePath,
                        '--assets-dest',
                        assetsPath,
                    ];
                    utils_1.Logger.log('ÊâìÂåÖÂèÇÊï∞:', ...cliArgs.slice(1, cliArgs.length));
                    process.env.KRN_PROJECT_ROOT = process.cwd();
                    process.env.KRN_PACKAGE_MANAGER = (0, utils_1.getPackageManager)(projectRoot);
                    const childProcess = (0, child_process_1.spawn)('node', cliArgs, {
                        env: Object.assign({ KRN_ENV: 'CORE' }, process.env),
                    });
                    const writeStream = fs.createWriteStream(logPath);
                    (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(writeStream);
                    (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.pipe(writeStream);
                    childProcess.on('close', () => {
                        writeStream === null || writeStream === void 0 ? void 0 : writeStream.close();
                    });
                    childProcess.on('error', reject);
                    childProcess.on('close', (code) => {
                        if (code === 0) {
                            resolve();
                        }
                        else {
                            reject();
                        }
                    });
                });
            };
            await buildInChildProcess();
            if (flags['verbose']) {
                utils_1.Logger.log(fs.readFileSync(logPath).toString());
            }
            const outputFile = fs.readFileSync(outputFilePath);
            const md5String = md5(outputFile);
            const filePath = `lib/${platform}/platform.${platform}.bundle`;
            utils_1.Logger.stop();
            utils_1.Logger.log('Âü∫Á°ÄÂåÖÁöÑmd5:', md5String, 'Ë∑ØÂæÑÂú∞ÂùÄ: ', filePath);
            utils_1.Logger.log(`${platform}Âü∫Á°ÄÂåÖÂ∑≤ÂÆåÊàêÊâìÂåÖ`);
        }
        catch (error) {
            utils_1.Logger.stop();
            return Promise.reject(error || new Error(fs.readFileSync(logPath).toString()));
        }
    }
    async runBuildPlatformBundleAndDependencies() {
        try {
            const flags = this.getFlags();
            const productPath = path.resolve(`lib`);
            if (fs.existsSync(productPath)) {
                fs.removeSync(productPath);
            }
            await this.runBuildPlatformBundle(BUILD_PLATFORM.IOS);
            await this.runBuildPlatformBundle(BUILD_PLATFORM.ANDROID);
            const { logPath: androidLogPath } = this.getBuildBundleParams(BUILD_PLATFORM.ANDROID);
            const { logPath: iosLogPath } = this.getBuildBundleParams(BUILD_PLATFORM.IOS);
            let std = '';
            std += (await fs.readFile(androidLogPath)).toString();
            std += (await fs.readFile(iosLogPath)).toString();
            const stdMatched = std.match(/(?<=\[core\sdependencies\]:\s)node_modules(.*)(?!=\n)/g);
            if (stdMatched) {
                // iosÂíåandroid‰æùËµñÂéªÈáç
                const stdMatchedFilter = [...new Set(stdMatched)];
                const coreDependenciesPath = flags['dependencies-dest']
                    ? path.resolve(flags['dependencies-dest'], './core-dependencies.json')
                    : path.resolve(`lib/bundle-dependencies`, `./core-dependencies.json`);
                if (fs.existsSync(coreDependenciesPath)) {
                    fs.removeSync(coreDependenciesPath);
                }
                if (!fs.existsSync(path.dirname(coreDependenciesPath))) {
                    fs.mkdirpSync(path.dirname(coreDependenciesPath));
                }
                fs.writeFileSync(coreDependenciesPath, JSON.stringify(Array.from(stdMatchedFilter)));
                utils_1.Logger.log('Âü∫Á°ÄÂåÖ‰æùËµñÂàÜÊûêÂÆåÊàê:', coreDependenciesPath);
            }
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async run() {
        try {
            const flags = this.getFlags();
            await super.run();
            await (0, patch_1.default)();
            await this.runBuildPlatformBundleAndDependencies();
            this.runAnalytics(Object.assign(Object.assign({ id: this.id }, flags), { CLIVersion: this.config.version, page: 'react.platform' }));
        }
        catch (error) {
            utils_1.Logger.stop();
            utils_1.Logger.log('Oops~ÊâìÂåÖÂ§±Ë¥•');
            return Promise.reject(error);
        }
    }
}
exports.default = BuildCore;
BuildCore.description = 'ÊâìÂü∫Á°ÄÂåÖÂëΩ‰ª§';
BuildCore.examples = [`krn build-core --platform=ios`];
BuildCore.flags = Object.assign({ verbose: command_1.flags.boolean({
        description: 'ÊòØÂê¶ËæìÂá∫ÊâìÂåÖÊó•Âøó',
        default: false,
    }), entry: command_1.flags.string({
        char: 'e',
        helpValue: './index.js',
        description: 'ÊâìÂåÖÂÖ•Âè£',
        default: './index.js',
    }), 'dependencies-dest': command_1.flags.string({
        description: '‰æùËµñÂàÜÊûêjsonËæìÂá∫ÁöÑ‰ΩçÁΩÆ',
        default: '',
    }) }, RNCliFlags);
