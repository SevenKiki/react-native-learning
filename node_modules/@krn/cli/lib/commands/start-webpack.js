"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const path = require("path");
const inquirer = require("inquirer");
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
const fs = require("fs-extra");
const patch_1 = require("../patch");
const command_2 = require("./command");
const cross_port_killer_1 = require("cross-port-killer");
const start_1 = require("@krn/repack/dist/commands/start");
const cacheManager = require('../webpack-config/development/cache-manager');
class StartWebpack extends command_2.default {
    constructor() {
        super(...arguments);
        this.devtoolsEnabled = false;
    }
    getFlags() {
        const { flags } = this.parse(StartWebpack);
        return flags;
    }
    async selectBundleId(bundleIds) {
        const responses = await inquirer.prompt({
            name: 'bundleId',
            message: '请选择需要调试的Bundle',
            type: 'list',
            choices: bundleIds.map((bundleId) => {
                return {
                    name: bundleId,
                };
            }),
        });
        return responses.bundleId;
    }
    async selectRegisterComponent(registerComponents) {
        const responses = await inquirer.prompt({
            name: 'registerComponent',
            message: '请选择需要调试的Appkey',
            type: 'list',
            choices: registerComponents.map((registerComponent) => {
                return {
                    name: registerComponent,
                };
            }),
        });
        return responses.registerComponent;
    }
    async selectCurrentIp(ipList) {
        const responses = await inquirer.prompt({
            name: 'ip',
            message: '请选择当前的IP',
            type: 'list',
            choices: ipList,
        });
        return responses.ip;
    }
    async getEntry(bundId, entry) {
        const { entry: entryFlag } = this.getFlags();
        if (entryFlag) {
            return entryFlag;
        }
        if ((0, lodash_1.isString)(entry)) {
            return entry;
        }
        else if ((0, lodash_1.isPlainObject)(entry) && entry) {
            return entry[bundId];
        }
        return '';
    }
    async getBundleId(entry) {
        const { bundleId: bundleIdFlag } = this.getFlags();
        if (bundleIdFlag) {
            return bundleIdFlag;
        }
        if (entry && (0, lodash_1.isPlainObject)(entry)) {
            // 多入口的情况
            const entryKeys = Object.keys(entry);
            if (entryKeys.length > 1) {
                return await this.selectBundleId(entryKeys);
            }
            else if (entryKeys.length === 1) {
                return entryKeys[0];
            }
        }
        return 'DEBUG_BUNDLE';
    }
    async getRegisterComponentName(entry) {
        if (entry) {
            const { name } = this.getFlags();
            const entryFile = fs.readFileSync(entry).toString();
            // 如果能提取到registerComponent，就可以方便生成二维码
            const registerComponents = entryFile.match(/(?<=AppRegistry\.registerComponent\((\n|\r|\s)*?('|")).*?(?=('|"))/g) || [];
            if (name) {
                return name;
            }
            else if (registerComponents.length >= 2) {
                return this.selectRegisterComponent(registerComponents);
            }
            else if (registerComponents.length === 1) {
                return registerComponents[0];
            }
        }
        utils_1.Logger.warn([
            '提取AppKey失败，无法生成二维码，可能原因如下:',
            " 1. AppKey不是一个静态字符串，请修改为AppRegistry.registerComponent('foo', ...)",
            ' 2. 确认entry入口文件是否存在',
        ].join('\n'));
    }
    getSchemeUrl({ bundleId, scheme, componentName, schemeParams = '', schemeTemplate, }) {
        var _a;
        if (schemeTemplate) {
            return schemeTemplate;
        }
        if (scheme) {
            // 只使用xx://协议的，自动补充krn，否则直接使用即可
            const _scheme = /.*\/\/$/.test(scheme) ? scheme + 'krn' : scheme;
            let schemeUrl = `${_scheme}?bundleId=${bundleId}&debugMode=1`;
            let schemeParamsStr = '';
            if (componentName) {
                schemeUrl += `&componentName=${componentName}`;
            }
            if ((0, lodash_1.isString)(schemeParams)) {
                schemeParamsStr = schemeParams;
            }
            else if ((0, lodash_1.isPlainObject)(schemeParams) && componentName) {
                schemeParamsStr = (_a = schemeParams[componentName]) !== null && _a !== void 0 ? _a : '';
            }
            if (schemeParamsStr) {
                schemeUrl += `&${schemeParamsStr}`;
            }
            return schemeUrl;
        }
        utils_1.Logger.warn([
            '获取Scheme失败，无法生成二维码，可能原因如下:',
            ' 1. `krn.config.json`未设置scheme，例如"scheme": "kwai://"',
            ' 2. `krn.config.json`未设置 schemeTemplate ，例如"schemeTemplate": "kwai://krn?bundleId=$BUNDLE_ID&debugMode=1&componentName=$COMPONENT_NAME&debugServer=$DEBUG_SERVER"',
        ].join('\n'));
        return '';
    }
    getKrnConfig() {
        try {
            const krnConfigPath = path.resolve('./krn.config.json');
            return fs.readJSONSync(krnConfigPath);
        }
        catch (error) {
            return {};
        }
    }
    async runStart() {
        const flags = this.getFlags();
        const krnConfig = this.getKrnConfig();
        const bundleId = await this.getBundleId(krnConfig.entry);
        const entry = await this.getEntry(bundleId, krnConfig.entry);
        const componentName = await this.getRegisterComponentName(entry);
        const checkGlobal = flags['no-check-global'] ? false : true;
        const ipList = (0, utils_1.getIPAddress)();
        const ip = flags.ip
            ? flags.ip
            : ipList.length > 1
                ? await this.selectCurrentIp(ipList)
                : ipList[0];
        const schemeUrl = this.getSchemeUrl({
            bundleId,
            componentName,
            scheme: krnConfig.scheme,
            schemeParams: krnConfig.schemeParams,
            schemeTemplate: krnConfig.schemeTemplate,
        });
        const TermialReporter = require(path.resolve(__dirname, '../patch/metro/src/lib/TerminalReporter.js'));
        const reactNativeCliPath = (0, utils_1.getReactNativeCLI)();
        const projectRoot = process.cwd();
        if (!fs.existsSync(reactNativeCliPath)) {
            return Promise.reject(new Error('请确认已安装依赖'));
        }
        // 检查新版本
        await (0, utils_1.checkNewVersion)();
        // 安装 klp 流水线工具
        if (!flags['disable-klp']) {
            (0, utils_1.installKlp)();
        }
        (0, utils_1.disableCheckUpdateReactNative)(process.cwd());
        const isDevtoolsEnabled = this.devtoolsEnabled || flags.debug ? 'enabled' : '';
        process.env.KRN_ENV = 'DEBUG';
        process.env.KRN_BUILD_TYPE = 'WEBPACK';
        process.env.KRN_DEV_BUNDLE_ID = bundleId;
        process.env.KRN_DEV_COMPONENT_NAME = componentName;
        process.env.KRN_CLI_VERSION = this.config.version;
        process.env.KRN_CHECK_GLOBAL_ENABLED = checkGlobal ? 'enabled' : '';
        process.env.KRN_DEVTOOLS_ENABLED = isDevtoolsEnabled;
        process.env.KRN_PROJECT_ROOT = process.cwd();
        process.env.KRN_PACKAGE_MANAGER = (0, utils_1.getPackageManager)(projectRoot);
        process.env.KRN_ENTRY = entry;
        process.env.KRN_CONFIG_PATH =
            flags.config || path.resolve('./webpack.config.js');
        let port = 8081;
        if (flags.port) {
            port = flags.port;
            process.env.KRN_PORT = port;
        }
        this.runAnalytics(Object.assign(Object.assign({ id: this.id }, flags), { page: bundleId, CLIVersion: this.config.version }));
        // 强制杀死已存在的进程
        if (flags.force) {
            const pids = await (0, cross_port_killer_1.kill)(port);
            if (pids.length) {
                utils_1.Logger.warn(`开启强制启动，已杀死占用端口: ${port} 的进程: ${pids.join(',')}`);
            }
        }
        try {
            process.env.KRN_ENV = 'DEBUG';
            process.env.KRN_SCHEME_NAME = krnConfig.scheme || '';
            process.env.KRN_SCHEME_URL = schemeUrl || '';
            process.env.KRN_SCHEME_TEMPLATE = krnConfig.schemeTemplate || '';
            process.env.KRN_SCHEME_EXTRA_PARAMS = (0, lodash_1.isString)(krnConfig.schemeParams)
                ? krnConfig.schemeParams
                : (0, lodash_1.isPlainObject)(krnConfig.schemeParams)
                    ? krnConfig.schemeParams[componentName || 'unknown']
                    : '';
            process.env.KRN_IP = ip || '';
            process.env.KRN_DEVTOOLS_ENABLED = isDevtoolsEnabled || '';
            const terminalReporter = new TermialReporter(console);
            if (flags['reset-cache']) {
                cacheManager.reset();
                utils_1.Logger.warn('已清除构建缓存！');
            }
            await (0, start_1.start)([], {
                root: projectRoot,
                reactNativePath: path.dirname(require.resolve('react-native', {
                    paths: [projectRoot],
                })),
                entry,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }, Object.assign(Object.assign({}, flags), { webpackConfig: path.resolve(__dirname, '../webpack-config/development/index.config.js'), platform: '', host: ip, port: +port, interactive: true }));
            // 先临时调用原来的 reporter 打印日志
            terminalReporter._logInitializing(port);
        }
        catch (error) {
            const stderr = error.toString();
            utils_1.Logger.error(`Server Error: ${stderr}.`);
        }
    }
    async run() {
        try {
            await super.run();
            await (0, patch_1.default)();
            await this.runStart();
        }
        catch (error) {
            utils_1.Logger.log('Oops~启动失败');
            return Promise.reject(error);
        }
    }
}
exports.default = StartWebpack;
StartWebpack.hidden = false;
StartWebpack.description = '使用 webpack 调试模式';
StartWebpack.examples = [`krn start-webpack`];
StartWebpack.flags = {
    name: command_1.flags.string({
        char: 'n',
        helpValue: 'Demo',
        description: 'registerComponent name',
    }),
    bundleId: command_1.flags.string({
        char: 'b',
        helpValue: 'Demo',
        description: 'BundleId',
    }),
    entry: command_1.flags.string({
        char: 'e',
        helpValue: './index.ts',
        description: 'entryFile',
    }),
    config: command_1.flags.string({
        helpValue: './webpack.config.js',
        description: 'CLI configuration file',
        default: '',
    }),
    'reset-cache': command_1.flags.boolean({
        char: 'r',
        description: '是否清除打包缓存',
        default: false,
    }),
    debug: command_1.flags.boolean({
        description: '开启debug调试',
        default: false,
    }),
    force: command_1.flags.boolean({
        char: 'f',
        description: '强制启动，如果启动端口被占用，会杀死占用端口的进程',
        default: false,
    }),
    'no-check-global': command_1.flags.boolean({
        description: '禁用global变量检测',
        default: false,
    }),
    'disable-klp': command_1.flags.boolean({
        description: '禁止安装klp工具',
        default: false,
    }),
    port: command_1.flags.string({
        char: 'p',
        helpValue: '8081',
        description: '端口号',
    }),
    ip: command_1.flags.string({
        description: 'IP地址',
        helpValue: '127.0.0.1',
    }),
};
