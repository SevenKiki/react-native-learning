"use strict";
const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const { merge } = require('webpack-merge');
const cacheManager = require('./cache-manager');
const webpackConfigPath = process.env.KRN_CONFIG_PATH;
const webpackBabelConfigPath = path.resolve('babel-webpack.config.js');
const oldBabelConfigPath = path.resolve('babel.config.js');
const customConfig = () => {
    try {
        return require(webpackConfigPath);
    }
    catch (err) {
        return {};
    }
};
const requirePath = (name) => {
    try {
        return require.resolve(name, {
            paths: [__dirname],
        });
    }
    catch (err) {
        return undefined;
    }
};
const bridgeHookScriptPath = requirePath('@krn/metro-config/dist/bridge-hook');
const devtoolsConnectScriptPath = requirePath('@krn/metro-config/dist/devtools-connect');
const rnPatchScriptPath = requirePath('@krn/metro-config/dist/rn-patch');
const checkGlobalScriptPath = requirePath('@krn/metro-config/dist/check-global');
// 获取注入的入口模块
const getPreloadModules = () => {
    const preloadModules = [rnPatchScriptPath];
    const isDevtoolsEnabled = process.env.KRN_DEVTOOLS_ENABLED === 'enabled';
    const isCheckGlobalEnabled = process.env.KRN_CHECK_GLOBAL_ENABLED === 'enabled';
    if (isCheckGlobalEnabled) {
        preloadModules.push(checkGlobalScriptPath);
    }
    if (isDevtoolsEnabled) {
        preloadModules.push(devtoolsConnectScriptPath);
    }
    return preloadModules.filter(Boolean);
};
const TerserPlugin = require('terser-webpack-plugin');
const Repack = require('@krn/repack');
const BridgeHookModulePlugin = require('./bridge-hook-plugin');
/**
 * More documentation, installation, usage, motivation and differences with Metro is available at:
 * https://github.com/callstack/repack/blob/main/README.md
 *
 * The API documentation for the functions and plugins used in this file is available at:
 * https://re-pack.netlify.app/
 */
/**
 * Webpack configuration.
 * You can also export a static object or a function returning a Promise.
 *
 * @param env Environment options passed from either Webpack CLI or React Native CLI
 *            when running with `react-native start/bundle`.
 */
module.exports = (env) => {
    const { mode = 'development', context = __dirname, entry = process.env.KRN_ENTRY, platform, minimize = mode === 'production', devServer = undefined, bundleFilename = undefined, sourceMapFilename = undefined, assetsPath = undefined, reactNativePath, } = env;
    const bundleId = process.env.KRN_DEV_BUNDLE_ID;
    if (!platform) {
        throw new Error('Missing platform');
    }
    process.env.BABEL_ENV = mode;
    process.env.NODE_ENV = mode;
    // 获取 babel 配置，并克隆
    const oldBabelConfig = _.cloneDeep(fs.existsSync(oldBabelConfigPath) ? require(oldBabelConfigPath) : {});
    cacheManager.init();
    /**
     * Using Module Federation might require disabling hmr.
     * Uncomment below to set `devServer.hmr` to `false`.
     *
     * Keep in mind that `devServer` object is not available
     * when running `webpack-bundle` command. Be sure
     * to check its value to avoid accessing undefined value,
     * otherwise an error might occur.
     */
    // if (devServer) {
    //   devServer.hmr = false;
    // }
    return merge({
        mode,
        /**
         * This should be always `false`, since the Source Map configuration is done
         * by `SourceMapDevToolPlugin`.
         */
        devtool: 'source-map',
        context,
        /**
         * `getInitializationEntries` will return necessary entries with setup and initialization code.
         * If you don't want to use Hot Module Replacement, set `hmr` option to `false`. By default,
         * HMR will be enabled in development mode.
         */
        entry: [
            bridgeHookScriptPath,
            ...Repack.getInitializationEntries(reactNativePath, {
                hmr: devServer && devServer.hmr,
            }),
            ...getPreloadModules(),
            entry,
        ],
        resolve: {
            /**
             * `getResolveOptions` returns additional resolution configuration for React Native.
             * If it's removed, you won't be able to use `<file>.<platform>.<ext>` (eg: `file.ios.js`)
             * convention and some 3rd-party libraries that specify `react-native` field
             * in their `package.json` might not work correctly.
             */
            mainFields: ['react-native', 'browser', 'module', 'main'],
            aliasFields: ['react-native', 'browser', 'module', 'main'],
            extensions: [
                `.${platform}.js`,
                `.${platform}.jsx`,
                `.${platform}.ts`,
                `.${platform}.tsx`,
                '.native.js',
                '.native.jsx',
                '.native.ts',
                '.native.tsx',
                '.js',
                '.jsx',
                '.ts',
                '.tsx',
            ],
            /**
             * Uncomment this to ensure all `react-native*` imports will resolve to the same React Native
             * dependency. You might need it when using workspaces/monorepos or unconventional project
             * structure. For simple/typical project you won't need it.
             */
            alias: {
                'react-native': reactNativePath,
            },
        },
        /**
         * Configures output.
         * It's recommended to leave it as it is unless you know what you're doing.
         * By default Webpack will emit files into the directory specified under `path`. In order for the
         * React Native app use them when bundling the `.ipa`/`.apk`, they need to be copied over with
         * `Repack.OutputPlugin`, which is configured by default inside `Repack.RepackPlugin`.
         */
        output: {
            clean: true,
            path: path.join(__dirname, 'build/generated', platform),
            filename: 'index.bundle',
            chunkFilename: '[name].chunk.bundle',
            publicPath: Repack.getPublicPath({ platform, devServer }),
        },
        /**
         * Configures optimization of the built bundle.
         */
        optimization: {
            /** Enables minification based on values passed from React Native CLI or from fallback. */
            minimize,
            /** Configure minimizer to process the bundle. */
            minimizer: [
                new TerserPlugin({
                    test: /\.(js)?bundle(\?.*)?$/i,
                    /**
                     * Prevents emitting text file with comments, licenses etc.
                     * If you want to gather in-file licenses, feel free to remove this line or configure it
                     * differently.
                     */
                    extractComments: false,
                    terserOptions: {
                        format: {
                            comments: false,
                        },
                    },
                }),
            ],
            chunkIds: 'named',
        },
        module: {
            /**
             * This rule will process all React Native related dependencies with Babel.
             * If you have a 3rd-party dependency that you need to transpile, you can add it to the
             * `include` list.
             *
             * You can also enable persistent caching with `cacheDirectory` - please refer to:
             * https://github.com/babel/babel-loader#options
             */
            unknownContextCritical: false,
            rules: [
                /**
                 * Here you can adjust loader that will process your files.
                 *
                 * You can also enable persistent caching with `cacheDirectory` - please refer to:
                 * https://github.com/babel/babel-loader#options
                 */
                // 编译项目中的 js/ts/jsx/tsx，走 tree shaking，走新的 babel config
                {
                    test: /\.m?[jt]sx?$/,
                    exclude: /node_modules/,
                    use: {
                        loader: require.resolve('babel-loader', {
                            paths: [__dirname],
                        }),
                        options: Object.assign({ 
                            /** Add React Refresh transform only when HMR is enabled. */
                            plugins: devServer && devServer.hmr
                                ? [
                                    require.resolve('react-refresh/babel', {
                                        paths: [__dirname],
                                    }),
                                ]
                                : undefined }, (fs.existsSync(webpackBabelConfigPath)
                            ? {
                                babelrc: false,
                                configFile: webpackBabelConfigPath,
                            }
                            : {})),
                    },
                },
                // 编译 node_modules 中除 react-native 的其他模块，走 tree shaking，走新的 babel config
                {
                    test: /\.m?[jt]sx?$/,
                    include: [/node_modules\/(?!react-native\/)/],
                    use: {
                        loader: require.resolve('babel-loader', {
                            paths: [__dirname],
                        }),
                        options: Object.assign(Object.assign({}, (fs.existsSync(webpackBabelConfigPath)
                            ? {
                                babelrc: false,
                                configFile: webpackBabelConfigPath,
                            }
                            : {})), { sourceType: 'unambiguous' }),
                    },
                },
                // 编译 react-native，不走 tree shaking，走原来老的 babel config
                {
                    test: /\.m?[jt]sx?$/,
                    include: [/node_modules\/(react-native)\//],
                    use: {
                        loader: require.resolve('babel-loader', {
                            paths: [__dirname],
                        }),
                        options: Object.assign({ babelrc: false }, oldBabelConfig),
                    },
                },
                /**
                 * This loader handles all static assets (images, video, audio and others), so that you can
                 * use (reference) them inside your application.
                 *
                 * If you wan to handle specific asset type manually, filter out the extension
                 * from `ASSET_EXTENSIONS`, for example:
                 * ```
                 * Repack.ASSET_EXTENSIONS.filter((ext) => ext !== 'svg')
                 * ```
                 */
                {
                    test: Repack.getAssetExtensionsRegExp(Repack.ASSET_EXTENSIONS),
                    use: {
                        loader: require.resolve('@krn/repack/assets-loader', {
                            paths: [__dirname],
                        }),
                        options: {
                            platform,
                            devServerEnabled: Boolean(devServer),
                            /**
                             * Defines which assets are scalable - which assets can have
                             * scale suffixes: `@1x`, `@2x` and so on.
                             * By default all images are scalable.
                             */
                            scalableAssetExtensions: Repack.SCALABLE_ASSETS,
                        },
                    },
                },
            ],
        },
        plugins: [
            /**
             * Configure other required and additional plugins to make the bundle
             * work in React Native and provide good development experience with
             * sensible defaults.
             *
             * `Repack.RepackPlugin` provides some degree of customization, but if you
             * need more control, you can replace `Repack.RepackPlugin` with plugins
             * from `Repack.plugins`.
             */
            new Repack.RepackPlugin({
                context,
                mode,
                platform,
                devServer,
                output: {
                    bundleFilename,
                    sourceMapFilename,
                    assetsPath,
                },
            }),
            new BridgeHookModulePlugin(),
        ],
        cache: {
            type: 'filesystem',
            cacheDirectory: cacheManager.getCacheDir(),
            name: `${bundleId || 'default'}-${platform}-${mode}`,
            version: cacheManager.getCacheVersion(),
        },
    }, customConfig());
};
