"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleStats = void 0;
const cli_shared_1 = require("@krn/cli-shared");
const index_1 = require("./index");
const fs = require("fs-extra");
const glob = require("glob");
const path = require("path");
const resolvePackages = async (sourcemapPath, bundleFilePath, baseDir) => {
    try {
        const sourceMapExplorer = path.resolve(index_1.rootDir, './node_modules/.bin/source-map-explorer');
        const statsJsonPath = path.join(baseDir, '__stats__.json');
        await (0, index_1.spawnAsync)('node', [
            sourceMapExplorer,
            bundleFilePath,
            sourcemapPath,
            '--json',
            statsJsonPath,
        ], {});
        const modules = {};
        const kidComponentsResult = new Map();
        const result = new Map();
        const nestedResult = new Map();
        const { results: [parseResult], } = fs.readJSONSync(statsJsonPath);
        const { files } = parseResult || { files: {} };
        for (const filePath in files) {
            const file = files[filePath];
            const [packageName, ...nestedPackageNames] = filePath.match(/(?<=node_modules\/)(@[^\/]+\/[^\/]+|[^\/]+)/g) || [];
            const isSourceFile = /\.(js|ts)x?$/.test(filePath);
            if (!isSourceFile) {
                continue;
            }
            // 匹配源代码文件
            const moduleMatch = filePath.match(/(?<=\/)src\/.+$/);
            if (!packageName && moduleMatch && moduleMatch[0]) {
                const modulePath = moduleMatch[0];
                modules[modulePath] = {
                    value: file.size,
                };
                continue;
            }
            if (packageName) {
                let packageResult;
                packageResult = result.get(packageName);
                if (!packageResult) {
                    // 查找版本号
                    const localtion = filePath.slice(0, filePath.indexOf(packageName)) +
                        packageName;
                    let packageJsonPath = path.join(localtion, 'package.json');
                    if (packageJsonPath.indexOf('webpack:') !== -1) {
                        try {
                            packageJsonPath = packageJsonPath.replace('webpack:', `${path.dirname(process.cwd())}`);
                        }
                        catch (err) {
                            console.log(`'查找模块: ${packageName} 版本号失败'`);
                            packageJsonPath = path.join(localtion, 'package.json');
                        }
                    }
                    const version = fs.existsSync(packageJsonPath)
                        ? fs.readJSONSync(packageJsonPath).version
                        : '-';
                    packageResult = {
                        name: packageName,
                        value: 0,
                        duplicateCount: 0,
                        version,
                    };
                    result.set(packageName, packageResult);
                }
                packageResult.value += file.size;
                // 匹配 kid ui 组件
                const kidUIPackageName = '@kid-ui/krn';
                if (packageName === kidUIPackageName) {
                    const componentNameMatch = filePath.match(/(?<=node_modules\/@kid-ui\/krn\/(lib|src)\/components\/)([^\/]+)/);
                    const kidUIPackage = result.get(kidUIPackageName);
                    if (componentNameMatch && componentNameMatch[0]) {
                        const componentName = componentNameMatch[0];
                        const dir = componentNameMatch[1];
                        let componentResult;
                        componentResult = kidComponentsResult.get(componentName);
                        if (!componentResult) {
                            componentResult = {
                                name: componentName,
                                value: 0,
                                version: (kidUIPackage === null || kidUIPackage === void 0 ? void 0 : kidUIPackage.version) || '-',
                                dir,
                            };
                            kidComponentsResult.set(componentName, componentResult);
                        }
                        componentResult.value += file.size;
                    }
                }
            }
            if (nestedPackageNames.length) {
                for (let i = 0; i < nestedPackageNames.length; i++) {
                    const nestedPackageName = nestedPackageNames[i];
                    let nestPackageResult;
                    nestPackageResult = nestedResult.get(nestedPackageName);
                    if (!nestPackageResult) {
                        nestPackageResult = {
                            name: nestedPackageName,
                            parents: [],
                        };
                        nestedResult.set(nestedPackageName, nestPackageResult);
                    }
                    const { parents } = nestPackageResult;
                    const parentPackageName = [
                        packageName,
                        ...nestedPackageNames,
                    ]
                        .slice(0, i + 1)
                        .join('/');
                    if (!parents.includes(parentPackageName)) {
                        parents.push(parentPackageName);
                    }
                }
            }
        }
        for (const [name, packageVal] of nestedResult) {
            let packageResult = result.get(name);
            if (!packageResult && name !== 'react-native') {
                continue;
            }
            if (name === 'react-native' && !packageResult) {
                packageResult = {
                    name: 'react-native',
                    value: 0,
                    duplicateCount: packageVal.parents.length,
                    version: '-',
                };
                result.set('react-native', packageResult);
                continue;
            }
            if (packageResult) {
                packageResult.duplicateCount = packageVal.parents.length;
            }
        }
        const kidComponents = [];
        for (const [, packageVal] of kidComponentsResult) {
            kidComponents.push(packageVal);
        }
        const packages = [];
        for (const [, packageVal] of result) {
            packages.push(packageVal);
        }
        fs.removeSync(statsJsonPath);
        return {
            kidComponents,
            packages,
            modules,
        };
    }
    catch (err) {
        cli_shared_1.Logger.error('解析打包依赖出错:', err);
        return {
            kidComponents: [],
            packages: [],
            modules: {},
        };
    }
};
const generateBuildInfo = async ({ bundleStats, modules, bundleDirPath, assets, version, builtAt, }) => {
    const buildInfo = Object.assign(Object.assign({}, bundleStats), { modules,
        assets,
        version,
        builtAt });
    const buildInfoPath = path.join(bundleDirPath, 'bundle-stats-detail.json');
    fs.writeJSONSync(buildInfoPath, buildInfo);
};
const bundleStats = async ({ outputDirPath, sourcemapPath, bundleSize, bundleFilePath, bundleDirPath, version, }) => {
    const { size: jsSize } = fs.statSync(bundleFilePath);
    const result = {
        packages: [],
        kidComponents: [],
        summary: {
            zipSize: bundleSize,
            totalSize: 0,
            jsSize,
            imgSize: 0,
            otherSize: 0,
            packageSize: 0,
            packagesCount: 0,
            assetsCount: 0,
            duplicatePackagesCount: 0,
        },
    };
    const assets = glob
        .sync('./**/*', {
        cwd: outputDirPath,
        ignore: [
            './output.zip',
            './manifest.json',
            './meta.json',
            './resource.tex',
        ],
    })
        .map((item) => {
        const stats = fs.statSync(path.join(outputDirPath, item));
        const isImg = /\.(aac|aiff|bmp|caf|gif|jpeg|jpg|png|webp|apng)$/;
        return {
            isAsset: stats.isFile(),
            size: stats.size,
            isImg: isImg.test(item),
            name: item,
        };
    })
        .filter((item) => item.isAsset);
    const { imgSize, otherSize, count } = assets.reduce((acc, curr) => {
        acc.imgSize += curr.isImg ? curr.size : 0;
        acc.otherSize += curr.isImg ? 0 : curr.size;
        acc.count += 1;
        return acc;
    }, {
        imgSize: 0,
        otherSize: 0,
        count: 0,
    });
    result.summary.imgSize = imgSize;
    result.summary.otherSize = otherSize;
    result.summary.assetsCount = count;
    result.summary.totalSize = jsSize + imgSize + otherSize;
    const { packages, kidComponents, modules } = await resolvePackages(sourcemapPath, bundleFilePath, outputDirPath);
    result.summary.packageSize = packages.reduce((acc, item) => {
        return acc + item.value;
    }, 0);
    result.summary.duplicatePackagesCount = packages.reduce((acc, item) => {
        return acc + +(item.duplicateCount > 0);
    }, 0);
    result.packages = packages;
    result.kidComponents = kidComponents;
    await generateBuildInfo({
        bundleStats: result,
        modules,
        bundleDirPath,
        assets: assets.map(({ name, size }) => ({ name, size })),
        version,
        builtAt: Date.now(),
    });
    return result;
};
exports.bundleStats = bundleStats;
