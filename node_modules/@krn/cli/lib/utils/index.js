"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disableCheckUpdateReactNative = exports.getPackageManager = exports.getWebpackCLI = exports.getReactNativeCLI = exports.getIPAddress = exports.writeJsonFile = exports.spawnAsync = exports.rmAndMkdir = exports.rootDir = exports.Logger = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const fs = require("fs-extra");
const prettier = require("prettier");
const logger_1 = require("./logger");
var logger_2 = require("./logger");
Object.defineProperty(exports, "Logger", { enumerable: true, get: function () { return logger_2.Logger; } });
tslib_1.__exportStar(require("./download"), exports);
tslib_1.__exportStar(require("./zip"), exports);
tslib_1.__exportStar(require("./exec-async"), exports);
tslib_1.__exportStar(require("./check-version"), exports);
tslib_1.__exportStar(require("./doctor-diagnose"), exports);
tslib_1.__exportStar(require("./install-klp"), exports);
const path = require("path");
const os = require("os");
const binUp = require('bin-up');
exports.rootDir = path.resolve(__dirname, '../../');
const rmAndMkdir = (desPath) => {
    if (fs.existsSync(desPath)) {
        fs.removeSync(desPath);
    }
    fs.mkdirSync(desPath, { recursive: true });
};
exports.rmAndMkdir = rmAndMkdir;
// some command will failed in spawn, like 'yes | sdkmanager --licenses'. Although spawn has a friendly stdout.
const spawnAsync = async (cmd, args, options = {}, extOptions = {}) => {
    return new Promise((resolve, reject) => {
        var _a, _b, _c, _d;
        const childProcess = (0, child_process_1.spawn)(cmd, args, options);
        const pipeMode = options.stdio === 'pipe' || options.stdio === undefined;
        let writeStream;
        if (extOptions.logPath && extOptions.log && pipeMode) {
            writeStream = fs.createWriteStream(extOptions.logPath);
            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(writeStream);
            (_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.pipe(writeStream);
            childProcess.on('close', () => {
                writeStream === null || writeStream === void 0 ? void 0 : writeStream.close();
            });
        }
        if (extOptions.log) {
            (_c = childProcess.stdout) === null || _c === void 0 ? void 0 : _c.on('data', (data) => {
                logger_1.Logger.log(data.toString());
            });
            (_d = childProcess.stderr) === null || _d === void 0 ? void 0 : _d.on('data', (data) => {
                logger_1.Logger.error(data.toString());
            });
        }
        childProcess.on('error', reject);
        childProcess.on('close', (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                reject(new Error('Exit code: ' + code));
            }
        });
    });
};
exports.spawnAsync = spawnAsync;
const writeJsonFile = (jsonPath, json) => {
    return fs.writeFile(jsonPath, 
    // stringify时给一个回车，这样prettier能很好地格式化json
    prettier.format(JSON.stringify(json, null, 1), {
        proseWrap: 'never',
        parser: 'json',
        tabWidth: 4,
    }));
};
exports.writeJsonFile = writeJsonFile;
const getIPAddress = () => {
    const interfaces = require('os').networkInterfaces();
    const ipList = [];
    for (const devName in interfaces) {
        const iface = interfaces[devName];
        for (let i = 0; i < iface.length; i++) {
            const alias = iface[i];
            if ((alias.family === 'IPv4' || alias.family === 4) &&
                alias.address !== '127.0.0.1' &&
                !alias.internal) {
                ipList.push(alias.address);
            }
        }
    }
    return ipList;
};
exports.getIPAddress = getIPAddress;
const getReactNativeCLI = () => {
    return binUp('react-native');
};
exports.getReactNativeCLI = getReactNativeCLI;
const getWebpackCLI = () => {
    return path.resolve(__dirname, '../../node_modules/.bin/webpack');
};
exports.getWebpackCLI = getWebpackCLI;
// yarn or npm
const getPackageManager = (projectRoot) => {
    return fs.existsSync(path.resolve(projectRoot, 'yarn.lock'))
        ? 'yarn'
        : 'npm';
};
exports.getPackageManager = getPackageManager;
const disableCheckUpdateReactNative = (root) => {
    var _a;
    // 关闭提示更新 React Native 版本
    try {
        const packageJsonPath = path.resolve(root, 'package.json');
        const cacheRootPath = path.join(os.homedir(), '.react-native-cli', 'cache');
        if (fs.existsSync(packageJsonPath)) {
            const name = (_a = fs.readJSONSync(packageJsonPath).name) !== null && _a !== void 0 ? _a : '';
            fs.mkdirpSync(cacheRootPath);
            const cacheFilePath = path.join(cacheRootPath, name);
            let cache = { lastChecked: '' };
            if (fs.existsSync(cacheFilePath)) {
                cache = fs.readJSONSync(cacheFilePath);
            }
            cache.lastChecked = new Date().toISOString();
            fs.writeJSONSync(cacheFilePath, cache, {
                spaces: 2,
            });
        }
    }
    catch (err) {
        logger_1.Logger.warn('禁用 React Native 检查更新失败', err);
    }
};
exports.disableCheckUpdateReactNative = disableCheckUpdateReactNative;
