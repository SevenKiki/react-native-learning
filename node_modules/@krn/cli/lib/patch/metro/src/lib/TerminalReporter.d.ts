export = CustomTerminalReporter;
declare class CustomTerminalReporter {
    constructor(terminal: any);
    _activeBundles: Map<any, any>;
    _scheduleUpdateBundleProgress: _.DebouncedFunc<(data: any) => void>;
    terminal: any;
    /**
     * Construct a message that represents the progress of a
     * single bundle build, for example:
     *
     *     BUNDLE path/to/bundle.js ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
     */
    _getBundleStatusMessage(_ref: any, phase: any): string;
    _logCacheDisabled(reason: any): void;
    _logBundleBuildDone(buildID: any): void;
    _logBundleBuildFailed(buildID: any): void;
    _logInitializing(port: any): void;
    _logInitializingFailed(port: any, error: any): void;
    _log(event: any): void;
    /**
     * We do not want to log the whole stacktrace for bundling error, because
     * these are operational errors, not programming errors, and the stacktrace
     * is not actionable to end users.
     */
    _logBundlingError(error: any): void;
    _logWorkerChunk(origin: any, chunk: any): void;
    _updateBundleProgress(_ref2: any): void;
    /**
     * This function is exclusively concerned with updating the internal state.
     * No logging or status updates should be done at this point.
     */
    _updateState(event: any): void;
    /**
     * Return a status message that is always consistent with the current state
     * of the application. Having this single function ensures we don't have
     * different callsites overriding each other status messages.
     */
    _getStatusMessage(): string;
    _logHmrClientError(e: any): void;
    update(event: any): void;
}
