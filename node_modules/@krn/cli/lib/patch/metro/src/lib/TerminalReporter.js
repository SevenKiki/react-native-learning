"use strict";
const chalk = require('chalk');
const path = require('path');
const throttle = require('lodash/throttle');
const qrcode = require('qrcode-terminal');
const util = require('util');
const stripAnsi = require('strip-ansi');
const { exec } = require('child_process');
const { URL } = require('url');
const qs = require('querystring');
const { AmbiguousModuleResolutionError } = require('metro-core');
const DARK_BLOCK_CHAR = '\u2593';
const LIGHT_BLOCK_CHAR = '\u2591';
const MAX_PROGRESS_BAR_CHAR_WIDTH = 16;
const GLOBAL_CACHE_DISABLED_MESSAGE_FORMAT = 'The global cache is now disabled because %s';
const groupStack = [];
let collapsedGuardTimer;
const formatLogTimestamp = (date) => {
    return chalk.dim(`[${date.toDateString()} ${date.toLocaleTimeString('en-US', {
        hour12: false,
    })}.${String(date.getMilliseconds()).padEnd(3, '0')}] `);
};
const logWarning = (terminal, format, ...args) => {
    const str = util.format(format, ...args);
    terminal.log('%s: %s', chalk.yellow('warning'), str);
};
const logError = (terminal, format, ...args) => {
    terminal.log('%s: %s', chalk.red('error'), 
    // Syntax errors may have colors applied for displaying code frames
    // in various places outside of where Metro is currently running.
    // If the current terminal does not support color, we'll strip the colors
    // here.
    util.format(chalk.supportsColor ? format : stripAnsi(format), ...args));
};
const logToConsole = (terminal, level, ...data) => {
    const logFunction = console[level] && level !== 'trace' ? level : 'log';
    const color = level === 'error'
        ? chalk.inverse.red
        : level === 'warn'
            ? chalk.inverse.yellow
            : chalk.inverse.white;
    if (level === 'group') {
        groupStack.push(level);
    }
    else if (level === 'groupCollapsed') {
        groupStack.push(level);
        clearTimeout(collapsedGuardTimer);
        // Inform users that logs get swallowed if they forget to call `groupEnd`.
        collapsedGuardTimer = setTimeout(() => {
            if (groupStack.includes('groupCollapsed')) {
                terminal.log(chalk.inverse.yellow.bold(' WARN '), 'Expected `console.groupEnd` to be called after `console.groupCollapsed`.');
                groupStack.length = 0;
            }
        }, 3000);
        return;
    }
    else if (level === 'groupEnd') {
        groupStack.pop();
        if (!groupStack.length) {
            clearTimeout(collapsedGuardTimer);
        }
        return;
    }
    if (!groupStack.includes('groupCollapsed')) {
        // Remove excess whitespace at the end of a log message, if possible.
        const lastItem = data[data.length - 1];
        if (typeof lastItem === 'string') {
            data[data.length - 1] = lastItem.trimEnd();
        }
        terminal.log(color.bold(` ${logFunction.toUpperCase()} `) +
            ''.padEnd(groupStack.length * 2, ' '), ...data);
    }
};
// const logoChalkRgb = chalk.rgb(253, 84, 3);
class CustomTerminalReporter {
    constructor(terminal) {
        this._activeBundles = new Map();
        this._scheduleUpdateBundleProgress = throttle((data) => {
            this.update(Object.assign(Object.assign({}, data), { type: 'bundle_transform_progressed_throttled' }));
        }, 100);
        const oldTerminalLog = terminal.log;
        terminal.log = (format, ...args) => {
            return oldTerminalLog.call(terminal, '[KRN-CLI]: ' + format, ...args);
        };
        this.terminal = terminal;
    }
    /**
     * Construct a message that represents the progress of a
     * single bundle build, for example:
     *
     *     BUNDLE path/to/bundle.js ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
     */
    _getBundleStatusMessage(_ref, phase) {
        let _ref$bundleDetails = _ref.bundleDetails, entryFile = _ref$bundleDetails.entryFile, bundleType = _ref$bundleDetails.bundleType, transformedFileCount = _ref.transformedFileCount, totalFileCount = _ref.totalFileCount, ratio = _ref.ratio, startTime = _ref.startTime;
        const localPath = path.relative('.', entryFile);
        const filledBar = Math.floor(ratio * MAX_PROGRESS_BAR_CHAR_WIDTH);
        const bundleTypeColor = phase === 'done'
            ? chalk.green
            : phase === 'failed'
                ? chalk.red
                : chalk.yellow;
        const progress = phase === 'in_progress'
            ? chalk.green.bgGreen(DARK_BLOCK_CHAR.repeat(filledBar)) +
                chalk.bgWhite.white(LIGHT_BLOCK_CHAR.repeat(MAX_PROGRESS_BAR_CHAR_WIDTH - filledBar)) +
                chalk.bold(` ${(100 * ratio).toFixed(1)}% `) +
                chalk.dim(`(${transformedFileCount}/${totalFileCount})`)
            : '';
        return (formatLogTimestamp(startTime) +
            bundleTypeColor.inverse.bold(` ${bundleType.toUpperCase()} `) +
            chalk.reset.dim(` ${path.dirname(localPath)}/`) +
            chalk.bold(path.basename(localPath)) +
            ' ' +
            progress +
            '\n');
    }
    _logCacheDisabled(reason) {
        const format = GLOBAL_CACHE_DISABLED_MESSAGE_FORMAT;
        switch (reason) {
            case 'too_many_errors':
                logWarning(this.terminal, format, 'it has been failing too many times.');
                break;
            case 'too_many_misses':
                logWarning(this.terminal, format, 'it has been missing too many consecutive keys.');
                break;
        }
    }
    _logBundleBuildDone(buildID) {
        const progress = this._activeBundles.get(buildID);
        if (progress != null) {
            const msg = this._getBundleStatusMessage(Object.assign(Object.assign({}, progress), { ratio: 1, transformedFileCount: progress.totalFileCount }), 'done');
            this.terminal.log(msg);
            this.terminal.log('Loading Bundle...');
            this._activeBundles.delete(buildID);
        }
    }
    _logBundleBuildFailed(buildID) {
        const progress = this._activeBundles.get(buildID);
        if (progress != null) {
            const msg = this._getBundleStatusMessage(progress, 'failed');
            this.terminal.log(msg);
        }
    }
    _logInitializing(port) {
        this.terminal.log('Welcome to KDS React CLI!');
        const ip = process.env.KRN_IP;
        const serverAddr = `http://${ip || 'localhost'}:${port}`;
        const isDevtoolsEnabled = process.env.KRN_DEVTOOLS_ENABLED === 'enabled';
        const customDevtoolsIp = process.env.KRN_DEVTOOLS_IP;
        const schemeTemplate = process.env.KRN_SCHEME_TEMPLATE;
        let schemeUrl = process.env.KRN_SCHEME_URL
            ? process.env.KRN_SCHEME_URL + '&debugServer=' + serverAddr
            : '';
        // 如果有自定义的 scheme 模板
        if (schemeTemplate) {
            schemeUrl = schemeTemplate.replace(/\$BUNDLE_ID/g, process.env.KRN_DEV_BUNDLE_ID)
                .replace(/\$COMPONENT_NAME/g, process.env.KRN_DEV_COMPONENT_NAME)
                .replace(/\$DEBUG_SERVER/g, serverAddr)
                .replace(/\$IP/g, ip)
                .replace(/\$PORT/g, port);
        }
        const launchDevtoolsApp = ({ ip, port, fallback }) => {
            try {
                const extraParamsStr = process.env.KRN_SCHEME_EXTRA_PARAMS;
                const scheme = process.env.KRN_SCHEME_NAME;
                let extraParams;
                if (extraParamsStr) {
                    extraParams = qs.parse(extraParamsStr);
                }
                const { searchParams } = new URL(schemeUrl);
                const { version } = require(path.resolve(__dirname, '../../../../../package.json'));
                searchParams.append('ip', ip);
                searchParams.append('port', port);
                searchParams.append('name', searchParams.get('componentName'));
                searchParams.append('version', version);
                searchParams.append('framework', 'React');
                searchParams.append('bundle', searchParams.get('bundleId'));
                searchParams.append('scheme', scheme);
                // Try to Launch Devtools App
                exec(`open "kds://cli/qrcode?${searchParams.toString()}${extraParams ? `&extra=${encodeURIComponent(JSON.stringify(extraParams))}` : ''}&schemeUrl=${encodeURIComponent(schemeUrl)}"`, (err) => {
                    if (err) {
                        fallback();
                    }
                });
            }
            catch (error) {
                fallback();
            }
        };
        const fallback = () => {
            qrcode.generate(schemeUrl, { small: true }, (code) => {
                this.terminal.log('扫码调试:\n' + code);
                this.terminal.log('提示: 调试前，请先摇一摇，选择KDS-React/Vue设置，开启本地调试，完成设置，重启APP');
                this.terminal.log('提示: 如需连接Devtools进行页面调试，请使用krn debug命令。');
            });
        };
        if (schemeUrl) {
            // 自定义调试 IP，不自动打开桌面 app
            if (isDevtoolsEnabled && !customDevtoolsIp) {
                launchDevtoolsApp({
                    ip,
                    port,
                    fallback,
                });
            }
            else {
                fallback();
            }
            this.terminal.log('Scheme:', chalk.green(schemeUrl));
        }
        this.terminal.log('Metro Sever:', chalk.green(serverAddr));
        this.terminal.log(`\n\nTo reload the app press "${chalk.bold(chalk.blue('R'))}"\nTo open developer menu press "${chalk.bold(chalk.blue('D'))}"\n`);
    }
    _logInitializingFailed(port, error) {
        if (error.code === 'EADDRINUSE') {
            this.terminal.log(chalk.bgRed.bold(' ERROR '), chalk.red("Metro can't listen on port", chalk.bold(String(port))));
            this.terminal.log('Most likely another process is already using this port');
            this.terminal.log('Run the following command to find out which process:');
            this.terminal.log('\n  ', chalk.bold('lsof -i :' + port), '\n');
            this.terminal.log('Then, you can either shut down the other process:');
            this.terminal.log('\n  ', chalk.bold('kill -9 <PID>'), '\n');
            this.terminal.log('or run Metro on different port.');
        }
        else {
            this.terminal.log(chalk.bgRed.bold(' ERROR '), chalk.red(error.message));
            const errorAttributes = JSON.stringify(error);
            if (errorAttributes !== '{}') {
                this.terminal.log(chalk.red(errorAttributes));
            }
            this.terminal.log(chalk.red(error.stack));
        }
    }
    _log(event) {
        switch (event.type) {
            case 'initialize_started':
                this._logInitializing(event.port);
                break;
            case 'initialize_done':
                this.terminal.log('\nMetro is ready.\n');
                break;
            case 'initialize_failed':
                this._logInitializingFailed(event.port, event.error);
                break;
            case 'bundle_build_done':
                this._logBundleBuildDone(event.buildID);
                break;
            case 'bundle_build_failed':
                this._logBundleBuildFailed(event.buildID);
                break;
            case 'bundling_error':
                this._logBundlingError(event.error);
                break;
            case 'global_cache_disabled':
                this._logCacheDisabled(event.reason);
                break;
            case 'transform_cache_reset':
                logWarning(this.terminal, 'the transform cache was reset.');
                break;
            case 'worker_stdout_chunk':
                this._logWorkerChunk('stdout', event.chunk);
                break;
            case 'worker_stderr_chunk':
                this._logWorkerChunk('stderr', event.chunk);
                break;
            case 'hmr_client_error':
                this._logHmrClientError(event.error);
                break;
            case 'client_log':
                logToConsole(this.terminal, event.level, ...event.data);
                break;
            case 'dep_graph_loading':
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const color = event.hasReducedPerformance
                    ? chalk.red
                    : chalk.blue;
                // this.terminal.log(
                //     color.bold('                    Welcome to Metro!\n') +
                //         chalk.dim(
                //             '              Fast - Scalable - Integrated\n\n',
                //         ),
                // );
                if (event.hasReducedPerformance) {
                    this.terminal.log(chalk.red('Metro is operating with reduced performance.\n' +
                        'Please fix the problem above and restart Metro.\n\n'));
                }
                break;
        }
    }
    /**
     * We do not want to log the whole stacktrace for bundling error, because
     * these are operational errors, not programming errors, and the stacktrace
     * is not actionable to end users.
     */
    _logBundlingError(error) {
        if (error instanceof AmbiguousModuleResolutionError) {
            const he = error.hasteError;
            const message = 'ambiguous resolution: module `' +
                `${error.fromModulePath}\` tries to require \`${he.hasteName}\`, ` +
                'but there are several files providing this module. You can delete ' +
                'or fix them: \n\n' +
                Object.keys(he.duplicatesSet)
                    .sort()
                    .map((dupFilePath) => `  * \`${dupFilePath}\`\n`)
                    .join('');
            logError(this.terminal, message);
            return;
        }
        let { message } = error;
        // Do not log the stack trace for SyntaxError (because it will always be in
        // the parser, which is not helpful).
        if (!(error instanceof SyntaxError)) {
            if (error.snippet == null && error.stack != null) {
                message = error.stack;
            }
        }
        if (error.filename && !message.includes(error.filename)) {
            message += ` [${error.filename}]`;
        }
        if (error.snippet != null) {
            message += '\n' + error.snippet;
        }
        logError(this.terminal, message);
    }
    _logWorkerChunk(origin, chunk) {
        const lines = chunk.split('\n');
        if (lines.length >= 1 && lines[lines.length - 1] === '') {
            lines.splice(lines.length - 1, 1);
        }
        lines.forEach((line) => {
            this.terminal.log(`transform[${origin}]: ${line}`);
        });
    }
    _updateBundleProgress(_ref2) {
        let buildID = _ref2.buildID, transformedFileCount = _ref2.transformedFileCount, totalFileCount = _ref2.totalFileCount;
        const currentProgress = this._activeBundles.get(buildID);
        if (currentProgress == null) {
            return;
        }
        const rawRatio = transformedFileCount / totalFileCount;
        const conservativeRatio = Math.pow(rawRatio, 2);
        const ratio = Math.max(conservativeRatio, currentProgress.ratio);
        Object.assign(currentProgress, {
            ratio,
            transformedFileCount,
            totalFileCount,
        });
    }
    /**
     * This function is exclusively concerned with updating the internal state.
     * No logging or status updates should be done at this point.
     */
    _updateState(event) {
        switch (event.type) {
            case 'bundle_build_done':
            case 'bundle_build_failed':
                this._activeBundles.delete(event.buildID);
                break;
            case 'bundle_build_started':
                const bundleProgress = {
                    bundleDetails: event.bundleDetails,
                    transformedFileCount: 0,
                    totalFileCount: 1,
                    ratio: 0,
                    startTime: new Date(),
                };
                this._activeBundles.set(event.buildID, bundleProgress);
                break;
            case 'bundle_transform_progressed':
                if (event.totalFileCount === event.transformedFileCount) {
                    this._scheduleUpdateBundleProgress.cancel();
                    this._updateBundleProgress(event);
                }
                else {
                    this._scheduleUpdateBundleProgress(event);
                }
                break;
            case 'bundle_transform_progressed_throttled':
                this._updateBundleProgress(event);
                break;
        }
    }
    /**
     * Return a status message that is always consistent with the current state
     * of the application. Having this single function ensures we don't have
     * different callsites overriding each other status messages.
     */
    _getStatusMessage() {
        return (Array.from(this._activeBundles.entries())
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            .map(([_, progress]) => {
            return this._getBundleStatusMessage(progress, 'in_progress');
        })
            .filter((str) => str != null)
            .join('\n'));
    }
    _logHmrClientError(e) {
        logError(this.terminal, 'A WebSocket client got a connection error. Please reload your device ' +
            'to get HMR working again: %s', e);
    }
    update(event) {
        this._log(event);
        this._updateState(event);
        this.terminal.status(this._getStatusMessage());
    }
}
module.exports = CustomTerminalReporter;
