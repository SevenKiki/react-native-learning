const fs = require('fs');
const path = require('path');
module.exports = function () {
    return {
        name: 'react-native-batch-bridge-register-check',
        pre() {
            this.result = [];
        },
        visitor: {
            Program(programePath, state) {
                const filename = state.file.opts.filename;
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const self = this;
                //通用
                state.hasRecordedPath = new Set();
                state.importBatchedName = '';
                programePath.traverse({
                    ImportDeclaration(outerPath) {
                        if (state.hasRecordedPath.has(outerPath)) {
                            return;
                        }
                        state.hasRecordedPath.add(outerPath);

                        const source = outerPath.get('source').node.value;

                        if (
                            source !==
                            'react-native/Libraries/BatchedBridge/BatchedBridge'
                        ) {
                            return;
                        }

                        outerPath.traverse({
                            ImportDefaultSpecifier(innerPath) {
                                if (state.hasRecordedPath.has(innerPath)) {
                                    return;
                                }
                                state.hasRecordedPath.add(innerPath);

                                const importedName = innerPath.get('local').node
                                    .name;

                                state.importBatchedName = importedName;
                            },
                        });
                    },

                    CallExpression(outerPath) {
                        if (state.hasRecordedPath.has(outerPath)) {
                            return;
                        }
                        state.hasRecordedPath.add(outerPath);

                        if (!state.importBatchedName) {
                            return;
                        }

                        if (
                            outerPath.get('callee').node.type ===
                            'MemberExpression'
                        ) {
                            outerPath.traverse({
                                MemberExpression(innerPath) {
                                    if (state.hasRecordedPath.has(innerPath)) {
                                        return;
                                    }
                                    state.hasRecordedPath.add(innerPath);

                                    const objectName =
                                        (innerPath.get('object') &&
                                            innerPath.get('object').node
                                                .name) ||
                                        '';
                                    const propertyName =
                                        (innerPath.get('property') &&
                                            innerPath.get('property').node
                                                .name) ||
                                        '';
                                    if (
                                        objectName ===
                                            state.importBatchedName &&
                                        propertyName ===
                                            'registerCallableModule'
                                    ) {
                                        const args = outerPath.get('arguments');
                                        if (args.length) {
                                            const node = args[0].node;
                                            if (node.type === 'StringLiteral') {
                                                self.result.push({
                                                    filename: path
                                                        .relative(
                                                            process.cwd(),
                                                            filename,
                                                        )
                                                        .replace(
                                                            /^node_modules\//,
                                                            '',
                                                        ),
                                                    key: node.value,
                                                });
                                            }
                                        }
                                    }
                                },
                            });
                        }
                    },
                });
            },
        },
        post() {
            const output = this.opts.outputFilePath;
            if (this.result.length && output) {
                let oldResult = [];
                if (fs.existsSync(output)) {
                    oldResult = JSON.parse(fs.readFileSync(output, 'utf8'));
                }
                const newResult = [...oldResult, ...this.result];
                fs.writeFileSync(output, JSON.stringify(newResult, null, 2));
            }
        },
    };
};
