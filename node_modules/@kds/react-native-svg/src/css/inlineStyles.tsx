import { Middleware, XmlAST, camelCase } from "../xml/common";
import { querySelectorAll, FlatSelectorList, closestElem, flattenToSelectors, parseProps, filterByMqs, filterByPseudos, cleanPseudos, sortSelectors, initStyle, } from './common';
import csstree, { CssNode, Declaration } from 'css-tree';

export const inlineStyles: Middleware = function inlineStyles(
    document: XmlAST,
) {
    // collect <style/>s
    const styleElements = querySelectorAll('style', document);

    //no <styles/>s, nothing to do
    if (styleElements.length === 0) {
        return document;
    }

    const selectors: FlatSelectorList = [];

    for (let element of styleElements) {
        const { children } = element;
        if (!children.length || closestElem(element, 'foreignObject')) {
            // skip empty <style/>s or <foreignObject> content.
            continue;
        }

        // collect <style/>s and their css ast
        try {
            const styleString = children.join('');
            flattenToSelectors(csstree.parse(styleString, parseProps), selectors);
        } catch (parseError) {
            console.warn(
                'Warning: Parse error of styles of <style/> element, skipped. Error details: ' +
                parseError,
            );
        }
    }

    // filter for mediaqueries to be used or without any mediaquery
    const selectorsMq = filterByMqs(selectors);

    // filter for pseudo elements to be used
    const selectorsPseudo = filterByPseudos(selectorsMq);

    // remove PseudoClass from its SimpleSelector for proper matching
    cleanPseudos(selectorsPseudo);

    // stable sort selectors
    const sortedSelectors = sortSelectors(selectorsPseudo).reverse();

    // match selectors
    for (let { rule, item } of sortedSelectors) {
        if (rule === null) {
            continue;
        }
        const selectorStr = csstree.generate(item.data);
        try {
            // apply <style/> to matched elements
            const matched = querySelectorAll(selectorStr, document).map(initStyle);
            if (matched.length === 0) {
                continue;
            }
            csstree.walk(rule, {
                visit: 'Declaration',
                enter(node: CssNode) {
                    const { property, value, important } = node as Declaration;
                    // existing inline styles have higher priority
                    // no inline styles, external styles,                                    external styles used
                    // inline styles,    external styles same   priority as inline styles,   inline   styles used
                    // inline styles,    external styles higher priority than inline styles, external styles used
                    const name = property.trim();
                    const camel = camelCase(name);
                    const val = csstree.generate(value).trim();
                    for (let element of matched) {
                        const { style, priority } = element;
                        const current = priority.get(name);
                        if (current === undefined || current < important) {
                            priority.set(name, important as boolean);
                            style[camel] = val;
                        }
                    }
                },
            });
        } catch (selectError) {
            if (selectError.constructor === SyntaxError) {
                console.warn(
                    'Warning: Syntax error when trying to select \n\n' +
                    selectorStr +
                    '\n\n, skipped. Error details: ' +
                    selectError,
                );
                continue;
            }
            throw selectError;
        }
    }

    return document;
};

export default inlineStyles;