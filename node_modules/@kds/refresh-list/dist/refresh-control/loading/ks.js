// 先放这，之后再迁移
import React, { Component } from 'react';
import { Animated, Easing } from 'react-native';
// @ts-expect-error
import Svg from 'react-native-svg/lib/module/elements/Svg';
// @ts-expect-error
import LinearGradient from 'react-native-svg/lib/module/elements/LinearGradient';
// @ts-expect-error
import Path from 'react-native-svg/lib/module/elements/Path';
// @ts-expect-error
import Stop from 'react-native-svg/lib/module/elements/Stop';
const AnimatePath = Animated.createAnimatedComponent(Path);
export var LoadingType;
(function (LoadingType) {
    LoadingType["highlight"] = "url(#c)";
    LoadingType["light"] = "#ffffff";
    LoadingType["gray"] = "#C6C6C6";
})(LoadingType || (LoadingType = {}));
export var LoadingSize;
(function (LoadingSize) {
    LoadingSize["medium"] = "40";
    LoadingSize["small"] = "30";
})(LoadingSize || (LoadingSize = {}));
export class KsLoading extends Component {
    constructor(props) {
        super(props);
        this.offset = new Animated.Value(0);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        this.onPropsChange(nextProps);
    }
    componentDidMount() {
        this.onPropsChange(this.props);
    }
    onPropsChange(nextProps) {
        const { animated = true, percent = 0, loopDuration = 1000 } = nextProps;
        if (animated) {
            if (this.animation) {
                return;
            }
            this.offset.setValue(0);
            this.animation = Animated.loop(Animated.timing(this.offset, {
                toValue: 320,
                duration: loopDuration,
                easing: Easing.linear,
                useNativeDriver: true,
            }));
            this.animation.start();
        }
        else {
            if (this.animation) {
                this.animation.stop();
                // @ts-expect-error
                this.animation = null;
            }
            this.offset.setValue(percent > 100 ? 320 : ((100 + percent) / 100) * 160);
        }
    }
    shouldComponentUpdate(nextProps) {
        const changeKeys = ['type', 'size', 'style'];
        return changeKeys.some((key) => this.props[key] !== nextProps[key]);
    }
    render() {
        const { type = LoadingType.gray, size = LoadingSize.medium, style, } = this.props;
        let path = (<>
        <LinearGradient id="c">
          <Stop stopColor="#FF4040" offset="0%"/>
          <Stop stopColor="#FFC900" offset="100%"/>
        </LinearGradient>
        <AnimatePath strokeDasharray="160" strokeLinecap="round" d="M40 40l8.201-8.201c4.53-4.53 11.873-4.53 16.402 0A11.598 11.598 0 0 1 68 40c0 6.405-5.193 11.598-11.598 11.598a11.598 11.598 0 0 1-8.201-3.397L40 40l-8.201-8.201c-4.53-4.53-11.873-4.53-16.402 0A11.598 11.598 0 0 0 12 40c0 6.405 5.193 11.598 11.598 11.598 3.076 0 6.026-1.222 8.201-3.397L40 40z" stroke={type} strokeWidth="7" fill="none" fillRule="nonzero" strokeDashoffset={this.offset}/>
      </>);
        return (<Svg width={size} height={size} viewBox="0 0 80 80" style={style}>
        {path}
      </Svg>);
    }
}
