import React, {Component} from 'react';
import {
  View,
  StyleSheet,
  Animated,
  PanResponder,
  PanResponderInstance,
  Easing,
  LayoutChangeEvent,
} from 'react-native';
import {
  PullRefreshState,
  DefaultRefreshControl,
  PullState,
  PullRefreshProps,
} from './constant';

export default class PullRefresh extends Component<
  PullRefreshProps,
  PullRefreshState
> {
  pullAnimHeight: number = 0;
  minPullDistance: number = 0;
  pan: Animated.Value;
  panResponder: PanResponderInstance;
  scrollY: number;
  isPulling: boolean;
  isRefreshing: boolean;
  animation?: Animated.CompositeAnimation;
  touching: boolean;
  pullState: PullState;
  moveHeight: number;
  movePercent: number;
  timeout?: number;
  refreshControl?: DefaultRefreshControl;
  scrollContent: () => React.ReactNode;

  static defaultProps = {
    RefreshControl: DefaultRefreshControl,
  };

  constructor(props: PullRefreshProps) {
    super(props);
    this.pan = new Animated.Value(0);
    this.isPulling = false;
    this.scrollY = 0;
    this.isRefreshing = false;
    this.touching = false;
    this.pullState = PullState.INIT;
    this.moveHeight = 0;
    this.movePercent = 0;
    this.state = {
      top: -1000,
    };

    this.scrollContent = () => React.Children.map(this.props.children, (child: any) =>
      React.cloneElement(child, {
        scrollEventThrottle: 1,
        onScroll: (evt: any) => {
          this.setScroll(evt.nativeEvent.contentOffset.y);
          if (
            child.props.onScroll &&
            typeof child.props.onScroll === 'function'
          ) {
            child.props.onScroll(evt);
          }
        },
      })
    );
    const onRelease = () => {
      this.pan.flattenOffset();
      this.touching = false;
      // @ts-expect-error
      const panValue = this.pan._value;
      if (panValue >= this.pullAnimHeight) {
        this.animatedTo(this.pullAnimHeight, () => {
          this.updatePullState(PullState.LOADING);
          this.props.onRequest && this.props.onRequest();
        });
      } else if (panValue > 0) {
        this.updatePullState(PullState.FINISH);
        this.animatedTo(0, () => {
          this.isPulling = false;
          this.updatePullState(PullState.INIT);
        });
      } else {
        this.updatePullState(PullState.INIT);
        this.isPulling = false;
      }
    };
    const canMove = (name: string, evt: any, gestureState: any) => {
      // console.log(name, this.isPulling, this.scrollY, gestureState.vy, canMove)
      // if (name === 'onMoveShouldSetPanResponderCapture') {
      //   return true;
      // }
      // if (name === 'onMoveShouldSetPanResponder') {
      //   return true;
      // }
      return (this.isPulling ? false : (this.scrollY <= 0 && gestureState.vy > 0 && gestureState.vy > Math.abs(gestureState.vx)))   
    };
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: canMove.bind(
        this,
        'onStartShouldSetPanResponder'
      ),
      onStartShouldSetPanResponderCapture: canMove.bind(
        this,
        'onStartShouldSetPanResponderCapture'
      ),
      onMoveShouldSetPanResponder: canMove.bind(
        this,
        'onMoveShouldSetPanResponder'
      ),
      onMoveShouldSetPanResponderCapture: canMove.bind(
        this,
        'onMoveShouldSetPanResponderCapture'
      ),
      onPanResponderGrant: () => {
        // console.log('onPanResponderGrant');
        this.animation && this.animation.stop();
        this.touching = true;
        // @ts-expect-error
        this.pan.setOffset(this.pan._value);
        this.updatePullState(PullState.PULLING);
        this.timeout && clearTimeout(this.timeout);
      },
      onPanResponderMove: (evt, gestureState) => {
        // console.log('===> move', gestureState.dy);
        this.isPulling = true;
        // @ts-expect-error
        const offset = this.pan._offset;
        let value = Math.max(offset + gestureState.dy, 0);
        if (value > 0) {
          // 弹簧劲度系数
          this.pan.setValue(gestureState.dy / 2.2);
        } else {
          this.pan.setValue(-offset);
        }
        this.moveHeight = value;
        this.movePercent = (value / this.pullAnimHeight) * 100;
        if (this.props.updateOnPullChange !== false) {
          this.renderRefreshControl();
        }
      },
      onPanResponderRelease: onRelease,
      onPanResponderTerminationRequest() {
        // console.log('onPanResponderTerminationRequest');
        return false;
      },
      onPanResponderTerminate: onRelease,
      onShouldBlockNativeResponder() {
        // console.log('onShouldBlockNativeResponder');
        return true;
      },
    });
    // this.addScrollListener();
  }
  renderRefreshControl() {
    const refreshControl = {
      pullAnimHeight: this.pullAnimHeight,
      minPullDistance: this.minPullDistance,
      pullState: this.pullState,
      moveHeight: this.moveHeight,
      movePercent: this.movePercent,
    };
    if (this.refreshControl) {
      this.refreshControl.setRefreshControlParams(refreshControl);
    }
  }
  animatedTo(toValue: number, cb?: () => void) {
    this.animation = Animated.timing(this.pan, {
      toValue: toValue,
      easing: Easing.bezier(0.1, 0.57, 0.1, 1),
      duration: ((this.pan as any)._value - toValue) * 1.4,
      useNativeDriver: false,
    });
    this.animation.start(({finished}: {finished: boolean}) => {
      if (finished) {
        cb && cb();
        this.animation = undefined;
      }
    });
  }
  setScroll(y: number) {
    this.scrollY = y;
  }
  updatePullState(state: PullState) {
    if (this.pullState === state) {
      return;
    }
    this.pullState = state;
    this.renderRefreshControl();
  }

  UNSAFE_componentWillReceiveProps(nextProps: PullRefreshProps) {
    if (this.pullState === PullState.PULLING) {
      return;
    }
    if (nextProps.isRefreshing === true && !this.isRefreshing) {
      this.animatedTo(this.pullAnimHeight);
      this.isRefreshing = true;
      this.updatePullState(PullState.LOADING);
    }
    if (nextProps.isRefreshing === false && this.isRefreshing) {
      this.updatePullState(PullState.HOLDING);
      this.timeout = setTimeout(() => {
        this.animatedTo(0, () => {
          this.isPulling = false;
          this.updatePullState(PullState.INIT);
        });
        this.updatePullState(PullState.FINISH);
      }, this.props.msHoldingTime || 1000);
      this.isRefreshing = false;
    }
    // if (nextProps.setScrollEvent !== prevProps.setScrollEvent) {
    //   this.addScrollListener(nextProps.setScrollEvent);
    // }
  }
  onLayout = (evt: LayoutChangeEvent) => {
    this.pullAnimHeight = this.pullAnimHeight || evt.nativeEvent.layout.height;
    this.minPullDistance = this.props.minPullDistance || this.pullAnimHeight;
    this.setState({
      top: -this.pullAnimHeight,
    });
  };
  setRefreshControl = (ref: DefaultRefreshControl) => {
    this.refreshControl = ref;
  };
  render() {
    const {top} = this.state;

    const content =
      this.props.isContentScroll !== false ? (
        <Animated.View
          style={{
            transform: [{translateY: this.pan}],
            flex: 1,
          }}>
          {this.scrollContent()}
        </Animated.View>
      ) : (
        this.scrollContent()
      );
    const RefreshControl = this.props.RefreshControl!;

    return (
      <View style={[styles.container, this.props.refreshLayoutStyle]} {...this.panResponder.panHandlers}>
        <Animated.View
          onLayout={this.onLayout}
          style={[
            styles.freshItem,
            {
              top: top,
              height: this.props.pullAnimHeight || undefined,
              transform: [{translateY: this.pan}],
            },
            this.props.refreshControlStyle
          ]}>
          <RefreshControl ref={this.setRefreshControl} />
        </Animated.View>
        {content}
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    overflow: 'hidden',
    position: 'relative',
    flex: 1,
  },
  freshItem: {
    position: 'absolute',
    width: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'transparent',
    zIndex: 1,
  },
});
