var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
//@ts-nocheck
import React, { useMemo, useState } from "react";
import { I18nManager, PixelRatio, Platform, StyleSheet, View, } from "react-native";
import { Svg, LinearGradient, Path, Stop, Defs, Mask, RadialGradient, Rect,
// @ts-expect-error
 } from "react-native-svg";
import { parseToRgb, rgbToColorString, transparentize } from "polished"; // To extract alpha
import { cornerToStyle, objFromKeys } from "./utils";
/** Package Semver. Used on the [Snack](https://snack.expo.dev/@srbrahma/react-native-shadow-2-sandbox)
 * and somehow may be useful to you. */
export var version = "6.0.5";
var isWeb = Platform.OS === "web";
/** Rounds the given size to a pixel perfect size. */
export function R(value) {
    // In Web, 1dp=1px. But it accepts decimal sizes, and it's somewhat problematic.
    // The size rounding is browser-dependent, so we do the decimal rounding for web by ourselves to have a
    // consistent behavior. We floor it, because it's better for the child to overlap by a pixel the right/bottom shadow part
    // than to have a pixel wide gap between them.
    if (isWeb)
        return Math.floor(value);
    return PixelRatio.roundToNearestPixel(value);
}
/** Converts dp to pixels. */
function P(value) {
    if (isWeb)
        return value;
    return PixelRatio.getPixelSizeForLayoutSize(value);
}
/** How many pixels for each dp. scale = pixels/dp */
var scale = isWeb ? 1 : PixelRatio.get();
/** Converts two sizes to pixel for perfect math, sum them and converts the result back to dp. */
function sumDps(a, b) {
    if (isWeb)
        return a + b;
    return R((P(a) + P(b)) / scale);
}
/** [Android/ios?] [*4] A small safe margin for the svg sizes.
 *
 * It fixes some gaps that we had, as even that the svg size and the svg rect for example size were the same, this rect
 * would still strangely be cropped/clipped. We give this additional size to the svg so our rect/etc won't be unintendedly clipped.
 *
 * It doesn't mean 1 pixel, as RN uses dp sizing, it's just an arbitrary and big enough number. */
var additional = isWeb ? 0 : 1;
var cornersArray = [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight",
];
// const cornersShadowArray = ['topLeftShadow', 'topRightShadow', 'bottomLeftShadow', 'bottomRightShadow'] as const;
var sidesArray = ["left", "right", "top", "bottom"];
export var Shadow = function (_a) {
    var _b, _c;
    var radiusProp = _a.radius, _d = _a.sides, sidesProp = _d === void 0 ? ["left", "right", "top", "bottom"] : _d, _e = _a.corners, cornersProp = _e === void 0 ? ["topLeft", "topRight", "bottomLeft", "bottomRight"] : _e, containerViewStyle = _a.containerViewStyle, shadowViewProps = _a.shadowViewProps, _f = _a.startColor, startColorProp = _f === void 0 ? "#00000020" : _f, _g = _a.finalColor, finalColorProp = _g === void 0 ? transparentize(1, startColorProp) : _g, _h = _a.distance, distanceProp = _h === void 0 ? 10 : _h, children = _a.children, sizeProp = _a.size, // Do not default here. We do `if (sizeProp)` on onLayout.
    offset = _a.offset, _j = _a.getChildRadius, getChildRadius = _j === void 0 ? true : _j, _k = _a.getViewStyleRadius, getViewStyleRadius = _k === void 0 ? true : _k, paintInsideProp = _a.paintInside, viewStyle = _a.viewStyle, _l = _a.safeRender, safeRender = _l === void 0 ? false : _l;
    var isRTL = I18nManager.isRTL;
    var _m = useState(), childWidth = _m[0], setChildWidth = _m[1];
    var _o = useState(), childHeight = _o[0], setChildHeight = _o[1];
    /** Defaults to true if offset is defined, else defaults to false */
    var paintInside = paintInsideProp !== null && paintInsideProp !== void 0 ? paintInsideProp : (offset ? true : false);
    var _p = offset !== null && offset !== void 0 ? offset : [0, 0], offsetX = _p[0], offsetY = _p[1];
    var distance = R(Math.max(distanceProp, 0)); // Min val as 0
    /** Read {@link additional}, [*4] */
    var distanceWithAdditional = distance + additional;
    var width = (_b = (sizeProp ? R(sizeProp === null || sizeProp === void 0 ? void 0 : sizeProp[0]) : childWidth)) !== null && _b !== void 0 ? _b : "100%"; // '100%' sometimes will lead to gaps. child size don't lie.
    var height = (_c = (sizeProp ? R(sizeProp === null || sizeProp === void 0 ? void 0 : sizeProp[1]) : childHeight)) !== null && _c !== void 0 ? _c : "100%";
    /** Will (+ additional), only if its value isn't '100%'. */
    var widthWithAdditional = typeof width === "string" ? width : width + additional;
    /** Will (+ additional), only if its value isn't '100%'. */
    var heightWithAdditional = typeof height === "string" ? height : height + additional;
    var radii = useMemo(function () {
        /** Not yet treated. May be negative / undefined */
        var cornerRadiusPartial = (function () {
            var _a, _b, _c, _d, _e, _f;
            if (radiusProp !== undefined) {
                if (typeof radiusProp === "number")
                    return objFromKeys(cornersArray, function () { return radiusProp; });
                else
                    return objFromKeys(cornersArray, function (k) { var _a; return (_a = radiusProp[k]) !== null && _a !== void 0 ? _a : radiusProp.default; });
            }
            /** We have to merge both viewStyle and childStyle with care. A bottomLeftBorderRadius in childStyle for eg shall not replace
             * borderRadius in viewStyle.
             *
             * Props inits as undefined so in getChildRadius we can Object.values check for undefined. */
            // Map type to undefined union instead of Partial as Object.values don't treat optional as | undefined. Keeps this type-safe.
            var mergedStyle = {
                bottomLeft: undefined,
                bottomRight: undefined,
                topLeft: undefined,
                topRight: undefined,
            };
            if (getViewStyleRadius) {
                var mergedViewStyle_1 = StyleSheet.flatten(viewStyle !== null && viewStyle !== void 0 ? viewStyle : {}); // Convert possible array style to a single obj style.
                mergedStyle = objFromKeys(cornersArray, function (k) {
                    var _a, _b;
                    return (_b = (_a = mergedViewStyle_1[cornerToStyle(k, false)]) !== null && _a !== void 0 ? _a : mergedViewStyle_1[cornerToStyle(k, true)]) !== null && _b !== void 0 ? _b : mergedViewStyle_1 === null || mergedViewStyle_1 === void 0 ? void 0 : mergedViewStyle_1.borderRadius;
                });
            }
            // Only enter block if there is a undefined corner that may now be defined;
            if (getChildRadius && Object.values(mergedStyle).includes(undefined)) {
                if (((_b = (_a = React.Children) === null || _a === void 0 ? void 0 : _a.count) === null || _b === void 0 ? void 0 : _b.call(_a, children)) > 1)
                    throw new Error("Only single child is accepted in Shadow component with getChildRadius={true} (default value). You should wrap it in a View or change this property to false and manually enter the borderRadius in the radius property.");
                /** May be an array of styles. */
                var childStyleTemp = (_f = (_e = (_d = (_c = React.Children) === null || _c === void 0 ? void 0 : _c.only) === null || _d === void 0 ? void 0 : _d.call(_c, children)) === null || _e === void 0 ? void 0 : _e.props) === null || _f === void 0 ? void 0 : _f.style;
                var childStyle_1 = StyleSheet.flatten(childStyleTemp !== null && childStyleTemp !== void 0 ? childStyleTemp : {}); // Convert possible array style to a single obj style.
                mergedStyle = objFromKeys(cornersArray, function (k) {
                    var _a, _b, _c;
                    return (_c = (_b = (_a = mergedStyle[k]) !== null && _a !== void 0 ? _a : childStyle_1[cornerToStyle(k, false)]) !== null && _b !== void 0 ? _b : childStyle_1[cornerToStyle(k, true)]) !== null && _c !== void 0 ? _c : childStyle_1 === null || childStyle_1 === void 0 ? void 0 : childStyle_1.borderRadius;
                });
            }
            return mergedStyle;
        })();
        /** Round and zero negative radius values */
        var radiiPreSizeLimit = objFromKeys(cornersArray, function (k) { var _a; return R(Math.max((_a = cornerRadiusPartial[k]) !== null && _a !== void 0 ? _a : 0, 0)); });
        var result = radiiPreSizeLimit;
        if (typeof width === "number" && typeof height === "number") {
            // https://css-tricks.com/what-happens-when-border-radii-overlap/
            // Note that the tutorial above doesn't mention the specification of minRatio < 1 but it's required as said on spec and will malfunction without it.
            var minRatio_1 = Math.min(
            // 'x / 0 = Infinity' is js, not a problem here.
            width / (radiiPreSizeLimit.topLeft + radiiPreSizeLimit.topRight), // top
            height / (radiiPreSizeLimit.topRight + radiiPreSizeLimit.bottomRight), // right
            width / (radiiPreSizeLimit.bottomLeft + radiiPreSizeLimit.bottomRight), // bottom
            height / (radiiPreSizeLimit.topLeft + radiiPreSizeLimit.bottomLeft) // left
            );
            if (minRatio_1 < 1)
                result = objFromKeys(cornersArray, function (k) {
                    return R(radiiPreSizeLimit[k] * minRatio_1);
                });
        }
        return result;
    }, [
        children,
        getChildRadius,
        getViewStyleRadius,
        height,
        radiusProp,
        viewStyle,
        width,
    ]);
    var shadow = useMemo(function () {
        var _a, _b;
        // Skip if using safeRender and we still don't have the exact sizes, if we are still on the first render using the relative sizes.
        if (safeRender && (typeof width === "string" || typeof height === "string"))
            return null;
        // polished vs 'transparent': https://github.com/styled-components/polished/issues/566. Maybe tinycolor2 would allow it.
        var startColor = startColorProp === "transparent" ? "#0000" : startColorProp;
        var finalColor = finalColorProp === "transparent" ? "#0000" : finalColorProp;
        var startColorRgb = parseToRgb(startColor);
        var finalColorRgb = parseToRgb(finalColor);
        // [*1]: Seems that SVG in web accepts opacity in hex color, but in mobile doesn't.
        // So we remove the opacity from the color, and only apply the opacity in stopOpacity, so in web
        // it isn't applied twice.
        var startColorWoOpacity = rgbToColorString(__assign(__assign({}, startColorRgb), { alpha: undefined })); // overwrite alpha
        var finalColorWoOpacity = rgbToColorString(__assign(__assign({}, finalColorRgb), { alpha: undefined }));
        var startColorOpacity = (_a = startColorRgb.alpha) !== null && _a !== void 0 ? _a : 1;
        var finalColorOpacity = (_b = finalColorRgb.alpha) !== null && _b !== void 0 ? _b : 1;
        var topLeft = radii.topLeft, topRight = radii.topRight, bottomLeft = radii.bottomLeft, bottomRight = radii.bottomRight;
        var cornerShadowRadius = {
            // Not using objFromKeys here as the key is different
            topLeftShadow: sumDps(topLeft, distance),
            topRightShadow: sumDps(topRight, distance),
            bottomLeftShadow: sumDps(bottomLeft, distance),
            bottomRightShadow: sumDps(bottomRight, distance),
        };
        var topLeftShadow = cornerShadowRadius.topLeftShadow, topRightShadow = cornerShadowRadius.topRightShadow, bottomLeftShadow = cornerShadowRadius.bottomLeftShadow, bottomRightShadow = cornerShadowRadius.bottomRightShadow;
        /** Which sides will have shadow. */
        var activeSides = objFromKeys(sidesArray, function (k) {
            return sidesProp.includes(k);
        });
        /** Which corners will have shadow. */
        var activeCorners = objFromKeys(cornersArray, function (k) { return cornersProp.includes(k); });
        // Fragment wasn't working for some reason, so, using array.
        var linearGradient = [
            // [*1] In mobile, it's required for the alpha to be set in opacity prop to work.
            // In web, smaller offsets needs to come before, so offset={0} definition comes first.
            React.createElement(Stop, { offset: 0, stopColor: startColorWoOpacity, stopOpacity: startColorOpacity, key: "1" }),
            React.createElement(Stop, { offset: 1, stopColor: finalColorWoOpacity, stopOpacity: finalColorOpacity, key: "2" }),
        ];
        function radialGradient(id, top, left, radius, shadowRadius) {
            return (React.createElement(RadialGradient, { id: id, cx: left ? shadowRadius : 0, cy: top ? shadowRadius : 0, r: shadowRadius, gradientUnits: "userSpaceOnUse" // won't show if this isn't set
             },
                React.createElement(Stop, { offset: radius / shadowRadius, stopColor: startColorWoOpacity, stopOpacity: startColorOpacity }),
                React.createElement(Stop, { offset: 1, stopColor: finalColorWoOpacity, stopOpacity: finalColorOpacity })));
        }
        return (React.createElement(React.Fragment, null,
            activeSides.left && (React.createElement(Svg, { width: distanceWithAdditional, height: heightWithAdditional, style: __assign({ position: "absolute", left: -distance, top: topLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null,
                    React.createElement(LinearGradient, { id: "left", x1: "1", y1: "0", x2: "0", y2: "0" }, linearGradient)),
                React.createElement(Rect, { width: distance, height: height, fill: "url(#left)", y: -sumDps(topLeft, bottomLeft) }))),
            activeSides.right && (React.createElement(Svg, { width: distanceWithAdditional, height: heightWithAdditional, style: __assign({ position: "absolute", left: width, top: topRight }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null,
                    React.createElement(LinearGradient, { id: "right", x1: "0", y1: "0", x2: "1", y2: "0" }, linearGradient)),
                React.createElement(Rect, { width: distance, height: height, fill: "url(#right)", y: -sumDps(topRight, bottomRight) }))),
            activeSides.bottom && (React.createElement(Svg, { width: widthWithAdditional, height: distanceWithAdditional, style: __assign({ position: "absolute", top: height, left: bottomLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null,
                    React.createElement(LinearGradient, { id: "bottom", x1: "0", y1: "0", x2: "0", y2: "1" }, linearGradient)),
                React.createElement(Rect, { width: width, height: distance, fill: "url(#bottom)", x: -sumDps(bottomLeft, bottomRight) }))),
            activeSides.top && (React.createElement(Svg, { width: widthWithAdditional, height: distanceWithAdditional, style: __assign({ position: "absolute", top: -distance, left: topLeft }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null,
                    React.createElement(LinearGradient, { id: "top", x1: "0", y1: "1", x2: "0", y2: "0" }, linearGradient)),
                React.createElement(Rect, { width: width, height: distance, fill: "url(#top)", x: -sumDps(topLeft, topRight) }))),
            activeCorners.topLeft && (React.createElement(Svg, { width: topLeftShadow + additional, height: topLeftShadow + additional, style: __assign({ position: "absolute", top: -distance, left: -distance }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null, radialGradient("topLeft", true, true, topLeft, topLeftShadow)),
                React.createElement(Path, { fill: "url(#topLeft)", d: "M0," + topLeftShadow + " a" + topLeftShadow + "," + topLeftShadow + " 0 0 1 " + topLeftShadow + " " + -topLeftShadow + " v" + distance + " " + (paintInside
                        ? "v" + topLeft + " h" + -topLeft // read [*2] below for the explanation for this
                        : "a" + topLeft + "," + topLeft + " 0 0 0 " + -topLeft + "," + topLeft) + " h" + -distance + " Z" }))),
            activeCorners.topRight && (React.createElement(Svg, { width: topRightShadow + additional, height: topRightShadow + additional, style: {
                    position: "absolute",
                    top: -distance,
                    left: width,
                    transform: __spreadArray([
                        { translateX: isRTL ? topRight : -topRight }
                    ], (isRTL ? [{ scaleX: -1 }] : []), true),
                } },
                React.createElement(Defs, null, radialGradient("topRight", true, false, topRight, topRightShadow)),
                React.createElement(Path, { fill: "url(#topRight)", d: "M0,0 a" + topRightShadow + "," + topRightShadow + " 0 0 1 " + topRightShadow + "," + topRightShadow + " h" + -distance + " " + (paintInside
                        ? "h" + -topRight + " v" + -topLeft
                        : "a" + topRight + "," + topRight + " 0 0 0 " + -topRight + "," + -topRight) + " v" + -distance + " Z" }))),
            activeCorners.bottomLeft && (React.createElement(Svg, { width: bottomLeftShadow + additional, height: bottomLeftShadow + additional, style: {
                    position: "absolute",
                    top: height,
                    left: -distance,
                    transform: __spreadArray([
                        { translateY: -bottomLeft }
                    ], (isRTL ? [{ scaleX: -1 }] : []), true),
                } },
                React.createElement(Defs, null, radialGradient("bottomLeft", false, true, bottomLeft, bottomLeftShadow)),
                React.createElement(Path, { fill: "url(#bottomLeft)", d: "M" + bottomLeftShadow + "," + bottomLeftShadow + " a" + bottomLeftShadow + "," + bottomLeftShadow + " 0 0 1 " + -bottomLeftShadow + "," + -bottomLeftShadow + " h" + distance + " " + (paintInside
                        ? "h" + bottomLeft + " v" + bottomLeft
                        : "a" + bottomLeft + "," + bottomLeft + " 0 0 0 " + bottomLeft + "," + bottomLeft) + " v" + distance + " Z" }))),
            activeCorners.bottomRight && (React.createElement(Svg, { width: bottomRightShadow + additional, height: bottomRightShadow + additional, style: {
                    position: "absolute",
                    top: height,
                    left: width,
                    transform: __spreadArray([
                        { translateX: isRTL ? bottomRight : -bottomRight },
                        { translateY: -bottomRight }
                    ], (isRTL ? [{ scaleX: -1 }] : []), true),
                } },
                React.createElement(Defs, null, radialGradient("bottomRight", false, false, bottomRight, bottomRightShadow)),
                React.createElement(Path, { fill: "url(#bottomRight)", d: "M" + bottomRightShadow + ",0 a" + bottomRightShadow + "," + bottomRightShadow + " 0 0 1 " + -bottomRightShadow + "," + bottomRightShadow + " v" + -distance + " " + (paintInside
                        ? "v" + -bottomRight + " h" + bottomRight
                        : "a" + bottomRight + "," + bottomRight + " 0 0 0 " + bottomRight + "," + -bottomRight) + " h" + distance + " Z" }))),
            paintInside && (React.createElement(Svg, { width: widthWithAdditional, height: heightWithAdditional, style: __assign({ position: "absolute" }, (isRTL && { transform: [{ scaleX: -1 }] })) },
                React.createElement(Defs, null,
                    React.createElement(Mask, { id: "maskPaintBelow" },
                        React.createElement(Rect, { width: width, height: height, fill: "#fff" }),
                        React.createElement(Rect, { width: topLeft, height: topLeft, fill: "#000" }),
                        React.createElement(Rect, { width: topRight, height: topRight, x: width, transform: "translate(" + -topRight + ", 0)", fill: "#000" }),
                        React.createElement(Rect, { width: bottomLeft, height: bottomLeft, y: height, transform: "translate(0, " + -bottomLeft + ")", fill: "#000" }),
                        React.createElement(Rect, { width: bottomRight, height: bottomRight, x: width, y: height, transform: "translate(" + -bottomRight + ", " + -bottomRight + ")", fill: "#000" }))),
                React.createElement(Rect, { width: width, height: height, mask: "url(#maskPaintBelow)", fill: startColorWoOpacity, fillOpacity: startColorOpacity })))));
    }, [
        safeRender,
        width,
        height,
        startColorProp,
        finalColorProp,
        radii,
        distance,
        distanceWithAdditional,
        heightWithAdditional,
        widthWithAdditional,
        paintInside,
        sidesProp,
        cornersProp,
        isRTL,
    ]);
    var result = useMemo(function () {
        return (
        // pointerEvents: https://github.com/SrBrahma/react-native-shadow-2/issues/24
        React.createElement(View, { style: [containerViewStyle], pointerEvents: "box-none" },
            React.createElement(View, __assign({ pointerEvents: "none" }, shadowViewProps, { style: [
                    __assign(__assign({}, StyleSheet.absoluteFillObject), { left: offsetX, top: offsetY }),
                    shadowViewProps === null || shadowViewProps === void 0 ? void 0 : shadowViewProps.style,
                ] }), shadow),
            React.createElement(View, { pointerEvents: "box-none", style: [
                    // Without alignSelf: 'flex-start', if your Shadow component had a sibling under the same View, the shadow would try to have the same size of the sibling,
                    // being it for example a text below the shadowed component. https://imgur.com/a/V6ZV0lI, https://github.com/SrBrahma/react-native-shadow-2/issues/7#issuecomment-899764882
                    { alignSelf: "flex-start" },
                    sizeProp && {
                        width: width,
                        height: height,
                        borderTopLeftRadius: radii.topLeft,
                        borderTopRightRadius: radii.topRight,
                        borderBottomLeftRadius: radii.bottomLeft,
                        borderBottomRightRadius: radii.bottomRight,
                    },
                    viewStyle,
                ], onLayout: function (e) {
                    var _a;
                    if (sizeProp)
                        // For some really strange reason, attaching conditionally the onLayout wasn't working
                        return; // on condition change, so we check here inside if the sizeProp is defined.
                    // [web] [*3]: the width/height we get here is already rounded by RN, even if the real size according to the browser
                    // inspector is decimal. It will round up if (>= .5), else, down.
                    var layout = (_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.layout;
                    setChildWidth(layout.width); // In web to round decimal values to integers. In mobile it's already rounded.
                    setChildHeight(layout.height);
                } }, children)));
    }, [
        containerViewStyle,
        offsetX,
        offsetY,
        shadowViewProps,
        shadow,
        sizeProp,
        width,
        height,
        radii.topLeft,
        radii.topRight,
        radii.bottomLeft,
        radii.bottomRight,
        viewStyle,
        children,
    ]);
    return result;
};
