//
//  KwaiImageView.m
//  react-native-kwai-image
//
//  Created by jiaozhiyu on 2020/11/12.
//

#import "KwaiImageView.h"
#import <SDWebImage/UIImage+MultiFormat.h>
#import <SDWebImage/SDImageCodersManager.h>
#import <React/RCTEventDispatcher.h>
#import <KSWebImage/UIImageView+KSImageResource.h>
#import <React/RCTLog.h>
#import <React/RCTUIManager.h>
#import <React/RCTImageUtils.h>
#import <React/KDSReactCoreSwitchConfigCenter.h>
#import <KSWebImage/KSImageAssetExtraMessage.h>
#import <KSWebImage/KSImageImageSourceDefine.h>
#import <KSWebImage/KSImageSubSolutionDefine.h>
#import <KSWebImage/KSWebimageHelper.h>
#import "KwaiImageViewManager.h"
#import <KRNComponentHelp/KRNComponentHelp.h>
#import <React/RCTComponent.h>

static inline BOOL _Float_Equal(CGFloat f1, CGFloat f2)
{
    CGFloat epsilon = FLT_EPSILON; //fix by jinjie:之前是0.0000001，精读不是很准确，用系统的吧，有坑的话请联系我
    return fabs(f1 - f2) <= epsilon;
}

#define KSFloatEqual(f1, f2) _Float_Equal((f1), (f2))
#define KSFloatEqualZero(f) _Float_Equal((f), 0)
#define KSFloatLess(f1, f2) !(KSFloatEqual(f1, f2)) && f1 < f2
#define KSFloatLessOrEqual(f1, f2) !(KSFloatLess(f2, f1))

#define WS __weak typeof(self) weakSelf = self;
#define SS __strong typeof(weakSelf) self = weakSelf;

static CGFloat RCT_IMAGE_SIZE_SCALE_FACTOR_THRESHOLD = 3.f;
static CGFloat RCT_IMAGE_MEMORY_FACTOR_THRESHOLD = 2*1024;

void Kwai_RCTSetImageScaleThreshold(CGFloat scale)
{
    RCT_IMAGE_SIZE_SCALE_FACTOR_THRESHOLD = scale;
}

void Kwai_RCTSetImageMemoryThreshold(CGFloat memory)
{
    RCT_IMAGE_MEMORY_FACTOR_THRESHOLD = memory;
}

static inline bool RCTShouldWarningForImageSize(CGSize imageSize, CGSize viewSize, CGFloat sizeThreshold)
{
    // 小于 0 则不限制
    if (sizeThreshold < 0) {
        return false;
    }
    
    // 宽高为 0 则不提示
    if (KSFloatEqualZero(viewSize.width) || KSFloatEqualZero(viewSize.height)) {
        return false;
    }
    
    if (imageSize.width > viewSize.width * sizeThreshold) {
        return true;
    }
    
    if (imageSize.height > viewSize.height * sizeThreshold) {
        return true;
    }
    
    return false;
}

static inline bool RCTShouldWarningForImageMemory(UIImage *image, CGFloat *memory, CGFloat memoryThreshold)
{
    if (memoryThreshold < 0) {
        return false;
    }
    // 计算图片内存大小
    CGSize imageSize = CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);
    CGFloat bytesPerPixel = 4.0;
    CGFloat bytesPerSize = imageSize.width * imageSize.height;
    *memory = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;
    
    if (*memory > memoryThreshold * 1024) {
        return true;
    }
    
    return false;
}

static BOOL RCTShouldReloadImageForSizeChange(CGSize currentSize, CGSize idealSize) {
  static const CGFloat upscaleThreshold = 1.2;
  static const CGFloat downscaleThreshold = 0.5;

  CGFloat widthMultiplier = idealSize.width / currentSize.width;
  CGFloat heightMultiplier = idealSize.height / currentSize.height;
    
  return widthMultiplier > upscaleThreshold || widthMultiplier < downscaleThreshold ||
    heightMultiplier > upscaleThreshold || heightMultiplier < downscaleThreshold;
}

static inline BOOL ShouldEnableMemoryOpt() {
    static BOOL _shouldEnableMemoryOpt = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSDictionary *config = RCTSwitchForKey(@"kdsMemoryOptConfig");
        _shouldEnableMemoryOpt = [config[@"imageAutoCropAndRelease"] boolValue];
    });
    return _shouldEnableMemoryOpt;
}

static inline BOOL ShouldStartAnimatingWhenLoaded() {
    static BOOL _shouldStartAnimatingWhenLoaded = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _shouldStartAnimatingWhenLoaded = [RCTSwitchForKey(@"enableKwaiImageStartAnimatingWhenLoaded") boolValue];
    });
    return _shouldStartAnimatingWhenLoaded;
}

static inline BOOL ShouldLoadEmptySource() {
    static BOOL _shouldLoadEmptySource = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _shouldLoadEmptySource = [RCTSwitchForKey(@"enableKwaiImageLoadEmptySource") boolValue];
    });
    return _shouldLoadEmptySource;
}

static inline BOOL ShouldLoadDefaultSourceAsynchronous() {
    static BOOL _shouldLoadDefaultSourceAsynchronous = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _shouldLoadDefaultSourceAsynchronous = [RCTSwitchForKey(@"enableKwaiImageLoadDefaultSourceAsynchronous") boolValue];
    });
    return _shouldLoadDefaultSourceAsynchronous;
}

#ifdef DEBUG
#define DebugLog(...) NSLog(__VA_ARGS__)
#else
#define DebugLog(...) (void)0
#endif

#define KSPOD_NAME @"react-native-kwai-image"

@interface KwaiImageView()

@property (nonatomic, assign) BOOL hasSentOnLoadStart;
@property (nonatomic, assign) BOOL hasCompleted;
@property (nonatomic, assign) BOOL hasErrored;
// Whether the latest change of props requires the image to be reloaded
@property (nonatomic, assign) BOOL needsReload;

@property (nonatomic, copy) NSDictionary* onLoadEvent;
@property (nonatomic, strong) SDAnimatedImageView *realImageView;
@property (nonatomic, strong) KSWebImageLoadResult *loadResult;
@property (nonatomic, strong) UIImage *defaultImage;
@property (nonatomic, weak) RCTBridge *bridge;
@property (nonatomic, assign) BOOL isAnimatedImage;

@end


@implementation KwaiImageView {
    CGSize _trgetSize;
    KwaiImageSource *_targetSource;
}

- (instancetype)initWithBridge:(RCTBridge *)bridge {
    if ((self = [super init])) {
        _realImageView = [[SDAnimatedImageView alloc] init];
        _realImageView.clipsToBounds = YES;
        _source = [KwaiImageSource new];
        _bridge = bridge;
        self.resizeMode = RCTResizeModeCover;
        self.clipsToBounds = YES;
        _useDefaultCacheKey = YES;
        _refreshCache = NO;
        _playAnimatedImage = YES;
        [self addSubview:_realImageView];
        
        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
        [center addObserver:self
                   selector:@selector(clearImageIfDetached)
                       name:UIApplicationDidReceiveMemoryWarningNotification
                     object:nil];
        [center addObserver:self
                   selector:@selector(clearImageIfDetached)
                       name:UIApplicationDidEnterBackgroundNotification
                     object:nil];
    }
    return self;
}

- (void)dealloc {
    @autoreleasepool {
      [_bridge.eventDispatcher.bridge.uiManager imageComponentDidReleased:self];
    }
}

- (void)clearImageIfDetached {
    if (ShouldEnableMemoryOpt() && !self.window) {
        RCTLogTrace(@"KwaiImageView<%p> clearImageIfDetached: image<%@>",
                    self,
                    self.image);
        [self clearImage];
    }
}

- (void)clearImage {
    _targetSource = nil;
    self.image = nil;
}

- (void)didMoveToWindow {
    [super didMoveToWindow];
    if (ShouldEnableMemoryOpt() &&
        self.window &&
        !self.image &&
        _targetSource != _source) {
        RCTLogTrace(@"KwaiImageView<%p> reloadImage by window set: frame(%f, %f)",
                    self,
                    self.frame.size.width,
                    self.frame.size.height);
        [self reloadImage];
    }
}

- (void)layoutSubviews {
    [super layoutSubviews];
    _realImageView.frame = self.bounds;
}

- (void)setResizeMode:(RCTResizeMode)resizeMode {
    if (_resizeMode != resizeMode) {
        _resizeMode = resizeMode;
        _realImageView.contentMode = (UIViewContentMode)resizeMode;
    }
}

- (void)setUseDefaultCacheKey:(BOOL)useDefaultCacheKey {
    if (_useDefaultCacheKey != useDefaultCacheKey) {
        _useDefaultCacheKey = useDefaultCacheKey;
    }
}

- (void)setRefreshCache:(BOOL)refreshCache {
    if (_refreshCache != refreshCache) {
        _refreshCache = refreshCache;
    }
}

- (void)setCropSize:(CGSize)cropSize {
    if (!CGSizeEqualToSize(_cropSize, cropSize) && cropSize.width > 0 && cropSize.height > 0 ) {
        _cropSize = cropSize;
    }
}

- (void)setDefaultSrc:(NSDictionary *)defaultSrc {
    if (![_defaultSrc isEqualToDictionary:defaultSrc]) {
        _defaultSrc = defaultSrc.copy;
        NSString *uriString = [defaultSrc objectForKey:@"uri"];
        if (uriString) {
            if (ShouldLoadDefaultSourceAsynchronous()) {
                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                    if (!self.realImageView.image) {
                        NSURL *imageUri = [[NSURL alloc] initWithString:uriString];
                        self.defaultImage = [UIImage sd_imageWithData:[NSData dataWithContentsOfURL:imageUri]];
                        dispatch_async(dispatch_get_main_queue(), ^{
                            if (!self.realImageView.image) {
                                self.realImageView.image = self.defaultImage.copy;
                            }
                        });
                    }
                });
            } else {
                NSURL *imageUri = [[NSURL alloc] initWithString:uriString];
                _defaultImage = [UIImage sd_imageWithData:[NSData dataWithContentsOfURL:imageUri]];
            }
        } else {
            _defaultImage = nil;
        }
    }
}

- (void)setImageWarningThreshold:(NSDictionary *)imageWarningThreshold {
    if (![_imageWarningThreshold isEqualToDictionary:imageWarningThreshold]) {
        _imageWarningThreshold = imageWarningThreshold.copy;
    }
}

+ (RCTResizeMode)type:(id)json RCT_DYNAMIC {
  static NSDictionary *mapping;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    mapping = (@{
      @"cover": @(RCTResizeModeCover),
      @"contain": @(RCTResizeModeContain),
      @"stretch": @(RCTResizeModeStretch),
      @"center": @(RCTResizeModeCenter),
      @"repeat": @(RCTResizeModeRepeat),
    });
  });
  return _RCT_CAST(type, [RCTConvertEnumValue("RCTResizeMode", mapping, @(RCTResizeModeStretch), json) integerValue]);
}


- (void)setOnKwaiImageLoadEnd:(RCTDirectEventBlock)onKwaiImageLoadEnd {
    _onKwaiImageLoadEnd = onKwaiImageLoadEnd;
    if (self.hasCompleted) {
        [self sendOnLoadEnd];
    }
}

- (void)setOnKwaiImageLoad:(RCTDirectEventBlock)onKwaiImageLoad {
    _onKwaiImageLoad = onKwaiImageLoad;
    if (self.hasCompleted && _onKwaiImageLoad) {
        _onKwaiImageLoad(self.onLoadEvent);
    }
}

- (void)setOnKwaiImageError:(RCTDirectEventBlock)onKwaiImageError {
    _onKwaiImageError = onKwaiImageError;
    if (self.hasErrored && _onKwaiImageError) {
        _onKwaiImageError(@{});
    }
}

- (void)setOnKwaiImageLoadStart:(RCTDirectEventBlock)onKwaiImageLoadStart {
    if (_source && !self.hasSentOnLoadStart) {
        _onKwaiImageLoadStart = onKwaiImageLoadStart;
        if (onKwaiImageLoadStart) {
            onKwaiImageLoadStart(@{});
        }
        self.hasSentOnLoadStart = YES;
    } else {
        _onKwaiImageLoadStart = onKwaiImageLoadStart;
        self.hasSentOnLoadStart = NO;
    }
}

- (void)setOnKwaiImageGifPlayEnd:(RCTDirectEventBlock)onKwaiImageGifPlayEnd {
    _onKwaiImageGifPlayEnd = onKwaiImageGifPlayEnd;
    _realImageView.loopCompletionBlock = ^(NSUInteger loopCount) {
        if (onKwaiImageGifPlayEnd) {
            onKwaiImageGifPlayEnd(@{});
        }
    };
}

- (void)setImageColor:(UIColor *)imageColor {
    if (imageColor != nil) {
        _imageColor = imageColor;
        _realImageView.image = [self makeImage:_realImageView.image withTint:self.imageColor];
    }
}

- (void)setAnimatedLoopCount:(NSInteger)animatedLoopCount {
    if (_animatedLoopCount != animatedLoopCount) {
        _animatedLoopCount = animatedLoopCount;
        [_realImageView setShouldCustomLoopCount:YES];
        if (animatedLoopCount <= 0) {
            _realImageView.animationRepeatCount = 0; // 0 和负数都无意义，将无限循环播放
        } else {
            _realImageView.animationRepeatCount = animatedLoopCount;
        }
    }
}

- (UIImage*)makeImage:(UIImage *)image withTint:(UIColor *)color {
    UIImage *newImage = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
    UIGraphicsBeginImageContextWithOptions(image.size, NO, newImage.scale);
    [color set];
    [newImage drawInRect:CGRectMake(0, 0, image.size.width, newImage.size.height)];
    newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}

- (void)checkImageWarning:(UIImage *)image {
#if defined(DEBUG) || defined(BETA) 
    CGSize viewSize = CGSizeMake(self.frame.size.width * RCTScreenScale(), self.frame.size.height * RCTScreenScale());
    CGFloat sizeWarningThreshold = [[_imageWarningThreshold valueForKey:@"imageSizeWarningThreshold"] doubleValue] ?: RCT_IMAGE_SIZE_SCALE_FACTOR_THRESHOLD;
    CGFloat memoryWarningThreshold = [[_imageWarningThreshold objectForKey:@"imageMemoryWarningThreshold"] doubleValue] ?: RCT_IMAGE_MEMORY_FACTOR_THRESHOLD;
    CGSize imageSize =  CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);
    BOOL shouldWarn = RCTShouldWarningForImageSize(imageSize, viewSize, sizeWarningThreshold);
    if (shouldWarn) {
        RCTLogWarn(@"图片宽高(%@x%@)超过了ImageView宽高(%@x%@)的%@倍\nurl:%@\n可通过 cropSize 属性来裁剪图片以减小图片大小，或者设置属性`imageWarningThreshold = {{imageSizeWarningThreshold:-1}}`关闭警告", @(imageSize.width),
                   @(imageSize.height), @(viewSize.width), @(viewSize.height), @(sizeWarningThreshold), self.loadResult.currentURL.absoluteString);
    }
    CGFloat memory = 0;
    shouldWarn = RCTShouldWarningForImageMemory(image, &memory, memoryWarningThreshold);
    if (shouldWarn) {
        RCTLogWarn(@"图片内存(%@ kb)超过了内存阈值(%@ kb)\nurl:%@\n可通过 cropSize 属性来裁剪图片以减小图片大小，或者通过`imageWarningThreshold = {{imageMemoryWarningThreshold:-1}}`关闭警告", @(memory/1024), @(memoryWarningThreshold), self.loadResult.currentURL.absoluteString);
    }
    [self checkImageFormat:image];
#endif
}

- (UIImage *)image {
    return _realImageView.image;
}

- (void)setImage:(UIImage *)image {
    [self checkImageWarning:image];
    if (self.imageColor != nil) {
        _realImageView.image = [self makeImage:image withTint:self.imageColor];
    } else {
        _realImageView.image = image;
    }
    [_bridge.eventDispatcher.bridge.uiManager imageComponent:self
                                          didSetImage:image];
}

- (void)sendOnLoad:(UIImage *)image {
    self.onLoadEvent = @{
                         @"width":[NSNumber numberWithDouble:image.size.width],
                         @"height":[NSNumber numberWithDouble:image.size.height],
                         @"isAnimatedImage": @(self.isAnimatedImage)
                         };
    if (self.onKwaiImageLoad) {
        self.onKwaiImageLoad(self.onLoadEvent);
    }
}

- (void)sendOnLoadEnd {
    if (self.onKwaiImageLoadEnd) {
        self.onKwaiImageLoadEnd(@{});
    }
}

- (void)setSource:(KwaiImageSource *)source {
    if (![_source isEqualToKwaiImageSource:source]) {
        _source = source;
        _needsReload = YES;
        RCTLogTrace(@"KwaiImageView<%p> changeSource: %@, %@", self, source.uri, source.urls);
    }
}

- (void)setPlayAnimatedImage:(BOOL)playAnimatedImage {
    if (_playAnimatedImage != playAnimatedImage) {
        _playAnimatedImage = playAnimatedImage;
        BOOL imageLoaded = _realImageView.image != nil;
        if (!imageLoaded) {
            _realImageView.autoPlayAnimatedImage = playAnimatedImage;
        } else {
            if (playAnimatedImage) {
                [_realImageView startAnimating];
            } else {
                [_realImageView stopAnimating];
            }
        }
    }
}

- (void)reactSetFrame:(CGRect)frame {
    [super reactSetFrame:frame];
    
    if (ShouldEnableMemoryOpt()) {
        if (frame.size.width <= 0 || frame.size.height <= 0) {
            RCTLogTrace(@"KwaiImageView<%p> set frame zero! frame(%f, %f), image(%f, %f)",
                        self,
                        frame.size.width,
                        frame.size.height,
                        self.image.size.width,
                        self.image.size.height);
            // 此处防止使用方故意设置成0只为加载图片，只在首次加载图片时使用
            if (!_loadResult) {
                _trgetSize = CGSizeZero;
                [self downloadImage];
                return;
            }
        }
        
        CGSize imageSize = CGSizeMake(self.image.size.width * self.image.scale,
                                      self.image.size.height * self.image.scale);
        CGSize frameSize = CGSizeMake(frame.size.width * RCTScreenScale(),
                                      frame.size.height * RCTScreenScale());
        
        if (_targetSource != _source) {
            RCTLogTrace(@"KwaiImageView<%p> reloadImage by source change: frame(%f, %f), image(%f, %f)",
                        self,
                        frameSize.width,
                        frameSize.height,
                        imageSize.width,
                        imageSize.height);
            _trgetSize = frameSize;
            [self reloadImage];
            return;
        }
        
        CGSize idealSize = RCTTargetSize(imageSize, 1, frameSize, 1, (RCTResizeMode)self.contentMode, YES);
        if (RCTShouldReloadImageForSizeChange(imageSize, idealSize) &&
            RCTShouldReloadImageForSizeChange(_trgetSize, idealSize)) {
            RCTLogTrace(@"KwaiImageView<%p> reloadImage by frame change: frame(%f, %f), image(%f, %f), ideal(%f, %f)",
                        self,
                        frameSize.width,
                        frameSize.height,
                        imageSize.width,
                        imageSize.height,
                        idealSize.width,
                        idealSize.height);
            //  用来防止小图每次frame更新时都重新加载
            _trgetSize = idealSize;
            [self reloadImage];
        }
    }
}

- (void)didSetProps:(NSArray<NSString *> *)changedProps
{
    if (_needsReload) {
        RCTLogTrace(@"KwaiImageView<%p> reloadImage by didSetProps: frame(%f, %f), image(%f, %f)",
                    self,
                    self.frame.size.width,
                    self.frame.size.height,
                    self.image.size.width,
                    self.image.size.height);
        [self reloadImage];
    }
}

- (void)reloadImage {
    _needsReload = NO;
    if (ShouldEnableMemoryOpt() && (self.frame.size.width <= 0 || self.frame.size.height <= 0)) {
        RCTLogTrace(@"KwaiImageView<%p> reloadImage but frame is zero: image(%f, %f)",
                    self,
                    self.image.size.width,
                    self.image.size.height);
        [self clearImage];
        return;
    }
    [self downloadImage];
}

- (void)downloadImage {
    _needsReload = NO;
    if (ShouldLoadEmptySource() || _source || _defaultImage) {
        _targetSource = _source;
        NSString* url = [_source.uri absoluteString];
        BOOL isBase64 = [url hasPrefix:@"data:image"];
        BOOL isLocalSource = url && (isBase64 || [url hasPrefix:@"file:///"]);
        // handle KSImageResource
        KSImageResource *resource = [self bridgeKSSourceFromSource:_source isLocalSource:isLocalSource];
        
        // Load base64 images.
        if (isLocalSource) {
            [self handleBase64:_source resource:resource isBase64:isBase64];
            return;
        }
        
        // Set headers.
        NSDictionary *headers = _source.headers;
        SDWebImageContext *context = nil;
        SDWebImageDownloaderRequestModifier *requestModifier = [SDWebImageDownloaderRequestModifier requestModifierWithBlock:^NSURLRequest * _Nullable(NSURLRequest * _Nonnull request) {
            NSMutableURLRequest *mutableRequest = [request mutableCopy];
            for (NSString *header in headers) {
                NSString *value = headers[header];
                [mutableRequest setValue:value forHTTPHeaderField:header];
            }
            return [mutableRequest copy];
        }];
        
        /// todo: SDImageCoderDecodeFirstFrameOnly
        context = @{SDImageCoderDecodeFirstFrameOnly : @(_source.decodeFirstFrameOnly),
                    SDWebImageContextDownloadRequestModifier : requestModifier};
        
        [self handleKwaiImageLoadStart];
        
        self.hasCompleted = NO;
        self.hasErrored = NO;
        
        [self downloadImage:_source context:context resource:resource];
    }
}

- (void)handleKwaiImageLoadStart {
    if (self.onKwaiImageLoadStart) {
        self.onKwaiImageLoadStart(@{});
        self.hasSentOnLoadStart = YES;
    } 
    self.hasSentOnLoadStart = NO;
}

- (void)handleBase64:(KwaiImageSource *)source resource:(KSImageResource *)resource isBase64:(BOOL)isBase64 {
    [self handleKwaiImageLoadStart];
    KSWebImageOptions *options = KSWebImageOptions.new;
    if (isBase64) {
        // base64 格式图片需要每次都下载，不能走缓存，否则会导致只显示第一次加载的 base64 图片，需要图片库优化后解决该问题
        options.allowedSource = KSImageSourceNetwork;
    }
    options.placeholderImage = _defaultImage;
    WS
    // 这里必须使用 KSImageResource 的接口才能有上报和 log
    [self.realImageView ks_setImageWithResource:resource options:options completed:^(UIImage * _Nullable image, NSError * _Nullable error, KSWebImageLoadResult * _Nullable loadResult) {
        SS
        self.loadResult = loadResult;
        [self handleImageLoadedEvent:image];
    }];
}

- (KSImageResource *)bridgeKSSourceFromSource:(KwaiImageSource *)source isLocalSource:(BOOL)isLocalSource {
    if (!source) return nil;
    NSArray <NSDictionary *> *cdnURLs;
    if (!isLocalSource) {
        cdnURLs = source.urls.count > 0 ? source.urls:@[@{@"url":source.uri.absoluteString ?: @"",
                                                          @"cdn": source.uri.host ?: @"",}];
    }
    
    return [[KSImageResource alloc] initWithURL:source.uri.absoluteString cdnURLs:cdnURLs pageURL:nil extraMessage:[self getExtraMessage]];
}


- (KSImageAssetExtraMessage *)getExtraMessage {
    NSString *currentBusinessBundleId = [[KRNComponentHelp sharedInstance] getBundleId:[_bridge parentBridge] rootTag:self.rootTag] ?: @"";
    
    return [[KSImageAssetExtraMessage alloc] initWithImageSource:KSImageSourceKRN bizFt:KSPOD_NAME subSolution:KSImageSubSolutionKRN bundleId:currentBusinessBundleId];
}


- (KSImagePriority)bridgePriorityFromSource:(KwaiImageSource *)source {
    KSImagePriority priority = KSImagePriorityNormal;
    switch (source.priority) {
        case KwaiImagePriorityLow:
            priority = KSImagePriorityLow;
            break;
        case KwaiImagePriorityNormal:
            priority = KSImagePriorityNormal;
            break;
        case KwaiImagePriorityHigh:
            priority = KSImagePriorityHigh;
            break;
        default:
            break;
    }
    return priority;
}

- (KSImageSourceType)bridgeAllowedSource:(KwaiImageCacheControl)cacheControl {
    KSImageSourceType allowedSource = KSImageSourceAll;
    switch (cacheControl) {
        case KwaiImageCacheControlCacheOnly:
            allowedSource = KSImageSourceCache;
            break;
        case KwaiImageCacheControlWeb:
            allowedSource = KSImageSourceNetwork;
            break;
        case KwaiImageCacheControlImmutable:
        default:
            break;
    }
    return allowedSource;
}

- (KSWebImageOptions *)bridgeOptionsFromSource:(KwaiImageSource *)source context:(SDWebImageContext *)context {
    KSWebImageOptions *imageOptions = KSWebImageOptions.new;
    imageOptions.requestModifier = context[SDWebImageContextDownloadRequestModifier];   // headers
    imageOptions.priority = [self bridgePriorityFromSource:source];                     // priority
    imageOptions.allowedSource = [self bridgeAllowedSource:source.cacheControl];        // cacheControl
    if ([context[SDImageCoderDecodeFirstFrameOnly] boolValue]) {
        imageOptions.bitOptions |= KSWebImageDecodeFirstFrameOnly;
    }
    if (_refreshCache) {
        imageOptions.bitOptions |= KSWebImageRefreshCached;
    }
    if (_requestUseCookie) {
        imageOptions.bitOptions |= KSWebImageHandleCookies;
    }
    if (!_useDefaultCacheKey) {
        imageOptions.cacheKeyFilter = ^NSString * _Nullable(NSString * _Nullable cacheKey) {
            DebugLog(@"cacheKey by sdk: %@, for url: %@", cacheKey, source.uri);
            return source.uri.absoluteString;
        };
    }
    return imageOptions;
}

- (void)downloadImage:(KwaiImageSource *)source context:(SDWebImageContext *)context resource:(KSImageResource *)resource {
    __weak typeof(self) weakSelf = self; // Always use a weak reference to self in blocks
    
    KSWebImageOptions *imageOptions = [self bridgeOptionsFromSource:source context:context]; // KSWebImageOptions 的 transformer 相关接口暂时不要用，否则会有类型等问题
    imageOptions.placeholderImage = _defaultImage;
    
    if (ShouldEnableMemoryOpt() &&
        CGSizeEqualToSize(_cropSize, CGSizeZero) &&
        self.frame.size.width > 0 &&
        self.frame.size.height > 0 &&
        ![source.uri.path hasSuffix:@".gif"]) {
        CGSize thumbnailPixelSize = CGSizeMake(self.frame.size.width * RCTScreenScale(), self.frame.size.height * RCTScreenScale());
        imageOptions.thumbnailPixelSize = thumbnailPixelSize;
        imageOptions.preserveAspectRatio = YES;
        imageOptions.cdnResizeResolution = thumbnailPixelSize;
        imageOptions.cdnResizeMode = KSWebImageCDNResizeModeMfit;
    } else {
        imageOptions.thumbnailPixelSize = _cropSize;
        imageOptions.cdnResizeResolution = _cropSize;
    }
    
    RCTLogTrace(@"KwaiImageView<%p> downloadImage: frame(%f, %f), image(%f, %f), crop(%f, %f)",
                self,
                self.frame.size.width,
                self.frame.size.height,
                self.image.size.width,
                self.image.size.height,
                imageOptions.thumbnailPixelSize.width,
                imageOptions.thumbnailPixelSize.height);
    
    [_realImageView ks_setImageWithResource:resource
                          options:imageOptions
                         progress:^(int64_t receivedSize,
                                    int64_t expectedSize,
                                    NSURL * _Nullable targetURL) {
        if (weakSelf.onKwaiImageProgress) {
            weakSelf.onKwaiImageProgress(@{@"loaded": @(receivedSize), @"total": @(expectedSize)});
        }
    } completed:^(UIImage * _Nullable image,
                  NSError * _Nullable error,
                  KSWebImageLoadResult * _Nullable loadResult) {
        RCTLogTrace(@"KwaiImageView<%p> downloadComplete: %@ frame(%f, %f), image(%f, %f)",
                    weakSelf,
                    error,
                    weakSelf.frame.size.width,
                    weakSelf.frame.size.height,
                    image.size.width,
                    image.size.height);
        weakSelf.loadResult = loadResult;
        [weakSelf setImage:weakSelf.realImageView.image];
        if (error) {
            weakSelf.hasErrored = YES;
            if (weakSelf.onKwaiImageError) {
                weakSelf.onKwaiImageError(@{});
            }
        } else {
            [weakSelf sendLoadedEvent:image];
        }
        [weakSelf sendOnLoadEnd];
    }];
}

- (void)checkImageFormat:(UIImage * _Nullable)image {
    // 这里 image 做出类型判断，否则转换会导致崩溃
    if(_loadResult != nil && [image isKindOfClass:[SDAnimatedImage class]]) {
        _isAnimatedImage = [(SDAnimatedImage *)image animatedImageFrameCount] > 1;
        BOOL isAPNG = [_loadResult.decodeMessage.imageFormat isEqual:@"PNG"]  && _isAnimatedImage;
        if (isAPNG) {
            RCTLogError(@"APNG image is not supported for now");
        }
    }
}

- (void)handleImageLoadedEvent:(UIImage *)image {
    [self setImage:self.realImageView.image];
    if (self.onKwaiImageProgress) {
        self.onKwaiImageProgress(@{
            @"loaded": @(1),
            @"total": @(1)
        });
    }
    [self sendLoadedEvent:image];
    [self sendOnLoadEnd];
}

- (void)sendLoadedEvent:(UIImage *)image {
    self.hasCompleted = YES;
    [self sendOnLoad:image];
    [self startAnimatingWhenLoaded];
}

- (void)startAnimatingWhenLoaded {
    if (ShouldStartAnimatingWhenLoaded()) {
        if (self.isAnimatedImage && self.playAnimatedImage && !self.realImageView.isAnimating) {
            [self.realImageView startAnimating];
        }
    }
}

@end

