import React, { forwardRef, memo } from 'react';
import {
  View,
  Image,
  ImageResolvedAssetSource,
  ImageSourcePropType,
  NativeModules,
  requireNativeComponent,
  StyleSheet,
  FlexStyle,
  LayoutChangeEvent,
  ShadowStyleIOS,
  StyleProp,
  Platform,
  TransformsStyle,
  AccessibilityProps,
} from 'react-native';

const KwaiImageViewNativeModule = NativeModules.KwaiImageView;

export type ResizeMode = 'contain' | 'cover' | 'stretch' | 'center';

export type ResizeMethod = 'auto' | 'resize' | 'scale';

export const resizeMode = {
  contain: 'contain',
  cover: 'cover',
  stretch: 'stretch',
  center: 'center',
} as const;

export const resizeMethod = {
  auto: 'auto',
  resize: 'resize',
  scale: 'scale',
} as const;

export type Priority = 'low' | 'normal' | 'high';

export const priority = {
  low: 'low',
  normal: 'normal',
  high: 'high',
} as const;

export type Cache = 'immutable' | 'web' | 'cacheOnly';

export const cacheControl = {
  // Ignore headers, use uri as cache key, fetch only if not in cache.
  immutable: 'immutable',
  // Respect http headers, no aggressive caching.
  web: 'web',
  // Only load from cache.
  cacheOnly: 'cacheOnly',
} as const;

export type Source = {
  uri?: string;
  uris?: { [key: string]: string }[];
  headers?: { [key: string]: string };
  priority?: Priority;
  cache?: Cache;
  decodeFirstFrameOnly?: boolean;
};

export interface OnLoadEvent {
  nativeEvent: {
    width: number;
    height: number;
    isAnimatedImage: boolean;
  };
}

export interface OnProgressEvent {
  nativeEvent: {
    loaded: number;
    total: number;
  };
}

export interface OnAnimatedFrame {
  nativeEvent: {
    totalFrameCount: number;
    currentFrame: number;
  };
}

export type ImageWarningThreshold = {
  imageSizeWarningThreshold?: number; 
	imageMemoryWarningThreshold?: number;
}

export type ImageSizeResponse = {
  width?: number; 
  height?: number;
}

export interface ImageStyle extends FlexStyle, TransformsStyle, ShadowStyleIOS {
  backfaceVisibility?: 'visible' | 'hidden';
  borderBottomLeftRadius?: number;
  borderBottomRightRadius?: number;
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: number;
  borderRadius?: number;
  borderTopLeftRadius?: number;
  borderTopRightRadius?: number;
  overlayColor?: string;
  tintColor?: string;
  opacity?: number;
}

export interface KwaiImagePropsIOS {
  refreshCache?: boolean;
  useDefaultCacheKey?: boolean;
  requestUseCookie?: boolean;
}

export interface KwaiImagePropsAndroid {
  /**
   * When true, enables progressive jpeg streaming
   * @platform android
   */
   progressiveRenderingEnabled?: boolean;
   /**
    * Duration of fade in animation in ms. Defaults to 300
    *
    * @platform android
    */
   fadeDuration?: number;
   /**
    * The mechanism that should be used to resize the image when the image's dimensions
    * differ from the image view's dimensions. Defaults to 'auto'.
    *
    * - auto: Use heuristics to pick between resize and scale.
    * - resize: A software operation which changes the encoded image in memory before it gets decoded.
    *   This should be used instead of scale when the image is much larger than the view.
    * - scale: The image gets drawn downscaled or upscaled. Compared to resize, scale is
    *   faster (usually hardware accelerated) and produces higher quality images.
    *   This should be used if the image is smaller than the view.
    *   It should also be used if the image is slightly bigger than the view.
    *
    * More details about resize and scale can be found at http://frescolib.org/docs/resizing.html.
    *
    * @platform android
    */
   resizeMethod?: ResizeMethod;
   onAnimatedFrame?(event: OnAnimatedFrame): void;
}

export interface KwaiImageProps extends KwaiImagePropsAndroid, KwaiImagePropsIOS, AccessibilityProps {
  source: Source | number;
  resizeMode?: ResizeMode;
  fallback?: boolean;
  defaultSource?: Source | number;
  cropSize?: {width: number; height: number };
  playAnimatedImage?: boolean;
  animatedLoopCount?: number;

  onLoadStart?(): void;

  onProgress?(event: OnProgressEvent): void;

  onLoad?(event: OnLoadEvent): void;

  onError?(): void;

  onLoadEnd?(): void;

  onGifPlayEnd?(): void;

  /**
   * onLayout function
   * Invoked on mount and layout changes with
   * {nativeEvent: { layout: {x, y, width, height}}}.
   */
  onLayout?: (event: LayoutChangeEvent) => void;

  /**
   * Style
   */
  style?: StyleProp<ImageStyle>;

  /**
   * TintColor
   * If supplied, changes the color of all the non-transparent pixels to the given color.
   */

  tintColor?: number | string;

  /**
   * A unique identifier for this element to be used in UI Automation testing scripts.
   */
  testID?: string;

  /**
   * Render children within the image.
   */
  children?: React.ReactNode;

  /**
   * Set the image size and memory warning threshold.
   * Image size and memory warning only happen on Debug mode. 
   */
  imageWarningThreshold?: ImageWarningThreshold;
}

function KwaiImageBase({
  source,
  tintColor,
  defaultSource,
  cropSize,
  onLoadStart,
  onProgress,
  onLoad,
  onError,
  onLoadEnd,
  onGifPlayEnd,
  onAnimatedFrame,
  style,
  fallback,
  children,
  // eslint-disable-next-line no-shadow
  resizeMode = 'cover',
  resizeMethod = 'auto',
  useDefaultCacheKey = true,
  refreshCache = false,
  forwardedRef,
  ...props
}: KwaiImageProps & { forwardedRef: React.Ref<any> }) {
  if (fallback) {
    const cleanedSource = { ...(source as any) };
    const cleanedDefaultSource = { ...(defaultSource as any) };
    delete cleanedSource.cache;
    const resolvedSource = Image.resolveAssetSource(cleanedSource);
    const resolvedDefaultSource = Image.resolveAssetSource(cleanedDefaultSource);

    return (
      <View style={[styles.imageContainer, style]} ref={forwardedRef}>
        <Image
          {...props}
          style={StyleSheet.absoluteFill}
          source={resolvedSource}
          defaultSource={resolvedDefaultSource}
          onLoadStart={onLoadStart}
          onProgress={onProgress}
          onLoad={onLoad as any}
          onError={onError}
          onLoadEnd={onLoadEnd}
          resizeMode={resizeMode}
          resizeMethod={resizeMethod}
        />
        {children}
      </View>
    );
  }

  var resolvedSource = Image.resolveAssetSource(source as any);
  var resolvedDefaultSource = Image.resolveAssetSource(defaultSource as any);
  var headers = null
  if (typeof source !== 'number') {
    var safeSource = { ...(source as any) };
    if (safeSource == null || safeSource === undefined) {
      safeSource = {};
    }
    if (safeSource.uri == null || safeSource.uri === undefined) {
      safeSource.uri = '';
    }
    if (safeSource.uris === '' || safeSource.uris === undefined) {
      safeSource.uris = null;
    }
    if (safeSource.headers) {
      headers = safeSource.headers;
    }
    resolvedSource = safeSource;
  }
  if (cropSize != null && cropSize.height >0 && cropSize.width > 0) {
    resizeMethod = 'resize';
  }
  return (
    <View style={[styles.imageContainer, style]} ref={forwardedRef}>
      <KwaiImageView
        {...props}
        tintColor={tintColor}
        style={StyleSheet.absoluteFill}
        source={resolvedSource}
        defaultSrc={Platform.OS == 'ios' ? resolvedDefaultSource : resolvedDefaultSource ? resolvedDefaultSource.uri : null}
        headers={headers}
        onKwaiImageLoadStart={onLoadStart}
        onKwaiImageProgress={onProgress}
        onKwaiImageLoad={onLoad}
        onKwaiImageError={onError}
        onKwaiImageLoadEnd={onLoadEnd}
        onKwaiImageGifPlayEnd={onGifPlayEnd}
        onKwaiImageAnimatedFrame={onAnimatedFrame}
        cropSize={cropSize}
        resizeMode={resizeMode}
        resizeMethod={resizeMethod}
        useDefaultCacheKey={useDefaultCacheKey}
        refreshCache={refreshCache}
      />
      {children}
    </View>
  );
}
interface KwaiImageStaticProperties {
  resizeMode: typeof resizeMode;
  resizeMethod: typeof resizeMethod;
  priority: typeof priority;
  cacheControl: typeof cacheControl;
  preload: (sources: Source[]) => Promise<Response>;
  getSize: (uri: string) => Promise<ImageSizeResponse>;
  resolveAssetSource: (source: ImageSourcePropType) => ImageResolvedAssetSource;
}

const KwaiImageMemo = memo(KwaiImageBase);

const KwaiImageComponent: React.ComponentType<KwaiImageProps> = forwardRef(
  (props: KwaiImageProps, ref: React.Ref<any>) => (
    <KwaiImageMemo forwardedRef={ref} {...props} />
  )
);

KwaiImageComponent.displayName = 'KwaiImage';

const KwaiImage: React.ComponentType<KwaiImageProps> &
  KwaiImageStaticProperties = KwaiImageComponent as any;

KwaiImage.resizeMode = resizeMode;

KwaiImage.resizeMethod = resizeMethod;

KwaiImage.cacheControl = cacheControl;

KwaiImage.priority = priority;

KwaiImage.preload = (sources: Source[]) =>
  KwaiImageViewNativeModule.preload(sources);

KwaiImage.getSize = (uri: string) => 
  KwaiImageViewNativeModule.getSize(uri);

KwaiImage.resolveAssetSource = (source: ImageSourcePropType) =>
  Image.resolveAssetSource(source)

const styles = StyleSheet.create({
  imageContainer: {
    overflow: 'hidden',
  },
});

// Types of requireNativeComponent are not correct.
const KwaiImageView = (requireNativeComponent as any)(
  'KwaiImageView',
  KwaiImage,
  {
    nativeOnly: {
      onKwaiImageLoadStart: true,
      onKwaiImageProgress: true,
      onKwaiImageLoad: true,
      onKwaiImageError: true,
      onKwaiImageLoadEnd: true,
    },
  }
);

export default KwaiImage;
