/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.kwai.kds.image;

import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapShader;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.widget.Toast;

import com.facebook.common.logging.FLog;
import com.facebook.common.references.CloseableReference;
import com.facebook.common.util.UriUtil;
import com.facebook.drawee.controller.AbstractDraweeControllerBuilder;
import com.facebook.drawee.controller.BaseControllerListener;
import com.facebook.drawee.controller.ControllerListener;
import com.facebook.drawee.controller.ForwardingControllerListener;
import com.facebook.drawee.drawable.AutoRotateDrawable;
import com.facebook.drawee.drawable.RoundedColorDrawable;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.generic.GenericDraweeHierarchy;
import com.facebook.drawee.generic.GenericDraweeHierarchyBuilder;
import com.facebook.drawee.generic.RoundingParams;
import com.facebook.drawee.interfaces.DraweeController;
import com.facebook.drawee.view.GenericDraweeView;
import com.facebook.fresco.animation.drawable.AnimatedDrawable2;
import com.facebook.fresco.animation.drawable.AnimationListener;
import com.facebook.imagepipeline.bitmaps.PlatformBitmapFactory;
import com.facebook.imagepipeline.common.ImageDecodeOptions;
import com.facebook.imagepipeline.common.ResizeOptions;
import com.facebook.imagepipeline.common.RotationOptions;
import com.facebook.imagepipeline.image.ImageInfo;
import com.facebook.imagepipeline.postprocessors.IterativeBoxBlurPostProcessor;
import com.facebook.imagepipeline.request.BasePostprocessor;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.request.ImageRequestBuilder;
import com.facebook.imagepipeline.request.Postprocessor;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.common.build.ReactBuildConfig;
import com.facebook.react.modules.fresco.ReactNetworkImageRequest;
import com.facebook.react.uimanager.FloatUtil;
import com.facebook.react.uimanager.PixelUtil;
import com.facebook.react.uimanager.UIManagerModule;
import com.facebook.react.uimanager.events.EventDispatcher;
import com.facebook.react.util.RCTLog;
import com.facebook.react.views.image.GlobalImageLoadListener;
import com.facebook.react.views.image.ImageMemoryMonitor;
import com.facebook.react.views.image.ImageResizeMethod;
import com.facebook.react.views.image.ImageResizeMode;
import com.facebook.react.views.image.MultiPostprocessor;
import com.facebook.react.views.imagehelper.ImageSource;
import com.facebook.react.views.imagehelper.MultiSourceHelper;
import com.facebook.react.views.imagehelper.MultiSourceHelper.MultiSourceResult;
import com.facebook.react.views.imagehelper.ResourceDrawableIdHelper;
import com.facebook.yoga.YogaConstants;
import com.yxcorp.image.fresco.wrapper.FrescoUtils;
import com.yxcorp.image.fresco.wrapper.ImageCallback;

import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;

/**
 * Wrapper class around Fresco's GenericDraweeView, enabling persisting props across multiple view
 * update and consistent processing of both static and network images.
 */
@SuppressWarnings("rawtypes")
@SuppressLint("ViewConstructor")
public class ReactImageView extends GenericDraweeView {

  public static final int REMOTE_IMAGE_FADE_DURATION_MS = 300;

  public static final float IMAGE_SCALE_FACTOR_THRESHOLD = 5f;

  public static final String IMAGE_WARN = "warn";

  public static final String PROJECT_NAME = BuildConfig.PROJECT_NAME;

  /**
   * 在某些特定系统版本，使用16位的png 会导致libpng 崩溃
   * 详见: https://team.corp.kuaishou.com/task/B320452
   */
  public static final String REMOTE_TRANSPARENT_BITMAP_URI =
    "data:image/png;base64," +
      "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAFBlWElmTU0AKgAAAAgAAgESAAMAAAABAAEAAIdpAAQAAAABAAAAJgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADr/7PgAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoZXuEHAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=";

  private static float[] sComputedCornerRadii = new float[4];

  private static final String TAG = "ReactImageView";

  public static boolean DEFAULTSOURCE_USE_BITMAPCOPY = true;
  public static boolean START_ANIMATING_WHEN_LOADED = false;


  /*
   * Implementation note re rounded corners:
   *
   * Fresco's built-in rounded corners only work for 'cover' resize mode -
   * this is a limitation in Android itself. Fresco has a workaround for this, but
   * it requires knowing the background color.
   *
   * So for the other modes, we use a postprocessor.
   * Because the postprocessor uses a modified bitmap, that would just get cropped in
   * 'cover' mode, so we fall back to Fresco's normal implementation.
   */
  private static final Matrix sMatrix = new Matrix();
  private static final Matrix sInverse = new Matrix();
  private ImageResizeMethod mResizeMethod = ImageResizeMethod.AUTO;

  private static float mScaleThreshold = IMAGE_SCALE_FACTOR_THRESHOLD;


  private class RoundedCornerPostprocessor extends BasePostprocessor {

    void getRadii(Bitmap source, float[] computedCornerRadii, float[] mappedRadii) {
      mScaleType.getTransform(
        sMatrix,
        new Rect(0, 0, source.getWidth(), source.getHeight()),
        source.getWidth(),
        source.getHeight(),
        0.0f,
        0.0f);
      sMatrix.invert(sInverse);
      mappedRadii[0] = sInverse.mapRadius(computedCornerRadii[0]);
      mappedRadii[1] = mappedRadii[0];

      mappedRadii[2] = sInverse.mapRadius(computedCornerRadii[1]);
      mappedRadii[3] = mappedRadii[2];

      mappedRadii[4] = sInverse.mapRadius(computedCornerRadii[2]);
      mappedRadii[5] = mappedRadii[4];

      mappedRadii[6] = sInverse.mapRadius(computedCornerRadii[3]);
      mappedRadii[7] = mappedRadii[6];
    }

    @Override
    public void process(Bitmap output, Bitmap source) {
      cornerRadii(sComputedCornerRadii);

      output.setHasAlpha(true);
      if (FloatUtil.floatsEqual(sComputedCornerRadii[0], 0f)
        && FloatUtil.floatsEqual(sComputedCornerRadii[1], 0f)
        && FloatUtil.floatsEqual(sComputedCornerRadii[2], 0f)
        && FloatUtil.floatsEqual(sComputedCornerRadii[3], 0f)) {
        super.process(output, source);
        return;
      }
      Paint paint = new Paint();
      paint.setAntiAlias(true);
      paint.setShader(new BitmapShader(source, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP));
      Canvas canvas = new Canvas(output);

      float[] radii = new float[8];

      getRadii(source, sComputedCornerRadii, radii);

      Path pathForBorderRadius = new Path();

      pathForBorderRadius.addRoundRect(
        new RectF(0, 0, source.getWidth(), source.getHeight()), radii, Path.Direction.CW);

      canvas.drawPath(pathForBorderRadius, paint);
    }
  }

  // Fresco lacks support for repeating images, see https://github.com/facebook/fresco/issues/1575
  // We implement it here as a postprocessing step.
  private static final Matrix sTileMatrix = new Matrix();

  private class TilePostprocessor extends BasePostprocessor {
    @Override
    public CloseableReference<Bitmap> process(Bitmap source, PlatformBitmapFactory bitmapFactory) {
      final Rect destRect = new Rect(0, 0, getWidth(), getHeight());

      mScaleType.getTransform(
        sTileMatrix, destRect, source.getWidth(), source.getHeight(), 0.0f, 0.0f);

      Paint paint = new Paint();
      paint.setAntiAlias(true);
      Shader shader = new BitmapShader(source, mTileMode, mTileMode);
      shader.setLocalMatrix(sTileMatrix);
      paint.setShader(shader);

      CloseableReference<Bitmap> output = bitmapFactory.createBitmap(getWidth(), getHeight());
      try {
        Canvas canvas = new Canvas(output.get());
        canvas.drawRect(destRect, paint);
        return output.clone();
      } finally {
        CloseableReference.closeSafely(output);
      }
    }
  }

  private final List<ImageSource> mSources;

  private @Nullable
  ImageSource mImageSource;
  private @Nullable
  ImageSource mCachedImageSource;
  private @Nullable
  Drawable mDefaultImageDrawable;
  private @Nullable
  Drawable mLoadingImageDrawable;
  private @Nullable
  RoundedColorDrawable mBackgroundImageDrawable;
  private int mBackgroundColor = 0x00000000;
  private int mBorderColor;
  private int mOverlayColor;
  private float mBorderWidth;
  private float mBorderRadius = YogaConstants.UNDEFINED;
  private @Nullable
  float[] mBorderCornerRadii;
  private ScalingUtils.ScaleType mScaleType;
  private Shader.TileMode mTileMode = ImageResizeMode.defaultTileMode();
  private boolean mIsDirty;
  private final AbstractDraweeControllerBuilder mDraweeControllerBuilder;
  private final RoundedCornerPostprocessor mRoundedCornerPostprocessor;
  private final TilePostprocessor mTilePostprocessor;
  private @Nullable
  IterativeBoxBlurPostProcessor mIterativeBoxBlurPostProcessor;
  private @Nullable
  ControllerListener mControllerListener;
  private @Nullable
  ControllerListener mControllerForTesting;
  private @Nullable
  GlobalImageLoadListener mGlobalImageLoadListener;
  private final @Nullable
  Object mCallerContext;
  private int mFadeDurationMs = -1;
  private boolean mProgressiveRenderingEnabled;
  private @Nullable
  ReadableMap mHeaders;
  private boolean mMultiSourceRetryEnabled = true;

  private Integer mResizeOptionWidth = null;
  private Integer mResizeOptionHeight = null;
  private float mSizeWarningThreshold = 0;
  private boolean mPlayAnimatedImage = true;
  private boolean mAutoPlayAnimatedImage = true;
  private int lastFrameNumber = -1;
  private @Nullable ImageMemoryMonitor mImageMemoryMonitor;
  private String mBundleId;
  private volatile boolean mImageLoadSuccessfully = false;
  private boolean mIsReuseUpdate;
  private String mDefaultSourceName;
  private String mLoadingIndicatorSourceName;
  private float mBlurRadius = 0f;
  private boolean mShouldNotify;
  private int mAnimatedLoopCount = 0;
  private int mCurrentLoopCount = 0;

  // We can't specify rounding in XML, so have to do so here
  private static GenericDraweeHierarchy buildHierarchy(Context context) {
    return new GenericDraweeHierarchyBuilder(context.getResources())
      .setRoundingParams(RoundingParams.fromCornersRadius(0))
      .build();
  }

  public ReactImageView(
      Context context,
      AbstractDraweeControllerBuilder draweeControllerBuilder,
      @Nullable GlobalImageLoadListener globalImageLoadListener,
      @Nullable Object callerContext,
      @Nullable ImageMemoryMonitor imageMemoryMonitor,
      String bundleId) {
    super(context, buildHierarchy(context));
    mScaleType = ImageResizeMode.defaultValue();
    mDraweeControllerBuilder = draweeControllerBuilder;
    mRoundedCornerPostprocessor = new RoundedCornerPostprocessor();
    mTilePostprocessor = new TilePostprocessor();
    mGlobalImageLoadListener = globalImageLoadListener;
    mCallerContext = callerContext;
    mSources = new LinkedList<>();
    mImageMemoryMonitor = imageMemoryMonitor;
    mBundleId = bundleId;
    // 默认打开事件通知
    setShouldNotifyLoadEvents(true);
  }

  public void updateReuseViewPropsStart() {
    mIsReuseUpdate = true;
  }

  public void updateReuseViewPropsEnd() {
    mIsReuseUpdate = false;
  }

  public void setShouldNotifyLoadEvents(boolean shouldNotify) {
    if (mIsReuseUpdate && mShouldNotify == shouldNotify) {
      return;
    }
    mShouldNotify = shouldNotify;
    if (!shouldNotify) {
      mControllerListener = null;
    } else {
      final EventDispatcher mEventDispatcher =
        ((ReactContext) getContext()).getNativeModule(UIManagerModule.class).getEventDispatcher();

      mControllerListener =
        new BaseControllerListener<ImageInfo>() {
          @Override
          public void onSubmit(String id, Object callerContext) {
            mEventDispatcher.dispatchEvent(
              new ImageLoadEvent(getId(), ImageLoadEvent.ON_LOAD_START));
          }

          @RequiresApi(api = Build.VERSION_CODES.M)
          @Override
          public void onFinalImageSet(
            String id, @Nullable final ImageInfo imageInfo, @Nullable Animatable animatable) {
            mImageLoadSuccessfully = true;
            if (imageInfo != null) {
              checkImageScale(imageInfo);
              mEventDispatcher.dispatchEvent(
                new ImageLoadEvent(
                  getId(),
                  ImageLoadEvent.ON_LOAD,
                  mImageSource.getSource(),
                  imageInfo.getWidth(),
                  imageInfo.getHeight(),
                  String.valueOf(animatable != null)));
              mEventDispatcher.dispatchEvent(new ImageLoadEvent(getId(), ImageLoadEvent.ON_LOAD_END));
              if (animatable instanceof AnimatedDrawable2) {
                AnimatedDrawable2 animatedDrawable2 = (AnimatedDrawable2) animatable;
                if (START_ANIMATING_WHEN_LOADED) {
                  if (mPlayAnimatedImage && !animatedDrawable2.isRunning()) {
                    animatedDrawable2.start();
                  }
                }
                animatedDrawable2.setAnimationListener(new AnimationListener() {
                  @Override
                  public void onAnimationStart(AnimatedDrawable2 animatedDrawable2) {
                    FLog.w(TAG,"onAnimationStart");
                  }

                  @Override
                  public void onAnimationStop(AnimatedDrawable2 animatedDrawable2) {
                    FLog.w(TAG,"onAnimationStop");
                  }

                  @Override
                  public void onAnimationReset(AnimatedDrawable2 animatedDrawable2) {
                    FLog.w(TAG,"onAnimationReset");
                  }

                  @Override
                  public void onAnimationRepeat(AnimatedDrawable2 animatedDrawable2) {
                    FLog.w(TAG,"onAnimationRepeat");
                  }

                  @Override
                  public void onAnimationFrame(AnimatedDrawable2 animatedDrawable2, int i) {
                    FLog.w(TAG,"onAnimationFrame:" + i);
                    if (animatedDrawable2 == null) {
                      return;
                    }
                    Map<String, Integer> animatedMessage = new HashMap<>();
                    animatedMessage.put(ImageLoadEvent.TOTAL_FRAME_COUNT, animatedDrawable2.getFrameCount());
                    animatedMessage.put(ImageLoadEvent.CURRENT_FRAME, i);
                    mEventDispatcher.dispatchEvent(
                      new ImageLoadEvent(
                        getId(),
                        ImageLoadEvent.ON_ANIMATED_FRAME,
                        mImageSource.getSource(),
                        animatedMessage));
                    if (lastFrameNumber != i) {
                      if (mAnimatedLoopCount > 0 && i < lastFrameNumber) {
                        mCurrentLoopCount++;
                        if (mCurrentLoopCount >= mAnimatedLoopCount) {
                          animatedDrawable2.stop();
                        }
                      }
                      lastFrameNumber = i;
                      if (i == animatedDrawable2.getFrameCount() - 1) {
                        mEventDispatcher.dispatchEvent(new ImageLoadEvent(getId(), ImageLoadEvent.ON_GIF_END));
                      }
                    }
                  }
                });
              }
            }
          }

          @Override
          public void onFailure(String id, Throwable throwable) {
            String errorMessage = "";
            if (throwable != null) {
              errorMessage = throwable.getMessage();
            }
            FLog.e(TAG, "onFailure: id = " + id + ", error = " + errorMessage);
            mEventDispatcher.dispatchEvent(
              new ImageLoadEvent(
                getId(), ImageLoadEvent.ON_ERROR, true, errorMessage));
          }
        };
    }

    mIsDirty = true;
  }

  public void setBlurRadius(float blurRadius) {
    if (mIsReuseUpdate && mBlurRadius == blurRadius) {
      return;
    }
    mBlurRadius = blurRadius;

    int pixelBlurRadius = (int) PixelUtil.toPixelFromDIP(blurRadius);
    if (pixelBlurRadius == 0) {
      mIterativeBoxBlurPostProcessor = null;
    } else {
      mIterativeBoxBlurPostProcessor = new IterativeBoxBlurPostProcessor(pixelBlurRadius);
    }
    mIsDirty = true;
  }

  @Override
  public void setBackgroundColor(int backgroundColor) {
    if (mBackgroundColor != backgroundColor) {
      mBackgroundColor = backgroundColor;
      mBackgroundImageDrawable = new RoundedColorDrawable(backgroundColor);
      mIsDirty = true;
    }
  }

  public void setBorderColor(int borderColor) {
    if (mIsReuseUpdate && mBorderColor == borderColor) {
      return;
    }
    mBorderColor = borderColor;
    mIsDirty = true;
  }

  public void setOverlayColor(int overlayColor) {
    if (mIsReuseUpdate && mOverlayColor == overlayColor) {
      return;
    }
    mOverlayColor = overlayColor;
    mIsDirty = true;
  }

  public void setBorderWidth(float borderWidth) {
    float borderWidthPixel = PixelUtil.toPixelFromDIP(borderWidth);
    if (mIsReuseUpdate && mBorderWidth == borderWidthPixel) {
      return;
    }

    mBorderWidth = borderWidthPixel;
    mBorderWidth = PixelUtil.toPixelFromDIP(borderWidth);
    mIsDirty = true;
  }

  public void setBorderRadius(float borderRadius) {
    if (!FloatUtil.floatsEqual(mBorderRadius, borderRadius)) {
      mBorderRadius = borderRadius;
      mIsDirty = true;
    }
  }

  public void setBorderRadius(float borderRadius, int position) {
    if (mBorderCornerRadii == null) {
      mBorderCornerRadii = new float[4];
      Arrays.fill(mBorderCornerRadii, YogaConstants.UNDEFINED);
    }

    if (!FloatUtil.floatsEqual(mBorderCornerRadii[position], borderRadius)) {
      mBorderCornerRadii[position] = borderRadius;
      mIsDirty = true;
    }
  }

  public void setScaleType(ScalingUtils.ScaleType scaleType) {
    if (mIsReuseUpdate && mScaleType == scaleType) {
      return;
    }
    mScaleType = scaleType;
    mIsDirty = true;
  }

  public void setTileMode(Shader.TileMode tileMode) {
    if (mIsReuseUpdate && mTileMode == tileMode) {
      return;
    }
    mTileMode = tileMode;
    mIsDirty = true;
  }

  public void setResizeMethod(ImageResizeMethod resizeMethod) {
    if (mIsReuseUpdate && mResizeMethod == resizeMethod) {
      return;
    }
    mResizeMethod = resizeMethod;
    mIsDirty = true;
  }

  private boolean isAlreadyExist(@Nullable ReadableArray sources) {
    if (sources == null) {
      return false;
    }
    for (int i = 0; i < sources.size(); i++) {
      String newUri = sources.getMap(i).getString("uri");

      boolean isSame = false;
      for (int k = 0; k < mSources.size(); k++) {
        String oldUri = mSources.get(k).getUri().toString();
        if (newUri != null && newUri.equals(oldUri)) {
          isSame = true;
          break;
        }
      }

      if (!isSame) {
        return false;
      }
    }
    return true;
  }

  public void setSource(@Nullable ReadableArray sources) {
    if (mIsReuseUpdate && isAlreadyExist(sources)) {
      return;
    }
    String sourceMessage = "";
    if (sources != null) {
      sourceMessage = sources.toString();
    }
    FLog.w(TAG, "setSource:" + sourceMessage);
    mSources.clear();
    if (sources == null || sources.size() == 0) {
      ImageSource imageSource = new ImageSource(getContext(), REMOTE_TRANSPARENT_BITMAP_URI);
      mSources.add(imageSource);
    } else {
      // Optimize for the case where we have just one uri, case in which we don't need the sizes
      if (sources.size() == 1) {
        ReadableMap source = sources.getMap(0);
        String uri = source.getString("uri");
        ImageSource imageSource = new ImageSource(getContext(), uri);
        mSources.add(imageSource);
        if (Uri.EMPTY.equals(imageSource.getUri())) {
          warnImageSource(uri);
        }
      } else {
        for (int idx = 0; idx < sources.size(); idx++) {
          ReadableMap source = sources.getMap(idx);
          String uri = source.getString("uri");

          double width = 0.0d;
          double height = 0.0d;

          if (!mMultiSourceRetryEnabled || source.hasKey("width")) {
            width = source.getDouble("width");
          }

          if (!mMultiSourceRetryEnabled || source.hasKey("height")) {
            height = source.getDouble("height");
          }

          ImageSource imageSource = new ImageSource(getContext(), uri, width, height);

          mSources.add(imageSource);
          if (Uri.EMPTY.equals(imageSource.getUri())) {
            warnImageSource(uri);
          }
        }
      }
    }
    mIsDirty = true;
  }

  @RequiresApi(api = Build.VERSION_CODES.KITKAT)
  public void setDefaultSource(@Nullable String name) {
    if (mIsReuseUpdate && Objects.equals(name, mDefaultSourceName)) {
      return;
    }
    mDefaultSourceName = name;

    if (name != null && name.startsWith("file://")) {
      String imagePath = name.replace("file://", "");
      mDefaultImageDrawable = Drawable.createFromPath(imagePath);
    } else if (name != null && !mImageLoadSuccessfully && (name.startsWith("http://") || name.startsWith("https://"))) {
      FrescoUtils.fetchImg(name, new ImageCallback() {
        @Override
        public void onCompleted(@Nullable Drawable drawable) {
          ImageCallback.super.onCompleted(drawable);
        }

        @Override
        public void onProgress(float progress) {
          ImageCallback.super.onProgress(progress);
        }

        @Override
        public void onCompletedBitmap(Bitmap bitmap) {
          ImageCallback.super.onCompletedBitmap(bitmap);

          FLog.w(TAG, "onCompletedBitmap");
          if (bitmap != null && !mImageLoadSuccessfully) {
            Bitmap bitmapCopy = bitmap;
            if (DEFAULTSOURCE_USE_BITMAPCOPY) {
              try {
                bitmapCopy = bitmap.copy(bitmap.getConfig(), bitmap.isMutable());
              } catch (Throwable throwable) {
                FLog.w(TAG, "copy bitmap for failed, stack: ", throwable);
              }
            }
            if (bitmapCopy != null) {
              mDefaultImageDrawable = new BitmapDrawable(getResources(), bitmapCopy);
              mIsDirty = true;
              maybeUpdateView();
            }
          }
        }
      });
    } else {
      mDefaultImageDrawable =
        ResourceDrawableIdHelper.getInstance().getResourceDrawable(getContext(), name);
    }
    mIsDirty = true;
  }

  @RequiresApi(api = Build.VERSION_CODES.KITKAT)
  public void setLoadingIndicatorSource(@Nullable String name) {
    if (mIsReuseUpdate && Objects.equals(name, mLoadingIndicatorSourceName)) {
      return;
    }
    mLoadingIndicatorSourceName = name;

    Drawable drawable =
      ResourceDrawableIdHelper.getInstance().getResourceDrawable(getContext(), name);
    mLoadingImageDrawable =
      drawable != null ? new AutoRotateDrawable(drawable, 1000) : null;
    mIsDirty = true;
  }

  public void setProgressiveRenderingEnabled(boolean enabled) {
    mProgressiveRenderingEnabled = enabled;
    // no worth marking as dirty if it already rendered..
  }

  public void setFadeDuration(int durationMs) {
    mFadeDurationMs = durationMs;
    // no worth marking as dirty if it already rendered..
  }

  public void setImageSizeWarningThreshold(float sizeWarningThreshold) {
    mSizeWarningThreshold = sizeWarningThreshold;
  }

  private void cornerRadii(float[] computedCorners) {
    float defaultBorderRadius = !YogaConstants.isUndefined(mBorderRadius) ? mBorderRadius : 0;

    computedCorners[0] =
      mBorderCornerRadii != null && !YogaConstants.isUndefined(mBorderCornerRadii[0])
        ? mBorderCornerRadii[0]
        : defaultBorderRadius;
    computedCorners[1] =
      mBorderCornerRadii != null && !YogaConstants.isUndefined(mBorderCornerRadii[1])
        ? mBorderCornerRadii[1]
        : defaultBorderRadius;
    computedCorners[2] =
      mBorderCornerRadii != null && !YogaConstants.isUndefined(mBorderCornerRadii[2])
        ? mBorderCornerRadii[2]
        : defaultBorderRadius;
    computedCorners[3] =
      mBorderCornerRadii != null && !YogaConstants.isUndefined(mBorderCornerRadii[3])
        ? mBorderCornerRadii[3]
        : defaultBorderRadius;
  }

  public void setHeaders(ReadableMap headers) {
    mHeaders = headers;
  }

  public void setmResizeOptionWidth(int width) { mResizeOptionWidth = width; }

  public void setmResizeOptionHeight(int height) { mResizeOptionHeight = height; }

  public void maybeUpdateView() {
    if (!mIsDirty) {
      return;
    }

    if (hasMultipleSources() && (getWidth() <= 0 || getHeight() <= 0)) {
      // If we need to choose from multiple uris but the size is not yet set, wait for layout pass
      return;
    }

    setSourceImage();
    if (mImageSource == null) {
      return;
    }

    boolean doResize = shouldResize(mImageSource);
    if (doResize && (getWidth() <= 0 || getHeight() <= 0)) {
      // If need a resize and the size is not yet set, wait until the layout pass provides one
      return;
    }

    if (isTiled() && (getWidth() <= 0 || getHeight() <= 0)) {
      // If need to tile and the size is not yet set, wait until the layout pass provides one
      return;
    }

    GenericDraweeHierarchy hierarchy = getHierarchy();
    hierarchy.setActualImageScaleType(mScaleType);

    if (mDefaultImageDrawable != null) {
      hierarchy.setPlaceholderImage(mDefaultImageDrawable, mScaleType);
    }

    if (mLoadingImageDrawable != null) {
      hierarchy.setPlaceholderImage(mLoadingImageDrawable, ScalingUtils.ScaleType.CENTER);
    }

    boolean usePostprocessorScaling =
      mScaleType != ScalingUtils.ScaleType.CENTER_CROP
        && mScaleType != ScalingUtils.ScaleType.FOCUS_CROP;

    RoundingParams roundingParams = hierarchy.getRoundingParams();

    cornerRadii(sComputedCornerRadii);

    roundingParams.setCornersRadii(
      sComputedCornerRadii[0],
      sComputedCornerRadii[1],
      sComputedCornerRadii[2],
      sComputedCornerRadii[3]);

    if (mBackgroundImageDrawable != null) {
      mBackgroundImageDrawable.setBorder(mBorderColor, mBorderWidth);
      mBackgroundImageDrawable.setRadii(roundingParams.getCornersRadii());
      hierarchy.setBackgroundImage(mBackgroundImageDrawable);
    }

    if (usePostprocessorScaling) {
      roundingParams.setCornersRadius(0);
    }

    roundingParams.setBorder(mBorderColor, mBorderWidth);
    if (mOverlayColor != Color.TRANSPARENT) {
      roundingParams.setOverlayColor(mOverlayColor);
    } else {
      // make sure the default rounding method is used.
      roundingParams.setRoundingMethod(RoundingParams.RoundingMethod.BITMAP_ONLY);
    }
    hierarchy.setRoundingParams(roundingParams);
    hierarchy.setFadeDuration(
      mFadeDurationMs >= 0
        ? mFadeDurationMs
        : mImageSource.isResource() ? 0 : REMOTE_IMAGE_FADE_DURATION_MS);

    List<Postprocessor> postProcessors = new LinkedList<>();
    if (usePostprocessorScaling) {
      postProcessors.add(mRoundedCornerPostprocessor);
    }
    if (mIterativeBoxBlurPostProcessor != null) {
      postProcessors.add(mIterativeBoxBlurPostProcessor);
    }
    if (isTiled()) {
      postProcessors.add(mTilePostprocessor);
    }
    Postprocessor postprocessor = MultiPostprocessor.from(postProcessors);

    int resizeWidth = getWidth();
    int resizeHeight = getHeight();
    if (mResizeOptionHeight != null && mResizeOptionWidth != null) {
      resizeWidth = mResizeOptionWidth;
      resizeHeight = mResizeOptionHeight;
    }

    ResizeOptions resizeOptions = doResize ? new ResizeOptions(resizeWidth, resizeHeight) : null;

    // This builder is reused
    mDraweeControllerBuilder.reset();

    mDraweeControllerBuilder
      .setAutoPlayAnimations(mAutoPlayAnimatedImage)
//      .setCallerContext(mCallerContext)
      .setOldController(getController());

    ImageRequest monitorRequest = null;
    if (mMultiSourceRetryEnabled) {
      ImageRequest[] imageRequests = buildSources(postprocessor, resizeOptions);

      mDraweeControllerBuilder.setFirstAvailableImageRequests(imageRequests, false);
      monitorRequest = imageRequests.length > 0 ? imageRequests[0] : null;
    } else {
      ImageRequest imageRequest =
        buildSingleImageRequest(mImageSource.getUri(), postprocessor, resizeOptions);

      if (mGlobalImageLoadListener != null) {
        mGlobalImageLoadListener.onLoadAttempt(mImageSource.getUri());
      }

      mDraweeControllerBuilder.setImageRequest(imageRequest);
      monitorRequest = imageRequest;
    }

    if (mCachedImageSource != null) {
      ImageRequest cachedImageRequest =
        ImageRequestBuilder.newBuilderWithSource(mCachedImageSource.getUri())
          .setPostprocessor(postprocessor)
          .setResizeOptions(resizeOptions)
          .setRotationOptions(RotationOptions.autoRotate())
          .setProgressiveRenderingEnabled(mProgressiveRenderingEnabled)
          .build();
      mDraweeControllerBuilder.setLowResImageRequest(cachedImageRequest);
    }

    ForwardingControllerListener combinedListener = new ForwardingControllerListener();
    if (mControllerListener != null) {
      combinedListener.addListener(mControllerListener);
    }
    if (mControllerForTesting != null) {
      combinedListener.addListener(mControllerForTesting);
    }
    KwaiImageControllerListenerFactory controllerListenerFactory =
      KwaiImageManagerConfig.INSTANCE.getControllerListenerFactory();
    if (controllerListenerFactory != null) {
      ControllerListener listener = controllerListenerFactory.createControllerListenerFactory();
      if (listener != null) {
        combinedListener.addListener(listener);
      }
    }

    if (mImageMemoryMonitor != null) {
      combinedListener.addListener(mImageMemoryMonitor.createControllerListener(monitorRequest));
    }
    mDraweeControllerBuilder.setControllerListener(combinedListener);

    KwaiImageCallerContextFactory callerContextFactory =
      KwaiImageManagerConfig.INSTANCE.getCallerContextFactory();
    if (callerContextFactory != null) {
      Object callerContext = callerContextFactory.createCallerContext(this, mImageSource);
      mDraweeControllerBuilder.setCallerContext(callerContext);
    }

    setController(mDraweeControllerBuilder.build());
    mIsDirty = false;

    // Reset again so the DraweeControllerBuilder clears all it's references. Otherwise, this causes
    // a memory leak.
    mDraweeControllerBuilder.reset();
  }

  // VisibleForTesting
  public void setControllerListener(ControllerListener controllerListener) {
    mControllerForTesting = controllerListener;
    mIsDirty = true;
    maybeUpdateView();
  }

  @Override
  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    FLog.w(TAG, "onSizeChanged: w = " + w + ", h = " + h + ", oldw" + oldw + ", oldh" + oldh);
    super.onSizeChanged(w, h, oldw, oldh);
    if (w > 0 && h > 0) {
      mIsDirty = mIsDirty || hasMultipleSources() || isTiled();
      maybeUpdateView();
    }
  }

  /**
   * ReactImageViews only render a single image.
   */
  @Override
  public boolean hasOverlappingRendering() {
    return false;
  }

  private boolean hasMultipleSources() {
    return mSources.size() > 1;
  }

  private boolean isTiled() {
    return mTileMode != Shader.TileMode.CLAMP;
  }

  private void setSourceImage() {
    mImageSource = null;
    if (mSources.isEmpty()) {
      ImageSource imageSource = new ImageSource(getContext(), REMOTE_TRANSPARENT_BITMAP_URI);
      mSources.add(imageSource);
    } else if (hasMultipleSources()) {
      MultiSourceResult multiSource =
        MultiSourceHelper.getBestSourceForSize(getWidth(), getHeight(), mSources);
      mImageSource = multiSource.getBestResult();
      mCachedImageSource = multiSource.getBestResultInCache();
      return;
    }

    mImageSource = mSources.get(0);
  }

  /**
   * fixme 临时方案，目前改动量最少的方案，后续验证无问题后再统一整理
   * <p>
   * 1、只需要这里改动一下就可以实现，借助Headers随意扩展的特定
   * 2、{@link #setHeaders(ReadableMap)} 执行时机早于 {@link #setSource(ReadableArray)}
   *
   * @param imageRequestBuilder
   */
  private void onConfigBitmapConfig(ImageRequestBuilder imageRequestBuilder) {
    if (mHeaders == null || !mHeaders.hasKey("bitmapConfig")) {
      return;
    }

    String config = mHeaders.getString("bitmapConfig");
    Bitmap.Config bitmapConfig = getBitmapConfig(config);
    if (bitmapConfig != null) {
      imageRequestBuilder.setImageDecodeOptions(ImageDecodeOptions.newBuilder()
        .setBitmapConfig(bitmapConfig).build());
    }
  }

  /**
   * 目前只支持{@link Bitmap.Config#RGB_565}和{@link Bitmap.Config#ARGB_8888}
   *
   * @param config
   * @return
   */
  private Bitmap.Config getBitmapConfig(String config) {
    if ("RGB_565".equalsIgnoreCase(config)) {
      return Bitmap.Config.RGB_565;
    } else if ("ARGB_8888".equalsIgnoreCase(config)) {
      return Bitmap.Config.ARGB_8888;
    } else {
      return null;
    }
  }

  private boolean shouldResize(ImageSource imageSource) {
    // Resizing is inferior to scaling. See http://frescolib.org/docs/resizing-rotating.html#_
    // We resize here only for images likely to be from the device's camera, where the app developer
    // has no control over the original size
    if (mResizeMethod == ImageResizeMethod.AUTO) {
      return UriUtil.isLocalContentUri(imageSource.getUri())
        || UriUtil.isLocalFileUri(imageSource.getUri());
    } else {
      return mResizeMethod == ImageResizeMethod.RESIZE;
    }
  }

  private void warnImageSource(String uri) {
    if (ReactBuildConfig.DEBUG) {
      Toast.makeText(
        getContext(),
        "Warning: Image source \"" + uri + "\" doesn't exist",
        Toast.LENGTH_SHORT)
        .show();
    }
  }

  public void setMultiSourceRetryEnabled(boolean multiSourceRetryEnabled) {
    if (mMultiSourceRetryEnabled != multiSourceRetryEnabled) {
      mMultiSourceRetryEnabled = multiSourceRetryEnabled;
      mIsDirty = true;
    }
  }

  public void setPlayAnimatedImage(boolean playAnimatedImage) {
    if (mPlayAnimatedImage == playAnimatedImage) {
      return;
    }
    mPlayAnimatedImage = playAnimatedImage;
    DraweeController draweeController = getController();
    if (draweeController != null) {
      Animatable animatable = draweeController.getAnimatable();
      if (animatable == null) {
        setAutoPlayAnimatedImage(playAnimatedImage);
      } else {
        if (playAnimatedImage) {
          animatable.start();
        } else {
          animatable.stop();
        }
      }
    } else {
        setAutoPlayAnimatedImage(playAnimatedImage);
    }
  }

  private void setAutoPlayAnimatedImage(boolean autoPlayAnimatedImage) {
    mAutoPlayAnimatedImage = autoPlayAnimatedImage;
  }

  public void setAnimatedLoopCount(int animatedLoopCount) {
    mAnimatedLoopCount = animatedLoopCount;
  }

  private ImageRequest[] buildSources(Postprocessor postprocessor, ResizeOptions resizeOptions) {
    ImageRequest[] imageRequests = new ImageRequest[mSources.size()];

    for (int i = 0; i < mSources.size(); i++) {
      imageRequests[i] =
        buildSingleImageRequest(mSources.get(i).getUri(), postprocessor, resizeOptions);
    }

    return imageRequests;
  }

  public String getBundleId() {
    return mBundleId;
  }

  private ImageRequest buildSingleImageRequest(Uri uri, Postprocessor postprocessor,
    ResizeOptions resizeOptions) {
    ImageRequestBuilder imageRequestBuilder = ImageRequestBuilder.newBuilderWithSource(uri)
      .setPostprocessor(postprocessor)
      .setResizeOptions(resizeOptions)
      .setAutoRotateEnabled(true)
      .setProgressiveRenderingEnabled(mProgressiveRenderingEnabled);

    onConfigBitmapConfig(imageRequestBuilder);

    return ReactNetworkImageRequest.fromBuilderWithHeaders(imageRequestBuilder, mHeaders);
  }

  private boolean shouldShowScaleWarn(float tWidth, float tHeight, float iWidth, float iHeight, float scaleThreshold) {
    if (scaleThreshold < 0) return false;
    if (iWidth > tWidth * scaleThreshold) return true;

    return (iHeight > tHeight * scaleThreshold);
  }

  private void checkImageScale(ImageInfo imageInfo) {
    if (imageInfo == null) {
      FLog.e(TAG, "checkImageScale :: drawable is null");
      return;
    }

    float targetW = getWidth();
    float targetH = getHeight();
    float imageW = imageInfo.getWidth();
    float imageH = imageInfo.getHeight();
    String uri = mImageSource == null ? "" :mImageSource.getSource();
    float finalSizeThreshold = mSizeWarningThreshold != 0 ? mSizeWarningThreshold : mScaleThreshold;
    if (shouldShowScaleWarn(targetW, targetH, imageW, imageH, finalSizeThreshold)) {
      String warningMsg = String.format("warn !!! ReactImageView(ID %s): \n" +
              "图片宽高(%s, %s) 超过了\n" +
              "控件宽高(%s, %s) %s倍\n" +
              "source: %s\n"+
              "可通过 cropSize 属性来裁剪图片以减小图片大小，或者设置属性 imageWarningThreshold = {{imageSizeWarningThreshold:-1}} \n" +
              "关闭警告",
          getId(), imageW, imageH, targetW, targetH, finalSizeThreshold, uri);
      FLog.w(TAG, warningMsg);
      ((ReactContext) getContext()).getJSModule(RCTLog.class).logIfNoNativeHook(IMAGE_WARN, warningMsg);
    }
  }

  /**
   * 仅限【Debug模式下】
   * 设置图片 和 目标空间的宽高比例阈值，超限提醒
   *
   * @param scaleThreshold 尺寸提醒阈值
   *                       < 0时默认关闭
   */
  public static void setScaleThreshold(float scaleThreshold) {
    mScaleThreshold = scaleThreshold;
  }

}
