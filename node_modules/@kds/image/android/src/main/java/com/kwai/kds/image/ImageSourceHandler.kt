package com.kwai.kds.image

import android.content.Context
import android.net.Uri
import android.text.TextUtils
import android.util.Log
import com.facebook.react.views.imagehelper.ResourceDrawableIdHelper
import com.yxcorp.utility.io.FileUtils
import org.apache.internal.commons.io.filefilter.AbstractFileFilter
import org.apache.internal.commons.io.filefilter.IOFileFilter
import org.apache.internal.commons.io.filefilter.TrueFileFilter
import java.io.File

internal object ImageSourceHandler {

  private const val TAG = "ImageSourceHandler"

  private val androidDrawableSuffix = listOf("ldpi", "mdpi", "hdpi", "xhdpi", "xxhdpi", "xxxhdpi")
  private val androidScales = listOf(0.75f, 1f, 1.5f, 2f, 3f, 4f)

  /**
   * JS传过来的url，有可能是网络url、也有可能是文件系统的url，对于文件系统的url，有可能是一个图片地址的绝对路径，
   * 也有可能是相对路径，这里由于分包的原因，导致相对路径识别不了
   *
   *
   * 文件系统 ---->
   *
   *
   * 1、绝对路径 file:///data/user/0/{包名}/files/react_native/{bundleId}/drawable-mdpi
   * /src_demo_images_0.jpeg
   *
   *
   * 2、相对路径  src_demo_images_0
   *
   *
   * Note: 为了做这个兼容，这里需要根据传过来的bundleId自动查询文件
   *
   * @param source
   * @return
   */
  @JvmStatic
  fun onInterceptImageSource(context: Context, source: String): String {
    // Notice: 暂时先固定使用此地址
    val rnRootDir = File(context.filesDir, "react_native")
    val uri = computeUri(context, source)

    if (Uri.EMPTY != uri) {
      return source
    }

    val nameFilter: IOFileFilter = ImageNameFilter(source)

    try {
      // TODO("这里后续优化到具体的某个bundle下面")
      val fileList = FileUtils
        .listFiles(rnRootDir, nameFilter, TrueFileFilter.INSTANCE) as List<File>

      val filePath = matchBestDrawablePath(context, source, fileList)

      if (filePath.isNotEmpty()) {
        return filePath
      }
    } catch (e: Exception) {
      Log.e(TAG, "分包转换本地图片异常", e)
    }

    return source
  }

  private fun matchBestDrawablePath(
    context: Context, source: String, fileList: List<File>
  ): String {
    // 可能存在多个，比如 drawable-mdpi/xxx.png  drawable-hdpi/xxx.png  drawable-xhdpi/xxx.png
    val targetName = getTargetName(context, source)

    // 1、精确匹配到具体的某个路径
    for (file in fileList) {
      if (file.absolutePath.contains(targetName)) {
        return "file://" + file.absolutePath
      }
    }

    // 2、走到这里说明没有匹配到，则取最后一个
    if (fileList.isNotEmpty()) {
      val lastFile = fileList.maxBy { file -> file.absolutePath }
      return "file://" + lastFile?.absolutePath
    }

    return ""
  }

  private fun computeUri(context: Context, source: String): Uri {
    return try {
      val uri = Uri.parse(source)
      // Verify scheme is set, so that relative uri (used by static resources) are not handled.
      if (uri.scheme == null) computeLocalUri(context, source) else uri
    } catch (e: Exception) {
      computeLocalUri(context, source)
    }
  }

  private fun computeLocalUri(context: Context, source: String): Uri {
    return ResourceDrawableIdHelper.getInstance()
      .getResourceDrawableUri(context, source)
  }

  private class ImageNameFilter(private val mSource: String) : AbstractFileFilter() {
    override fun accept(file: File): Boolean {
      if (!file.isFile) {
        return false
      }
      val name = file.name
      if (TextUtils.isEmpty(name)) {
        return false
      }
      return if (TextUtils
          .equals(FileUtils.removeExtension(mSource), FileUtils.removeExtension(name))
      ) {
        true
      } else name.contains(mSource)
    }
  }

  private fun getTargetName(context: Context, source: String): String {
    val scale = context.resources.displayMetrics.density

    val folderName = getAndroidResourceFolderName(scale)

    return folderName + File.separator + source
  }

  private fun pickScale(deviceScale: Float): Float {
    // Packager guarantees that `scales` array is sorted
    for (scale in androidScales) {
      if (scale >= deviceScale) {
        return scale
      }
    }

    // If nothing matches, device scale is larger than any available
    // scales, so we return the biggest one. Unless the array is empty,
    // in which case we default to 1
    return androidScales.last()
  }

  private fun getAndroidResourceFolderName(scale: Float): String {
    val pickScale = pickScale(scale)
    val suffix = getAndroidAssetSuffix(pickScale)
    return "drawable-$suffix"
  }

  private fun getAndroidAssetSuffix(scale: Float): String? {
    val index = androidScales.indexOf(scale)
    if (index >= 0) {
      return androidDrawableSuffix[index]
    }

    return "mdpi"
  }
}
