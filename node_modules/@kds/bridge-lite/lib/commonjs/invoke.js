"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invokeSync = exports.invoke = void 0;

var _bridgeError = require("./bridge-error");

var _constants = require("./constants");

var _globalConfig = require("./global-config");

var _utils = require("./utils");

var _BatchedBridge = _interopRequireDefault(require("react-native/Libraries/BatchedBridge/BatchedBridge"));

var _reactNative = require("react-native");

var _getKswitchData = _interopRequireDefault(require("./legency/get-kswitch-data"));

var _loadUri = _interopRequireDefault(require("./legency/load-uri"));

var _getSlideBack = _interopRequireDefault(require("./legency/get-slide-back"));

var _setSlideBack = _interopRequireDefault(require("./legency/set-slide-back"));

var _exitPageWithInfo = _interopRequireDefault(require("./legency/exit-page-with-info"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 支持多次callback回调的简单实现
const callbacks = new Map();
const KdsCallback = {
  callback(callbackId, result) {
    let callback = callbacks.get(callbackId);

    if (callback) {
      callback(result);
    }
  }

};

_BatchedBridge.default.registerCallableModule('KdsCallback', KdsCallback);

const getInvocationConfig = args => {
  const [bridge, params = {}, optionsOrCallback] = args;
  const [options, callback] = typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback !== null && optionsOrCallback !== void 0 ? optionsOrCallback : {}];
  return {
    initialBridge: bridge,
    bridge,
    params,
    options,
    callback
  };
};

const invoke = function () {
  var _globalConfig$timeout, _url;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  const config = getInvocationConfig(args);
  const {
    bridge,
    params,
    callback,
    options: {
      timeout = (_globalConfig$timeout = _globalConfig.globalConfig.timeout) !== null && _globalConfig$timeout !== void 0 ? _globalConfig$timeout : 0
    }
  } = config;
  const [namespace, method] = bridge.split('.'); // 基于 10.5.10 之前版本 如果url 以 market://开头 调用NativeModules.KRNBasic.open方法.
  // https://team.corp.kuaishou.com/task/T2502723

  if (method === 'loadUri' && namespace === 'platform' && _reactNative.Platform.OS === 'android' && params !== null && params !== void 0 && (_url = params.url) !== null && _url !== void 0 && _url.startsWith('market://')) {
    const appVersion = (0, _utils.getAppVersion)();

    if ((0, _utils.versionCompare)(appVersion, '10.5.20') === _utils.VersionIs.LessThan) {
      return (0, _loadUri.default)(params);
    }
  } // @ts-ignore 类型声明中暂时没有这个 bridge


  if (method === 'getSlideBack' && namespace === 'tool') {
    return (0, _getSlideBack.default)(JSON.parse((0, _utils.normalParams)(params || {})));
  } // @ts-ignore 类型声明中暂时没有这个 bridge


  if (method === 'setSlideBack' && namespace === 'tool') {
    return (0, _setSlideBack.default)(JSON.parse((0, _utils.normalParams)(params || {})));
  } // https://team.corp.kuaishou.com/task/T3494368


  if (method === 'exitPageWithInfo' && namespace === 'ui') {
    return (0, _exitPageWithInfo.default)(JSON.parse((0, _utils.normalParams)(params || {})));
  }

  if (_constants.callbackOnlyBridgeSet.has(bridge)) {
    var _NativeModules$Kds;

    // 只支持多次回调的 bridge，需要注册 callbackId
    const callbackId = (0, _utils.generateUUID)();
    callbacks.set(callbackId, result => {
      const data = _globalConfig.globalConfig.isSetSerializer ? _globalConfig.globalConfig.serializer.parse(result) : result;
      callback === null || callback === void 0 ? void 0 : callback(data);
    });

    if (_globalConfig.globalConfig.isSetSerializer && (_NativeModules$Kds = _reactNative.NativeModules.Kds) !== null && _NativeModules$Kds !== void 0 && _NativeModules$Kds.invokeWithArgs) {
      _reactNative.NativeModules.Kds.invokeWithArgs({
        rootTag: (params === null || params === void 0 ? void 0 : params.rootTag) || _globalConfig.globalConfig.rootTag,
        nameSpace: (0, _utils.normalNamespace)(namespace),
        method,
        params: (0, _utils.normalParams)(params),
        callbackId,
        multiCallback: true,
        callbackType: 'str'
      });

      return undefined;
    }

    _reactNative.NativeModules.Kds.invokeWithMultiCallback((0, _utils.normalNamespace)(namespace), method, (0, _utils.normalParams)(params), callbackId);

    return undefined;
  }

  const baseInvoking = new Promise((resolve, reject) => {
    var _NativeModules$Kds2;

    const baseInvokingSuccessHandle = data => {
      // 返回的结果中如果有 result 字段时且不为 1，则按照错误处理，进入 reject
      if (data && 'result' in data && typeof data.result === 'number' && data.result !== 1) {
        reject(new _bridgeError.BridgeError(`bridge：${bridge} 调用出错，调用参数为：${JSON.stringify(params)}，错误信息为：${data.error_msg || data.message || ''}`, data.result, {
          bridge,
          params
        }));
        return;
      }

      if (data && data.result === 1) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const {
          result,
          ...restData
        } = data;
        resolve(restData);
        return;
      }

      resolve(data);
    };

    const baseInvokingFailHandle = err => {
      reject((0, _utils.dealRejectErrorInfo)(err));
    };

    if (_globalConfig.globalConfig.isSetSerializer && (_NativeModules$Kds2 = _reactNative.NativeModules.Kds) !== null && _NativeModules$Kds2 !== void 0 && _NativeModules$Kds2.invokeWithArgs) {
      _reactNative.NativeModules.Kds.invokeWithArgs({
        rootTag: (params === null || params === void 0 ? void 0 : params.rootTag) || _globalConfig.globalConfig.rootTag,
        nameSpace: (0, _utils.normalNamespace)(namespace),
        method,
        params: (0, _utils.normalParams)(params),
        callbackType: 'str'
      }).then(res => {
        const data = _globalConfig.globalConfig.serializer.parse(res);

        baseInvokingSuccessHandle(data);
      }, baseInvokingFailHandle);

      return;
    }

    _reactNative.NativeModules.Kds.invoke((0, _utils.normalNamespace)(namespace), method, (0, _utils.normalParams)(params)).then(baseInvokingSuccessHandle, baseInvokingFailHandle);
  });
  const invoking = timeout > 0 && Number.isFinite(timeout) ? Promise.race([baseInvoking, (0, _utils.delay)(timeout).then(() => Promise.reject(new _bridgeError.BridgeError('timeout', 125010, {
    bridge,
    params: config.params
  })))]) : baseInvoking;
  return invoking;
};

exports.invoke = invoke;

const invokeSync = function () {
  var _NativeModules$Kds3, _NativeModules$Kds4;

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  const config = getInvocationConfig(args);
  const {
    bridge,
    params
  } = config;
  const unSupported = _globalConfig.globalConfig.isSetSerializer ? !((_NativeModules$Kds3 = _reactNative.NativeModules.Kds) !== null && _NativeModules$Kds3 !== void 0 && _NativeModules$Kds3.syncInvokeWithReturnStr) : !((_NativeModules$Kds4 = _reactNative.NativeModules.Kds) !== null && _NativeModules$Kds4 !== void 0 && _NativeModules$Kds4.syncInvoke);

  if (unSupported) {
    throw new _bridgeError.BridgeError('当前客户端版本不支持同步调用', -1, {
      bridge,
      params
    });
  }

  const [namespace, method] = bridge.split('.'); // 修改支持同步调用的列表时，请先修改 api/index.ts 下面的 SupportSyncAPI 和 SupportSyncAPIMethodName

  const supportedNamespaces = ['platform', 'system', 'tool', 'social'];
  const supportedMethodNames = {
    system: ['isNetworkConnected', 'getServerTime', 'isBottomNavigationBarShown', 'getNetworkType', 'getPushPermission', 'isPad', 'getDisplaySetting', 'getNavigationBarHeight', 'deviceIsLandscape'],
    platform: ['getDarkMode'],
    tool: ['getClipBoard', 'getKswitchData', 'canIUse', 'getABTestInfo', 'getStartUpData'],
    social: ['getNoticeRecoTextSync', 'getPymkRecoTextSync', 'getRemarkNameSync', 'getSocialMultiStringLangsSync']
  }; // 不支持的命名空间

  if (supportedNamespaces.indexOf(namespace) === -1) {
    throw new _bridgeError.BridgeError(`${namespace} 命名空间不支持同步调用`, -1, {
      bridge,
      params
    });
  } // 不支持的方法名


  if (supportedMethodNames[namespace].indexOf(method) === -1) {
    throw new _bridgeError.BridgeError(`${namespace} 命名空间的 ${method} 方法不支持同步调用`, -1, {
      bridge,
      params
    });
  } // 如果调用 tool.getKswitchData，在 10.4.40 之前使用 NativeModules.SwitchBridge.getKswitchDataSync 调用


  if (method === 'getKswitchData' && namespace === 'tool') {
    const appVersion = (0, _utils.getAppVersion)();

    if ((0, _utils.versionCompare)(appVersion, '10.4.40') === _utils.VersionIs.LessThan) {
      return (0, _getKswitchData.default)(params);
    }
  }

  let resultOrError; // 如果自定义了 serializer 就走新方法

  if (_globalConfig.globalConfig.isSetSerializer) {
    const withReturnStrResultOrErrorString = _reactNative.NativeModules.Kds.syncInvokeWithReturnStr({
      rootTag: (params === null || params === void 0 ? void 0 : params.rootTag) || _globalConfig.globalConfig.rootTag,
      nameSpace: (0, _utils.normalNamespace)(namespace),
      method,
      params: (0, _utils.normalParams)(params),
      callbackType: 'str'
    });

    resultOrError = _globalConfig.globalConfig.serializer.parse(withReturnStrResultOrErrorString);
  } else {
    // 否则走旧方法
    resultOrError = _reactNative.NativeModules.Kds.syncInvoke({
      nameSpace: (0, _utils.normalNamespace)(namespace),
      method,
      params: (0, _utils.normalParams)(params)
    });
  }

  if (resultOrError && 'errorCode' in resultOrError) {
    resultOrError.code = resultOrError.errorCode;
    resultOrError.message = resultOrError.errorMsg; // 删除掉原来的错误码及错误信息字段

    delete resultOrError.errorCode;
    delete resultOrError.errorMsg;
    throw (0, _utils.dealRejectErrorInfo)(resultOrError);
  }

  return resultOrError;
};

exports.invokeSync = invokeSync;
//# sourceMappingURL=invoke.js.map