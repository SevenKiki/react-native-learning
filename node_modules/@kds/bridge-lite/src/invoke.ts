import { BridgeError } from './bridge-error';
import { callbackOnlyBridgeSet } from './constants';
import { globalConfig } from './global-config';
import type {
    YodaBridges,
    InvocationParameters,
    InvocationPromise,
    InvocationOptions,
    InvocationConfig,
    InvocationBridgeNamespace,
    InvocationBridgeName,
    YodaSupportSyncBridges,
    InvocationResponse,
    InvocationParams,
} from './types';
import {
    dealRejectErrorInfo,
    delay,
    generateUUID,
    normalParams,
    normalNamespace,
    getAppVersion,
    versionCompare,
    VersionIs,
} from './utils';
import BatchedBridge from 'react-native/Libraries/BatchedBridge/BatchedBridge';
import { NativeModules, Platform } from 'react-native';
import getKswitchData from './legency/get-kswitch-data';
import loadUri from './legency/load-uri';
import getSlideBack from './legency/get-slide-back';
import setSlideBack from './legency/set-slide-back';
import exitPageWithInfo from './legency/exit-page-with-info';

// 支持多次callback回调的简单实现
const callbacks = new Map();
const KdsCallback = {
    callback(callbackId: String, result: any) {
        let callback = callbacks.get(callbackId);
        if (callback) {
            callback(result);
        }
    },
};
BatchedBridge.registerCallableModule('KdsCallback', KdsCallback);

const getInvocationConfig = <T extends keyof YodaBridges>(
    args: InvocationParameters<T>,
) => {
    const [bridge, params = {}, optionsOrCallback] = args;
    const [options, callback] =
        typeof optionsOrCallback === 'function'
            ? [{} as InvocationOptions, optionsOrCallback]
            : [optionsOrCallback ?? {}];

    return {
        initialBridge: bridge,
        bridge,
        params,
        options,
        callback,
    } as InvocationConfig<T>;
};

export const invoke = <T extends keyof YodaBridges>(
    ...args: InvocationParameters<T>
): InvocationPromise<T> => {
    const config = getInvocationConfig(args);
    const {
        bridge,
        params,
        callback,
        options: { timeout = globalConfig.timeout ?? 0 },
    } = config;
    const [namespace, method] = bridge.split('.') as [
        InvocationBridgeNamespace<T>,
        InvocationBridgeName<T>,
    ];

    // 基于 10.5.10 之前版本 如果url 以 market://开头 调用NativeModules.KRNBasic.open方法.
    // https://team.corp.kuaishou.com/task/T2502723
    if (
        method === 'loadUri' &&
        namespace === 'platform' &&
        Platform.OS === 'android' &&
        (params as InvocationParams<'platform.loadUri'>)?.url?.startsWith(
            'market://',
        )
    ) {
        const appVersion = getAppVersion();
        if (versionCompare(appVersion, '10.5.20') === VersionIs.LessThan) {
            return loadUri(params as any);
        }
    }

    // @ts-ignore 类型声明中暂时没有这个 bridge
    if (method === 'getSlideBack' && namespace === 'tool') {
        return getSlideBack(JSON.parse(normalParams(params || {})));
    }
    // @ts-ignore 类型声明中暂时没有这个 bridge
    if (method === 'setSlideBack' && namespace === 'tool') {
        return setSlideBack(JSON.parse(normalParams(params || {})));
    }

    // https://team.corp.kuaishou.com/task/T3494368
    if (method === 'exitPageWithInfo' && namespace === 'ui') {
        return exitPageWithInfo(JSON.parse(normalParams(params || {})));
    }

    if (callbackOnlyBridgeSet.has(bridge)) {
        // 只支持多次回调的 bridge，需要注册 callbackId
        const callbackId = generateUUID();
        callbacks.set(callbackId, (result: any) => {
            const data = globalConfig.isSetSerializer
                ? globalConfig.serializer.parse(result)
                : result;
            callback?.(data);
        });
        if (globalConfig.isSetSerializer && NativeModules.Kds?.invokeWithArgs) {
            NativeModules.Kds.invokeWithArgs({
                rootTag: params?.rootTag || globalConfig.rootTag,
                nameSpace: normalNamespace(namespace),
                method,
                params: normalParams(params),
                callbackId,
                multiCallback: true,
                callbackType: 'str',
            });
            return undefined;
        }
        NativeModules.Kds.invokeWithMultiCallback(
            normalNamespace(namespace),
            method,
            normalParams(params),
            callbackId,
        );
        return undefined;
    }

    const baseInvoking = new Promise((resolve, reject) => {
        const baseInvokingSuccessHandle = (data: any) => {
            // 返回的结果中如果有 result 字段时且不为 1，则按照错误处理，进入 reject
            if (
                data &&
                'result' in data &&
                typeof data.result === 'number' &&
                data.result !== 1
            ) {
                reject(
                    new BridgeError(
                        `bridge：${bridge} 调用出错，调用参数为：${JSON.stringify(
                            params,
                        )}，错误信息为：${
                            data.error_msg || data.message || ''
                        }`,
                        data.result,
                        {
                            bridge,
                            params,
                        },
                    ),
                );
                return;
            }
            if (data && data.result === 1) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { result, ...restData } = data;
                resolve(restData);
                return;
            }
            resolve(data);
        };
        const baseInvokingFailHandle = (err: any) => {
            reject(dealRejectErrorInfo(err));
        };
        if (globalConfig.isSetSerializer && NativeModules.Kds?.invokeWithArgs) {
            NativeModules.Kds.invokeWithArgs({
                rootTag: params?.rootTag || globalConfig.rootTag,
                nameSpace: normalNamespace(namespace),
                method,
                params: normalParams(params),
                callbackType: 'str',
            }).then((res: any) => {
                const data = globalConfig.serializer.parse(res);
                baseInvokingSuccessHandle(data);
            }, baseInvokingFailHandle);
            return;
        }
        NativeModules.Kds.invoke(
            normalNamespace(namespace),
            method,
            normalParams(params),
        ).then(baseInvokingSuccessHandle, baseInvokingFailHandle);
    }) as InvocationPromise<T>;

    const invoking =
        timeout > 0 && Number.isFinite(timeout)
            ? Promise.race([
                  baseInvoking,
                  delay(timeout).then(() =>
                      Promise.reject(
                          new BridgeError('timeout', 125010, {
                              bridge,
                              params: config.params,
                          }),
                      ),
                  ),
              ])
            : baseInvoking;

    return invoking;
};

export const invokeSync = <T extends keyof YodaSupportSyncBridges>(
    ...args: InvocationParameters<T>
): InvocationResponse<T> => {
    const config = getInvocationConfig(args);
    const { bridge, params } = config;

    const unSupported = globalConfig.isSetSerializer
        ? !NativeModules.Kds?.syncInvokeWithReturnStr
        : !NativeModules.Kds?.syncInvoke;
    if (unSupported) {
        throw new BridgeError('当前客户端版本不支持同步调用', -1, {
            bridge,
            params,
        });
    }

    const [namespace, method] = bridge.split('.') as [
        InvocationBridgeNamespace<T>,
        InvocationBridgeName<T>,
    ];

    // 修改支持同步调用的列表时，请先修改 api/index.ts 下面的 SupportSyncAPI 和 SupportSyncAPIMethodName
    const supportedNamespaces = [
        'platform' as const,
        'system' as const,
        'tool' as const,
        'social' as const,
    ];
    const supportedMethodNames = {
        system: [
            'isNetworkConnected',
            'getServerTime',
            'isBottomNavigationBarShown',
            'getNetworkType',
            'getPushPermission',
            'isPad',
            'getDisplaySetting',
            'getNavigationBarHeight',
            'deviceIsLandscape',
        ],
        platform: ['getDarkMode'],
        tool: [
            'getClipBoard',
            'getKswitchData',
            'canIUse',
            'getABTestInfo',
            'getStartUpData',
        ],
        social: [
            'getNoticeRecoTextSync',
            'getPymkRecoTextSync',
            'getRemarkNameSync',
            'getSocialMultiStringLangsSync',
        ],
    };
    // 不支持的命名空间
    if (supportedNamespaces.indexOf(namespace) === -1) {
        throw new BridgeError(`${namespace} 命名空间不支持同步调用`, -1, {
            bridge,
            params,
        });
    }
    // 不支持的方法名
    if (supportedMethodNames[namespace].indexOf(method as any) === -1) {
        throw new BridgeError(
            `${namespace} 命名空间的 ${method} 方法不支持同步调用`,
            -1,
            {
                bridge,
                params,
            },
        );
    }

    // 如果调用 tool.getKswitchData，在 10.4.40 之前使用 NativeModules.SwitchBridge.getKswitchDataSync 调用
    if (method === 'getKswitchData' && namespace === 'tool') {
        const appVersion = getAppVersion();
        if (versionCompare(appVersion, '10.4.40') === VersionIs.LessThan) {
            return getKswitchData(params as any);
        }
    }
    let resultOrError;
    // 如果自定义了 serializer 就走新方法
    if (globalConfig.isSetSerializer) {
        const withReturnStrResultOrErrorString =
            NativeModules.Kds.syncInvokeWithReturnStr({
                rootTag: params?.rootTag || globalConfig.rootTag,
                nameSpace: normalNamespace(namespace),
                method,
                params: normalParams(params),
                callbackType: 'str',
            });
        resultOrError = globalConfig.serializer.parse(
            withReturnStrResultOrErrorString,
        );
    } else {
        // 否则走旧方法
        resultOrError = NativeModules.Kds.syncInvoke({
            nameSpace: normalNamespace(namespace),
            method,
            params: normalParams(params),
        });
    }
    if (resultOrError && 'errorCode' in resultOrError) {
        resultOrError.code = resultOrError.errorCode;
        resultOrError.message = resultOrError.errorMsg;
        // 删除掉原来的错误码及错误信息字段
        delete resultOrError.errorCode;
        delete resultOrError.errorMsg;

        throw dealRejectErrorInfo(resultOrError);
    }
    return resultOrError;
};
