const parser = require("@babel/parser");
const traverse  = require("@babel/traverse");
const fs = require("fs")
const { SourceMapConsumer } = require("source-map")

const argIsNumberOrIdentifierOrExpression = (argItem) => {
  // 判断入口参数是 数字/变量/表达式/带符号的数字/函数返回值
  return (
    argItem.isNumericLiteral() ||
    argItem.isUnaryExpression() ||
    argItem.isBinaryExpression() ||
    argItem.isIdentifier() ||
    argItem.isCallExpression()
  )
}

const argIsFuncOrIdentifierOrCallExpression = (argItem) => {
  // 判断入口参数是否为 变量/函数/函数返回值
  return (
    argItem.isFunctionExpression() ||
    argItem.isArrowFunctionExpression() ||
    argItem.isIdentifier() ||
    argItem.isCallExpression()
  )
}

const calleeIsIdentifierOrArrayOrCallExpression = (caller) => {
  // 判断调用者是否为 变量/数组/函数返回值
  return (
    caller.isArrayExpression() ||
    caller.isIdentifier() ||
    caller.isCallExpression()
  )
}

const arrayPrototypeArgIsNumberOrEmpty = (path, allowEmptyArg = false) => {
  const calleeObj = path.get("callee").get("object")
  const arg = path.get("arguments")
  // 判断调用者
  const calleeFlag = calleeIsIdentifierOrArrayOrCallExpression(calleeObj)
  // 判断入口参数
  let argFlag
  if (allowEmptyArg) {
    // 是否允许入口参数为空
    argFlag =
      arg.length === 0 ||
      (arg.length === 1 && argIsNumberOrIdentifierOrExpression(arg[0]))
  } else {
    argFlag = arg.length === 1 && argIsNumberOrIdentifierOrExpression(arg[0])
  }
  return calleeFlag && argFlag
}

const arrayPrototypeArgIsFucOrEmpty = (path, allowEmptyArg = false) => {
  const calleeObj = path.get("callee").get("object")
  const arg = path.get("arguments")
  // 判断调用者
  const calleeFlag = calleeIsIdentifierOrArrayOrCallExpression(calleeObj)
  // 判断入口参数
  let argFlag
  if (allowEmptyArg) {
    argFlag =
      arg.length === 0 ||
      (arg.length === 1 && argIsFuncOrIdentifierOrCallExpression(arg[0]))
  } else {
    argFlag = arg.length === 1 && argIsFuncOrIdentifierOrCallExpression(arg[0])
  }
  return calleeFlag && argFlag
}

const unSupportRules = [
  {
    reg: /^finally$/,
    isReal: (path) => {
      const calleeObj = path.get("callee").get("object")
      // 判断调用者是否函数返回值
      const isCalleeCallExpression = calleeObj.isCallExpression()
      // 判断调用者是否为new Promise
      const isNewPromise =
        calleeObj.isNewExpression() &&
        calleeObj.get("callee").isIdentifier() &&
        calleeObj.get("callee").node.name === "Promise"

      // 判断调用者是否为变量
      const isIdentifierCallee = calleeObj.isIdentifier()

      // 判断传入值是否为 空 / function / 变量 / 函数返回值
      const paramsIsEmpty = path.get("arguments").length === 0
      const paramsIsFunc =
        path.get("arguments").length === 1 &&
        argIsFuncOrIdentifierOrCallExpression(path.get("arguments")[0])

      return (
        (isCalleeCallExpression || isNewPromise || isIdentifierCallee) &&
        (paramsIsEmpty || paramsIsFunc)
      )
    },
  },
  {
    reg: /^at$/,
    isReal: (path) => {
      return arrayPrototypeArgIsNumberOrEmpty(path)
    },
  },
  {
    reg: /^flat$/,
    isReal: (path) => {
      return arrayPrototypeArgIsNumberOrEmpty(path, true)
    },
  },
  {
    reg: /^flatMap$/,
    isReal: (path) => {
      return arrayPrototypeArgIsFucOrEmpty(path)
    },
  },
  {
    reg: /^with$/,
    isReal: (path) => {
      const calleeObj = path.get("callee").get("object")
      const arg = path.get("arguments")
      // 判断调用者
      const calleeFlag = calleeIsIdentifierOrArrayOrCallExpression(calleeObj)
      // 判断入口参数
      const argFlag =
        arg.length === 2 && argIsNumberOrIdentifierOrExpression(arg[0])
      return calleeFlag && argFlag
    },
  },
  {
    reg: /^toSpliced$/,
    isReal: (path) => {
      const calleeObj = path.get("callee").get("object")
      const arg = path.get("arguments")
      // 判断调用者
      const calleeFlag = calleeIsIdentifierOrArrayOrCallExpression(calleeObj)
      // 判断入口参数
      const argFlag =
        arg.length === 0 ||
        (arg.length === 1 && argIsNumberOrIdentifierOrExpression(arg[0])) ||
        (arg.length > 1 &&
          argIsNumberOrIdentifierOrExpression(arg[0]) &&
          argIsNumberOrIdentifierOrExpression(arg[1]))
      return calleeFlag && argFlag
    },
  },
  {
    reg: /^toSorted$/,
    isReal: (path) => {
      return arrayPrototypeArgIsFucOrEmpty(path, true)
    },
  },
  {
    reg: /^toReversed$/,
    isReal: (path) => {
      const calleeObj = path.get("callee").get("object")
      const arg = path.get("arguments")
      // 判断调用者
      const calleeFlag = calleeIsIdentifierOrArrayOrCallExpression(calleeObj)
      return calleeFlag && arg.length === 0
    },
  },
  {
    reg: /^findLast$/,
    isReal: (path) => {
      return arrayPrototypeArgIsFucOrEmpty(path)
    },
  },
  {
    reg: /^findLastIndex$/,
    isReal: (path) => {
      return arrayPrototypeArgIsFucOrEmpty(path)
    },
  },
]

module.exports = async function checkJSCode(filePath, sourceMapFilePath, ignoreRules = []) {
  const code = fs.readFileSync(filePath, "utf-8")
  const ast = parser.parse(code)
  const cache = []

  traverse.default(ast, {
    CallExpression(path, state) {
      const fucPath = path.get("callee").get("property")
      const fucPathNode = fucPath.node
      if (fucPathNode) {
        if (
          unSupportRules.some(
            (item) => item.reg.test(fucPathNode.name) && item.isReal(path)
          ) && !(ignoreRules.includes(fucPathNode.name))
        ) {
          cache.push({
            name: fucPathNode.name,
            line: fucPathNode.loc.start.line,
            column: fucPathNode.loc.start.column,
            filePath: filePath,
          })
        }
      }
    },
  })

  if (sourceMapFilePath && fs.existsSync(sourceMapFilePath)) {
    // 如果传了sourcemap 就进行行列反解
    const whatever = await SourceMapConsumer.with(
      fs.readFileSync(sourceMapFilePath, "utf8"),
      null,
      (consumer) => {
        return cache.map((val) => {
          const sourcemapOutput = consumer.originalPositionFor({
            line: val.line,
            column: val.column,
          })
          return {
            name: val.name,
            line: sourcemapOutput.line,
            column: sourcemapOutput.column,
            filePath: sourcemapOutput.source,
          }
        })
      }
    )
    return whatever
  }
  return cache
}
