"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reactNativeAssetsLoader = exports.raw = void 0;
const path = require("path");
const utils = require("loader-utils");
const schema_utils_1 = require("schema-utils");
const image_size_1 = require("image-size");
const dedent = require("dedent");
const hasha = require("hasha");
const escapeStringRegexp = require("escape-string-regexp");
const plugins_1 = require("../plugins");
function getOptions(loaderContext) {
    const options = utils.getOptions(loaderContext) || {};
    (0, schema_utils_1.validate)({
        type: 'object',
        required: ['platform'],
        properties: {
            platform: {
                type: 'string',
            },
            bundleToFile: { type: 'boolean' },
            publicPath: { type: 'string' },
            assetDest: { type: 'string' },
        },
    }, options, { name: 'reactNativeAssetsLoader' });
    return options;
}
exports.raw = true;
function reactNativeAssetsLoader(contents) {
    return __awaiter(this, void 0, void 0, function* () {
        this.cacheable();
        const callback = this.async();
        const logger = this.getLogger('reactNativeAssetsLoader');
        const rootContext = this.rootContext;
        logger.debug('Processing:', this.resourcePath);
        const content = contents.toString();
        // 如果文件内容中包含了 skipedSuffix，说明该文件已经被处理过了，直接返回
        const skipedSuffix = 'KRN Webpack Default AssetsLoader Skiped';
        if (content.indexOf(skipedSuffix) !== -1) {
            logger.debug('KRN Webpack Default AssetsLoader Skiped:', this.resourcePath);
            callback === null || callback === void 0 ? void 0 : callback(null, contents);
            return;
        }
        try {
            const options = getOptions(this);
            const pathSeparatorPattern = new RegExp(`\\${path.sep}`, 'g');
            const resourcePath = this.resourcePath;
            const dirname = path.dirname(resourcePath);
            // Relative path to rootContext without any ../ due to https://github.com/callstack/haul/issues/474
            // Assets from from outside of rootContext, should still be placed inside bundle output directory.
            // Example:
            //   resourcePath    = monorepo/node_modules/my-module/image.png
            //   dirname         = monorepo/node_modules/my-module
            //   rootContext     = monorepo/packages/my-app/
            //   relativeDirname = ../../node_modules/my-module (original)
            // So when we calculate destination for the asset for iOS ('assets' + relativeDirname + filename),
            // it will end up outside of `assets` directory, so we have to make sure it's:
            //   relativeDirname = node_modules/my-module (tweaked)
            const relativeDirname = path
                .relative(rootContext, dirname)
                .replace(new RegExp(`^[\\.\\${path.sep}]+`), '');
            const type = path.extname(resourcePath).replace(/^\./, '');
            const assetsPath = 'assets';
            const suffix = `(@\\d+(\\.\\d+)?x)?(\\.(${options.platform}|native))?\\.${type}$`;
            const filename = path
                .basename(resourcePath)
                .replace(new RegExp(suffix), '');
            // Name with embedded relative dirname eg `node_modules_reactnative_libraries_newappscreen_components_logo.png`
            const normalizedName = `${(relativeDirname.length === 0
                ? filename
                : `${relativeDirname.replace(pathSeparatorPattern, '_')}_${filename}`)
                .toLowerCase()
                .replace(/[^a-z0-9_]/g, '')}.${type}`;
            // 如果是 svg 文件，其他 loader 已经处理过了，直接返回
            if (type === 'svg') {
                const exportMatches = /^module.exports\s*=\s*(.*)/.test(content);
                const exportDefaultMatches = /export default\s*(.*)/.test(content);
                if (exportMatches || exportDefaultMatches) {
                    callback === null || callback === void 0 ? void 0 : callback(null, contents);
                    return;
                }
            }
            const files = yield new Promise((resolve, reject) => this.fs.readdir(dirname, (error, results) => {
                var _a, _b;
                if (error) {
                    reject(error);
                }
                else {
                    resolve((_b = (_a = results) === null || _a === void 0 ? void 0 : _a.filter((result) => typeof result === 'string')) !== null && _b !== void 0 ? _b : []);
                }
            }));
            const scales = plugins_1.AssetResolver.collectScales(files, {
                name: filename,
                type,
                platform: options.platform,
            });
            const scaleKeys = Object.keys(scales).sort((a, b) => parseInt(a.replace(/[^\d.]/g, ''), 10) -
                parseInt(b.replace(/[^\d.]/g, ''), 10));
            const scaleNums = scaleKeys.map(item => parseInt(item.replace(/[^\d.]/g, ''), 10));
            const assets = yield Promise.all(scaleKeys.map((scale) => {
                const scaleFilePath = path.join(dirname, scales[scale].name);
                this.addDependency(scaleFilePath);
                return new Promise((resolve, reject) => this.fs.readFile(scaleFilePath, (error, results) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        let destination;
                        if (options.bundleToFile && options.platform === 'android') {
                            const testXml = /\.(xml)$/;
                            const testMP4 = /\.(mp4)$/;
                            const testImages = /\.(png|jpg|gif|webp)$/;
                            const testFonts = /\.(ttf|otf|ttc)$/;
                            // found font family
                            if (testXml.test(normalizedName) &&
                                (results === null || results === void 0 ? void 0 : results.indexOf('font-family')) !== -1) {
                                destination = 'font';
                            }
                            else if (testFonts.test(normalizedName)) {
                                // font extensions
                                destination = 'font';
                            }
                            else if (testMP4.test(normalizedName)) {
                                // video files extensions
                                destination = 'raw';
                            }
                            else if (testImages.test(normalizedName) ||
                                testXml.test(normalizedName)) {
                                // images extensions
                                switch (scale) {
                                    case '@0.75x':
                                        destination = 'drawable-ldpi';
                                        break;
                                    case '@1x':
                                        destination = 'drawable-mdpi';
                                        break;
                                    case '@1.5x':
                                        destination = 'drawable-hdpi';
                                        break;
                                    case '@2x':
                                        destination = 'drawable-xhdpi';
                                        break;
                                    case '@3x':
                                        destination = 'drawable-xxhdpi';
                                        break;
                                    case '@4x':
                                        destination = 'drawable-xxxhdpi';
                                        break;
                                    default:
                                        throw new Error(`Unknown scale ${scale} for ${scaleFilePath}`);
                                }
                            }
                            else {
                                // everything else is going to RAW
                                destination = 'raw';
                            }
                            destination = path.join(destination, normalizedName);
                        }
                        else {
                            const name = `${filename}${scale === '@1x' ? '' : scale}.${type}`;
                            destination = path.join(assetsPath, relativeDirname, name);
                        }
                        resolve({
                            destination,
                            content: results,
                        });
                    }
                }));
            }));
            assets.forEach((asset) => {
                const { destination, content } = asset;
                logger.debug('Asset emitted:', destination);
                // Assets are emitted relatively to `output.path`.
                this.emitFile(options.assetDest ? path.join(options.assetDest, destination) : destination, content !== null && content !== void 0 ? content : '');
            });
            let publicPath = path
                .join(assetsPath, relativeDirname)
                .replace(pathSeparatorPattern, '/');
            if (options.publicPath) {
                publicPath = path.join(options.publicPath, publicPath);
            }
            const hashes = yield Promise.all(assets.map((asset) => {
                var _a;
                return hasha.async((_a = Buffer.from(asset.content || '')) !== null && _a !== void 0 ? _a : asset.destination, {
                    algorithm: 'md5',
                });
            }));
            let info;
            try {
                info = (0, image_size_1.imageSize)(this.resourcePath);
                const match = path
                    .basename(this.resourcePath)
                    .match(new RegExp(`^${escapeStringRegexp(filename)}${suffix}`));
                if (match === null || match === void 0 ? void 0 : match[1]) {
                    const scale = Number(match[1].replace(/[^\d.]/g, ''));
                    if (typeof scale === 'number' && Number.isFinite(scale)) {
                        info.width && (info.width /= scale);
                        info.height && (info.height /= scale);
                    }
                }
            }
            catch (e) {
                // Asset is not an image
            }
            logger.debug('Asset processed:', {
                resourcePath,
                platform: options.platform,
                rootContext,
                relativeDirname,
                type,
                assetsPath,
                filename,
                normalizedName,
                scales,
                assets: assets.map((asset) => asset.destination),
                publicPath,
                width: info === null || info === void 0 ? void 0 : info.width,
                height: info === null || info === void 0 ? void 0 : info.height,
            });
            callback === null || callback === void 0 ? void 0 : callback(null, dedent `
      var AssetRegistry = require('react-native/Libraries/Image/AssetRegistry');
      module.exports = AssetRegistry.registerAsset({
        __packager_asset: true,
        scales: ${JSON.stringify(scaleNums)},
        name: ${JSON.stringify(filename)},
        type: ${JSON.stringify(type)},
        hash: ${JSON.stringify(hashes.join())},
        httpServerLocation: ${JSON.stringify(publicPath)},
        ${options.bundleToFile
                ? ''
                : `fileSystemLocation: ${JSON.stringify(dirname)},`}
        ${info ? `height: ${info.height},` : ''}
        ${info ? `width: ${info.width},` : ''}
      });
      `);
        }
        catch (error) {
            callback === null || callback === void 0 ? void 0 : callback(error);
        }
    });
}
exports.reactNativeAssetsLoader = reactNativeAssetsLoader;
exports.default = reactNativeAssetsLoader;
//# sourceMappingURL=assetsLoader.js.map