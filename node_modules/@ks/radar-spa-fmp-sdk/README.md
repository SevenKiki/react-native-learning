# spa fmp方案

# 发布流程
* 改package里的版本号
* 切换到 `master` 发布
```
npm i
npm run build
npm publish
```


# 指标说明
<span style="color: red;">以下4个指标每个页面只会上报一次，其中FMP、FFP只有在浏览器初始打开的页面会上报（后续切换后的页面不会上报），SFMP、SFFP每个页面都会上报一次</span>


| 指标名 | 指标中文名 | 字段说明 | 雷达对应字段 | 计算公式 |
| ---- | ------ | ---- | ------ | ------ |
| FMP (First Meaningful Paint) | 首屏时间 | 记录浏览器打开时页面首屏重要内容渲染完的耗时，它是体现页面整体性能的一个指标。只有在浏览器初始打开的页面会上报（后续切换后的页面不会上报） | fmp |页面核心模块渲染完成时刻 - navigationStart |
| SFMP (SPA First Meaningful Paint) | SPA页面首屏时间 | SPA应用从进入路由页面开始到页面首屏重要内容渲染完的耗时。每个页面都会上报一次 | radar_spa_sfmp(event表) |页面核心模块渲染完成时刻 - beforeEach(vue导航守卫) |
| FFP (First framework Pain) | 页面框架挂载时间 | 从打开浏览器开始到前端同步内容渲染完成的耗时(反映纯前端性能)。只有在浏览器初始打开的页面会上报（后续切换后的页面不会上报） | radar_spa_ffp(event表) | 路由页面mounted时刻 - navigationStart|
| SFFP (SPA First framework Pain) | 页面框架挂载时间 | SPA应用从进入路由页面到前端同步内容渲染完成的耗时(反映纯前端性能)。每个页面都会上报一次 | radar_spa_sffp(event表) | 路由页面mounted时刻 - beforeEach(vue导航守卫) |


# 前置要求
* 需要项目中有`@ks-radar/radar-navigation-collect`和`@ks-radar/radar-core`两个包，需要传入这两个包的实例

# 适用范围
* vue2、vue3、react
* 微前端

# 接入教程
## 第一步：Install
```shell
npm install -D @ks/radar-spa-fmp-sdk
```

## 第二步：`main.js`中引入插件
```js
import router from './router';
import { Weblog } from '@ks/weblogger';
import RadarCore from '@ks-radar/radar-core';
import RadarNavigationCollect from '@ks-radar/radar-navigation-collect';
import RadarSpaFmpCollect from '@ks/radar-spa-fmp-sdk';

// 1.初始化weblogger(可以不放在main.js初始化)
const weblogger = new Weblog({
    env: 'production',
}, {
    product_name: 'data_authority_center', // weblog的KPN
    user_id: 'zhangsan', // 当前登录用户的英文名
});

// 2.初始化RadarCore，将weblogger传入
const core = new RadarCore({
    projectId: '6daeed631412312', // 雷达ID
    sampling: 1, // 上报采样率，1 为全部上报
    weblogger, // 传入weblogger实例
});

// 3.初始化RadarNavigationCollect插件，该插件上报基础性能参数（如：dns耗时...）
const navCollect = new RadarNavigationCollect({
    core,
})

/**
 * 作用：每个页面的核心模块CSS选择器对应关系
 * @pageMainElMap {routePath: cssSelector}
 *  routePath：页面router的path
 *  cssSelector：核心模块CSS选择器
 * 注意：cssSelector一般为动态数据内容容器元素，cssSelector需要在在页面mounted时已存在，否则监听不到渲染完成
 */
const pageMainElMap = {
    '/assets-search-home': '.hot-tab-content',
    '/hive/detail': '.hive-coloumn-table .ks-table__body-wrapper tbody'
};
// 4.初始化SPA FMP采集器 （最好放在main.js中）
window.spaCollect = new RadarSpaFmpCollect({
    core, // 若此时没有实例化，可以后续通过RadarSpaFmpCollect实例的updateDependence方法更新
    navCollect, // 若此时没有实例化，可以后续通过RadarSpaFmpCollect实例的updateDependence方法更新
    router, // 【选填】vue 的router实例，如果无法传入也可选择使用routeChange的方案使用
    config: {
        isDebugger: true,
        pageMainElMap,
    },
});

new Vue({
    router,
    render: h => h(App),
}).$mount('#app');
```

**注意**
如果`new RadarCore`和`new RadarNavigationCollect`不是在main.js中实例化，实例化后可以通过调用`RadarSpaFmpCollect`实例上的`updateDependence`方法更新传入的`RadarCore`和`RadarNavigationCollect`实例

示例：
```js
const core = new RadarCore(...);
const navCollect = new RadarNavigationCollect(...)

window.spaCollect.updateDependence({
    core,
    navCollect,
})
```

### 说明：
插件传入参数说明

| 参数 | 说明 | 类型 | 可选值 | 默认值 |
| ---- | ---- | ---- | ------ | ------ |
| core | 雷达RadarCore实例 | - | ------ | - |
| router | 传入`new Vue()`的router，插件内会使用`router.beforeEach`钩子 | Router | ------ | ------ |
| config.pageMainElMap | 每个页面的核心模块CSS选择器对应关系 | Object | ------ | {} |
| config.isDebugger | 是否打开开发模式,会在控制台打印指标时间 | Boolean | true/false | false |

**pageMainElMap说明：**

`config.pageMainElMap` 是每个页面核心模块父容器对应的css选择器，它是Object类型，`{routePath: cssSelector}`

* routePath：页面router的path
* cssSelector：核心模块CSS选择器。**cssSelector一般为动态数据内容容器元素，cssSelector需要在在页面mounted时已存在，否则监听不到渲染完成**


## 第三步：在每个页面的`index.vue`文件中上报核心数据（FMP、SFMP、FFP、SFFP）：
#### 方式一：合并上报4个指标
在每个路由页面的index文件中使用插件的`spa(routePath)`方法上报，就会自动上报`FMP`、`SFMP`、`FFP`、`SFFP`指标。
`routePath`参数是每个页面的`route.path`
```html
<template>
    <div>
        这是一个页面的index文件
    </div>
</template>
<script>
export default {
    name: 'test-page',
    mounted() {
        window.spaCollect.spa(this.$route.path); // 页面性能上报，放在mounted第一行
        ...
    }
};
</script>
```

#### 方式二：自行找时机手动上报每个指标
自己根据指标含义判断上报时机，然后调用以下方法上报
* `fmp(routePath)`: 上报FMP，传入当前页面routePath
* `sfmp(routeId)`: 上报SFMP，传入当前页面routeId(可以是自己定义的能标志这个页面的id)
* `ffp(routePath)`: 上报FFP，传入当前页面routePath
* `sffp(routeId)`: 上报SFFP，传入当前页面routeId(可以是自己定义的能标志这个页面的id)
```html
<template>
    <div>
        这是一个页面的index文件
    </div>
</template>
<script>
export default {
    name: 'test-page',
    mounted() {
        const routePath = this.$route.path;
        // FFP、SFFP须在页面index的mounted时机上报
        window.spaCollect.ffp(routePath);
        window.spaCollect.sffp(routePath);
    },
    methods: {
        afterChartRender() { // FMP、SFMP自己把握上报时机
            const routePath = this.$route.path;
            window.spaCollect.fmp(routePath);
            window.spaCollect.sfmp(routePath);
        }
    }
};
</script>
```



## 不传入router方案

​	传入router的方案目前只支持传入vue的router实例，采集器内部会使用 `router.beforeEach` 记录页面的起点。但对于其他技术栈，或者微前端场景下的子页面路由跳转，无法有较好的支持。

​	因此提供一个**routeChange**的方法，用于记录路由页面的起点，建议在beforeEach或类似beforeEach的时机进行调用。

```typescript
const routePath = this.$route.path;
window.spaCollect.routeChange(routePath);
```

​	提供 **reportRpv** 方法，用于上报spa的路由改变次数，在传入router的方案里会在 `router.afterEach`  自动进行数据上报。在不传入`router` 的场景下，建议在类似 `router.afterEach` 的时机进行调用。

```typescript
window.spaCollect.reportRpv(extendInfo); // extendInfo 为附加信息，支持在日志查询模块查看
```

# 拓展

## 拓展参数
* spa(routePath, extendInfo)
    * routePath: 【必填】 当前页面路由path
    * extendInfo: 【可选】雷达extra_info字段
* fmp(routePath, timestamp)
    * routePath: 【必填】当前页面路由path
    * timestamp: 【可选】外部自定义发生fmp时的时间戳
* sfmp(routeId, extendInfo, timestamp)
    * routeId: 【必填】当前页面routeId(可以是自己定义的能标志这个页面的id)
    * extendInfo: 【可选】雷达extra_info字段
    * timestamp: 【可选】外部自定义发生sfmp时的时间戳
* ffp(routePath, extendInfo)
    * routePath: 【必填】当前页面路由path
    * extendInfo: 【可选】雷达extra_info字段
* sffp(routeId, extendInfo)
    * routeId: 【必填】当前页面routeId(可以是自己定义的能标志这个页面的id)
    * extendInfo: 【可选】雷达extra_info字段