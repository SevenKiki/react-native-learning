(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.TimingMonitor = factory());
})(this, (function () { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }

    var sdkName = 'webLogger';
    function error() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            var error_1 = sdkName === 'webLogger_krn' ? console === null || console === void 0 ? void 0 : console.log : console === null || console === void 0 ? void 0 : console.error;
            return error_1 && error_1.call.apply(error_1, __spreadArray([console], args, false));
        }
        catch (e) {
            return;
        }
    }

    /**
     * 事件监听兼容处理
     * @param {*} evtTarget  事件监听目标
     * @param {*} evtName   事件名
     * @param {*} callback  回调函数
     * @param {*} options  相关参数设置
     */
    function addMonitor(evtTarget, evtName, callback, options) {
        if ('attachEvent' in evtTarget) {
            return evtTarget.attachEvent('on' + evtName, callback);
        }
        return evtTarget.addEventListener(evtName, callback, options);
    }
    /**
     * 事件监听解绑兼容处理
     * @param {*} evtTarget  事件监听目标
     * @param {*} evtName   事件名
     * @param {*} callback  事件回调
     */
    function removeMonitor(evtTarget, evtName, callback, options) {
        if ('attachEvent' in evtTarget) {
            return evtTarget.detachEvent('on' + evtName, callback);
        }
        return evtTarget.removeEventListener(evtName, callback, options);
    }

    var BasePlugin = /** @class */ (function () {
        function BasePlugin() {
        }
        BasePlugin.prototype.apply = function (weblog) {
            this.weblog = weblog;
        };
        return BasePlugin;
    }());
    /**
     * 在 bootstrap 环境下自动注册插件
     * @param Plugin
     * @param optionKey
     */
    var autoRegister = function (Plugin, optionKey) {
        var _a;
        if (typeof window === 'undefined' ||
            typeof window._GLOBAL_KS_WEBLOGGER_ === 'undefined' ||
            typeof Plugin !== 'function')
            return;
        var _b = window._GLOBAL_KS_WEBLOGGER_, weblog = _b.weblog, config = _b.config;
        var option = optionKey ? (_a = config.plugins[optionKey]) === null || _a === void 0 ? void 0 : _a.options : undefined;
        weblog.addPluginInstance(new Plugin(option));
    };

    var perf = typeof window !== 'undefined'
        ? window.performance
        : null;
    var performanceTiming = perf && perf.timing || null;
    perf
        && perf.getEntriesByType
        && perf.getEntriesByType('navigation')[0]
        || null;

    // TODO页面停留时间先依赖一个全局副作用来搞，毕竟要侵入SPA模式下比较蛋疼……
    var perfMap = {
        // DNS查找时间
        dnsLookup: {
            end: 'domainLookupEnd',
            start: 'domainLookupStart',
        },
        // TCP建连时间
        tcpConnection: {
            end: 'connectEnd',
            start: 'connectStart',
        },
        // 静态资源加载时间
        resourceLoad: {
            end: 'responseEnd',
            start: 'requestStart',
        },
        // 首屏JS耗时……暂时先这么对付了，具体JS的耗时后面再提供吧
        // 计算的时候以第一个script开始时间点为起始，一直到DOM Complete完成
        // 这样看起来应该是可被定义为JS耗时了……
        jsCost: {
            custom: function () {
                if (typeof performance.getEntries !== 'function') {
                    return 0;
                }
                var entries = performance.getEntries();
                var pageTimeInfo = entries[0];
                var firstJSTimeInfo = entries
                    .filter(function (item) { return item.initiatorType === 'script'; })[0];
                if (firstJSTimeInfo && pageTimeInfo) {
                    return pageTimeInfo.domComplete - firstJSTimeInfo.fetchStart;
                }
                return 0;
            },
        },
        // DOM加载完毕时间
        documentContentLoaded: {
            end: 'domComplete',
            start: 'fetchStart',
        },
        // 页面加载完毕时间
        load: {
            end: 'loadEventEnd',
            start: 'fetchStart',
        },
        timeToFirstByte: {
            end: 'loadEventEnd',
            start: 'fetchStart',
        },
        // 首屏时间，依靠主动打点
        firstScreen: {
            custom: function (key, options) {
                var endPoint = (options || {}).endPoint;
                var end = typeof endPoint !== 'undefined' ? endPoint : new Date().valueOf();
                return performanceTiming && (end - performanceTiming.fetchStart) || 0;
            },
        },
        // 白屏时间，依靠主动打点
        whiteScreen: {
            custom: function (key, options) {
                var endPoint = (options || {}).endPoint;
                var end = typeof endPoint !== 'undefined' ? endPoint : new Date().valueOf();
                return performanceTiming && (end - performanceTiming.fetchStart) || 0;
            },
        },
    };
    var TimingMonitor = /** @class */ (function (_super) {
        __extends(TimingMonitor, _super);
        /**
         * 兼容写法，如果在 Weblog 初始化设置 plugins 时，不需要设置 weblog
         * @param weblog
         */
        function TimingMonitor(weblog) {
            var _this = _super.call(this) || this;
            _this.load = function () {
                // 严格意义上来说类似的时间对于onload计算，都是等到window.onload执行完毕才开始计算
                // 所以页面加载完毕时间使用的是loadEventEnd事件，所以手动进入下一个event loop
                // 确保获取loadEventEnd事件
                setTimeout(function () {
                    var perfInfo = _this.collect();
                    if (!perfInfo) {
                        return;
                    }
                    [
                        'load',
                        'documentContentLoaded',
                        'dnsLookup',
                        'tcpConnection',
                        'jsCost',
                        'timeToFirstByte',
                    ].forEach(function (key) {
                        var _a;
                        // TODO后面做一个支持度list来维护，现在先手动过滤一下
                        if (key === 'jsCost' && perfInfo[key] === 0) {
                            return;
                        }
                        _this.weblog.collect('CUSTOM', {
                            key: costMap[key],
                            value: (_a = {},
                                _a[costMap[key]] = perfInfo[key],
                                _a)
                        });
                    });
                });
            };
            if (!performanceTiming) {
                error('The Timing Monitor need performance APIs to Support!');
                return _this;
            }
            if (weblog) {
                _this.apply(weblog);
            }
            return _this;
        }
        TimingMonitor.prototype.apply = function (weblog) {
            this.weblog = weblog;
            addMonitor(window, 'load', this.load);
        };
        TimingMonitor.prototype.destroy = function () {
            removeMonitor(window, 'load', this.load);
        };
        TimingMonitor.prototype.calculate = function (key, options) {
            var perf = perfMap[key];
            if (!perf) {
                throw new Error('The perf key is not correct!');
            }
            if (typeof perf.custom === 'function') {
                return perf.custom(key, options);
            }
            var endPoint = performanceTiming[perfMap[key].end];
            var startPoint = performanceTiming[perfMap[key].start];
            return endPoint - startPoint;
        };
        // 目前只针对这两个需要手动打点;
        TimingMonitor.prototype.mark = function (key, options) {
            var _a;
            var data = this.collect(key, options);
            if (!data)
                return;
            this.weblog.collect('CUSTOM', {
                key: costMap[key],
                value: (_a = {},
                    _a[costMap[key]] = data[key],
                    _a)
            });
        };
        TimingMonitor.prototype.collect = function (key, options) {
            var _a;
            var _this = this;
            // 如果不支持timing api的话，就直接不上报了，免得数据污染
            if (!performanceTiming) {
                return;
            }
            if (key) {
                return _a = {},
                    _a[key] = this.calculate(key, options),
                    _a;
            }
            var allPerf = {};
            return Object.keys(perfMap).reduce(function (map, key) {
                map[key] = _this.calculate(key, options);
                return map;
            }, allPerf);
        };
        TimingMonitor.key = 'timingMonitor';
        return TimingMonitor;
    }(BasePlugin));
    // 优先使用pagehide 其次使用beforeunload;
    var costMap = {
        load: 'total_download_cost',
        documentContentLoaded: 'operational_cost',
        dnsLookup: 'dns_query_cost',
        tcpConnection: 'tcp_cost',
        jsCost: 'js_cost',
        whiteScreen: 'white_screen_cost',
        firstScreen: 'first_screen_cost',
        timeToFirstByte: 'ttfb_cost',
    };
    /**
     * 如果使用了 bootstrap 则自动注册插件
     */
    autoRegister(TimingMonitor);

    return TimingMonitor;

}));
//# sourceMappingURL=timingmonitor.js.map
