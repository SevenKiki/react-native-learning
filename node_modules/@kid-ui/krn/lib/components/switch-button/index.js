import React, { useEffect, useRef, useState } from 'react';
import { Animated, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import useThemeValue from '../../theme/useThemeValue';
import { createKidComponent, rem } from '../../utils';
const SwitchButton = (props) => {
    var _a, _b;
    const { width, height, offTintColor = { light: '#EAEAEA', dark: '#6B6B6F' }, onTintColor = { light: '#326BFB', dark: '#618EFF' }, thumbTintColor = { light: '#FFFFFF', dark: '#FFFFFF' }, isControlSwitch = false, duration = 300, disabled = false, } = props;
    const backgroundColorOn = useThemeValue(onTintColor), backgroundColorOff = useThemeValue(offTintColor), circleColorOn = useThemeValue(thumbTintColor), circleColorOff = useThemeValue(thumbTintColor);
    const [isSwitchOn, setIsSwitchOn] = useState(props.switchOn);
    useEffect(() => {
        if (isControlSwitch && isSwitchOn !== props.switchOn) {
            setIsSwitchOn(props.switchOn);
        }
    }, [props.switchOn]);
    const [animXValue] = useState(new Animated.Value(isSwitchOn ? 1 : 0));
    const getStart = () => {
        return props.type === undefined
            ? 0
            : props.type === 0
                ? 0
                : props.containerStyle && props.containerStyle.padding
                    ? props.containerStyle.padding * 2
                    : {};
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const runAnimation = () => {
        const animValue = {
            fromValue: isSwitchOn ? 0 : 1,
            toValue: isSwitchOn ? 1 : 0,
            duration,
            useNativeDriver: false,
        };
        Animated.timing(animXValue, animValue).start();
    };
    const endPos = props.containerStyle && props.circleStyle
        ? (width || props.containerStyle.width) -
            (props.circleStyle.width +
                (props.containerStyle.padding || 0) * 2)
        : 0;
    const circlePosXEnd = props.RTL ? -endPos : endPos;
    const [circlePosXStart] = useState(getStart());
    const prevSwitchOnRef = useRef();
    const prevSwitchOn = !!prevSwitchOnRef.current;
    useEffect(() => {
        prevSwitchOnRef.current = isSwitchOn;
        if (prevSwitchOn !== isSwitchOn) {
            runAnimation();
        }
    }, [prevSwitchOn, isSwitchOn, runAnimation]);
    const generateRightText = () => {
        return (<Animated.View style={props.rightContainerStyle}>
                <Text style={props.textRightStyle}>{props.backTextRight}</Text>
            </Animated.View>);
    };
    const generateLeftText = () => {
        return (<Animated.View style={props.leftContainerStyle}>
                <Text style={props.textLeftStyle}>{props.backTextLeft}</Text>
            </Animated.View>);
    };
    const generateLeftIcon = () => {
        return (<View style={{ position: 'absolute', left: 5 }}>
                {props.backgroundImageOn}
            </View>);
    };
    const generateRightIcon = () => {
        return (<View style={{ position: 'absolute', right: 5 }}>
                {props.backgroundImageOff}
            </View>);
    };
    return (<TouchableOpacity disabled={disabled} testID={props.testID} hitSlop={props.hitSlop} onPress={() => {
            let newSwitchOn = !isSwitchOn;
            if (!isControlSwitch) {
                setIsSwitchOn(newSwitchOn);
            }
            if (props.onPress) {
                props.onPress(newSwitchOn);
            }
        }} activeOpacity={1}>
            <Animated.View style={[
            styles.container,
            props.containerStyle,
            {
                width: width || ((_a = props.containerStyle) === null || _a === void 0 ? void 0 : _a.width),
                height: height || ((_b = props.containerStyle) === null || _b === void 0 ? void 0 : _b.height)
            },
            {
                backgroundColor: animXValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [
                        backgroundColorOff,
                        backgroundColorOn,
                    ],
                }),
            },
        ]}>
                {generateLeftText()}
                {isSwitchOn && generateLeftIcon()}
                <Animated.View style={[
            props.circleStyle,
            {
                backgroundColor: animXValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [
                        circleColorOff,
                        circleColorOn,
                    ],
                }),
            },
            {
                transform: [
                    {
                        translateX: animXValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: [
                                circlePosXStart,
                                circlePosXEnd,
                            ],
                        }),
                    },
                ],
            },
            props.buttonStyle,
        ]}>
                    <Animated.View style={props.buttonContainerStyle}>
                        <Text style={props.buttonTextStyle}>
                            {props.buttonText}
                        </Text>
                    </Animated.View>
                </Animated.View>
                {generateRightText()}
                {!isSwitchOn && generateRightIcon()}
            </Animated.View>
        </TouchableOpacity>);
};
SwitchButton.defaultProps = {
    containerStyle: {
        // marginTop: 16,
        width: rem(48),
        height: rem(26),
        borderRadius: rem(13),
        padding: rem(1),
    },
    circleStyle: {
        width: rem(24),
        height: rem(24),
        borderRadius: rem(12),
    },
    hitSlop: {
        top: rem(10),
        bottom: rem(10),
        left: rem(10),
        right: rem(10)
    }
};
const styles = StyleSheet.create({
    container: {
        flexDirection: 'row',
        alignItems: 'center',
    },
});
export const KidSwitchButton = createKidComponent(SwitchButton);
