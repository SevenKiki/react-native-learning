import React, { useEffect, useRef, useState } from 'react';
import { PanResponder, Text, TouchableOpacity, View, Animated, NativeModules, } from 'react-native';
import { useStyle } from './utils';
const SlideOperation = ({ rootTag, customStyle = {}, enableLeftSlideBack = true, actionWidth = 88, leftActions = [], rightActions = [], leftActionWidth, rightActionWidth, children, canSlideBackSpace = 11, index = -1, onCallBack, close = false, closeAfterClickedBtn = true, numberOfLines = 1, ellipsizeMode = 'clip' }) => {
    var _a;
    const leftWidth = leftActionWidth || actionWidth;
    const rightWidth = rightActionWidth || actionWidth;
    const maxLeftWidth = leftWidth * leftActions.length;
    const maxRightWidth = rightWidth * rightActions.length;
    const { styles } = useStyle({ customStyle });
    // 上一次滑动的偏移量
    const previousX = useRef(0);
    // 左移的偏移动画值
    const currentLeft = useRef(new Animated.Value(0)).current;
    const [canSlideBack, setCanSlideBack] = useState(true);
    //  true: 打开滑动返回  false ：关闭滑动返回
    useEffect(() => {
        var _a, _b;
        (_b = (_a = NativeModules.KRNBasic) === null || _a === void 0 ? void 0 : _a.setSlideBack) === null || _b === void 0 ? void 0 : _b.call(_a, {
            enabled: enableLeftSlideBack && canSlideBack,
            rootTag: rootTag !== null && rootTag !== void 0 ? rootTag : 0,
        });
    }, [canSlideBack, enableLeftSlideBack, rootTag]);
    /**
     * 处理移动过程中的位置变化
     * @param position 需要移动到的位置
     * @param animateType 移动动画类型
     */
    const handleAction = (position, animateType) => {
        if (animateType === 'timing') {
            Animated.timing(currentLeft, {
                toValue: position,
                duration: 500,
                useNativeDriver: false,
            }).start();
        }
        else {
            Animated.spring(currentLeft, {
                toValue: position,
                useNativeDriver: false,
            }).start();
        }
        previousX.current = position;
    };
    useEffect(() => {
        if (close) {
            handleAction(0, 'timing');
        }
    }, [close]);
    /**
     * 是否需要成为move事件响应者，返回true直接走onPanResponderMove
     * @param evt
     * @param gestureState
     */
    const handleMoveShouldSetPanResponderCapture = (evt, gestureState) => {
        const { pageX } = evt.nativeEvent;
        setCanSlideBack(pageX <= canSlideBackSpace);
        const { dx, dy } = gestureState;
        return (pageX > canSlideBackSpace &&
            (dx > 2 || dx < -2 || dy > 2 || dy < -2));
    };
    /**
     * 表示申请成功，组件成为了事件处理响应者
     */
    const handlePanResponderGrant = (evt) => {
        setCanSlideBack(evt.nativeEvent.pageX <= canSlideBackSpace);
        onCallBack && onCallBack(index);
    };
    /**
     * 处理滑动事件
     * @param evt
     * @param gestureState
     */
    const handlePanResponderMove = (evt, gestureState) => {
        setCanSlideBack(evt.nativeEvent.pageX <= canSlideBackSpace);
        const { dx } = gestureState;
        if (dx <= 0) {
            if (previousX.current < 0) {
                currentLeft.setValue(-maxRightWidth);
            }
            else if (previousX.current === 0) {
                currentLeft.setValue(Math.max(-maxRightWidth, dx));
            }
            else {
                currentLeft.setValue(Math.max(0, previousX.current + dx));
            }
        }
        else {
            if (previousX.current < 0) {
                currentLeft.setValue(Math.min(0, previousX.current + dx));
            }
            else if (previousX.current === 0) {
                currentLeft.setValue(Math.min(dx, maxLeftWidth));
            }
            else {
                currentLeft.setValue(maxLeftWidth);
            }
        }
    };
    /**
     * 手指离开屏幕时
     * @param evt
     * @param gestureState
     */
    const handlePanResponderEnd = (evt, gestureState) => {
        setCanSlideBack(evt.nativeEvent.pageX <= canSlideBackSpace);
        const { dx } = gestureState;
        if (dx <= 0) {
            if (previousX.current > 0 || (previousX.current === 0 && dx >= -maxRightWidth / 4)) {
                handleAction(0, 'timing');
            }
            else {
                handleAction(-maxRightWidth, 'spring');
            }
        }
        else {
            if (previousX.current < 0 || (previousX.current === 0 && dx <= maxLeftWidth / 4)) {
                handleAction(0, 'timing');
            }
            else {
                handleAction(maxLeftWidth, 'spring');
            }
        }
    };
    /**
     * 渲染Action
     */
    const renderAction = ({ item, index, actionWidth }) => {
        return (<TouchableOpacity testID={`ActionTouchableOpacity${index}`} key={index} style={[
                styles.action,
                {
                    width: actionWidth,
                    backgroundColor: item.bgColor || 'rgba(0, 0, 0, 0)',
                },
            ]} onPress={() => {
                item.onClick && item.onClick();
                if (closeAfterClickedBtn) {
                    handleAction(0, 'timing');
                }
            }} activeOpacity={(customStyle === null || customStyle === void 0 ? void 0 : customStyle.actionActiveOpacity) || 0.5}>
                {item.render ? (item.render()) : (<Text numberOfLines={numberOfLines} ellipsizeMode={ellipsizeMode} style={[
                    styles.actionTxt,
                    item.textStyle || {},
                ]}>
                        {item.text || ''}
                    </Text>)}
            </TouchableOpacity>);
    };
    /**
     * 手势操作定义
     */
    const panResponder = useRef(PanResponder.create({
        // 要求成为响应者：
        onStartShouldSetPanResponder: handleMoveShouldSetPanResponderCapture,
        onStartShouldSetPanResponderCapture: handleMoveShouldSetPanResponderCapture,
        onMoveShouldSetPanResponder: handleMoveShouldSetPanResponderCapture,
        onMoveShouldSetPanResponderCapture: handleMoveShouldSetPanResponderCapture,
        onPanResponderGrant: handlePanResponderGrant,
        onPanResponderMove: handlePanResponderMove,
        onPanResponderEnd: handlePanResponderEnd,
        onPanResponderTerminationRequest: () => true,
        onShouldBlockNativeResponder: () => false,
    }));
    return (<View style={styles.slideContainer}>
            <View style={[styles.actionContainer]}>
                <Animated.View style={[
            styles.actions,
            {
                width: currentLeft.interpolate({
                    inputRange: [-maxRightWidth, 0, maxLeftWidth],
                    outputRange: [0, 0, maxLeftWidth],
                }),
            },
        ]}>
                    {leftActions.map((item, index) => {
            return renderAction({
                item,
                index,
                actionWidth: leftWidth
            });
        })}
                </Animated.View>
                <Animated.View style={[
            styles.actions,
            {
                width: currentLeft.interpolate({
                    inputRange: [-maxRightWidth, 0, maxLeftWidth],
                    outputRange: [maxRightWidth, 0, 0],
                }),
            },
        ]}>
                    {rightActions.map((item, index) => {
            return renderAction({
                item,
                index,
                actionWidth: rightWidth
            });
        })}
                </Animated.View>
            </View>
            <Animated.View testID='SlideOperationGesture' {...(_a = panResponder.current) === null || _a === void 0 ? void 0 : _a.panHandlers} style={[
            styles.item,
            {
                transform: [
                    {
                        translateX: currentLeft.interpolate({
                            inputRange: [-maxRightWidth, 0, maxLeftWidth],
                            outputRange: [-maxRightWidth, 0, maxLeftWidth],
                        }),
                    },
                ],
            },
        ]}>
                {children}
            </Animated.View>
        </View>);
};
export { SlideOperation };
export default React.memo(SlideOperation);
