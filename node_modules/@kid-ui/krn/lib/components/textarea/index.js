var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Text, TextInput, View, Platform } from 'react-native';
import useStyle from './styles';
import { mergeRefs } from '../../utils';
const isIOS = Platform.OS === 'ios';
const fixControlledValue = (value) => {
    if (typeof value === 'undefined' || value === null) {
        return '';
    }
    return value;
};
const Textarea = React.forwardRef((props, ref) => {
    const styles = useStyle(props);
    const { value, defaultValue, editable, disabled, style, rows, autoHeight, count, containerStyle, countStyle, countLeftStyle, countRightStyle, renderCount, extra } = props, rest = __rest(props, ["value", "defaultValue", "editable", "disabled", "style", "rows", "autoHeight", "count", "containerStyle", "countStyle", "countLeftStyle", "countRightStyle", "renderCount", "extra"]);
    const _editable = React.useMemo(() => !disabled && editable, [editable, disabled]);
    const [inputCount, setInputCount] = React.useState(fixControlledValue(value || defaultValue).length);
    const [height, setHeight] = React.useState(0);
    const inputRef = React.useRef();
    React.useImperativeHandle(ref, () => ({
        focus: () => {
            if (inputRef.current) {
                inputRef.current.focus();
            }
        },
        blur: () => {
            if (inputRef.current) {
                inputRef.current.blur();
            }
        },
        clear: () => {
            if (inputRef.current) {
                inputRef.current.clear();
            }
        },
        get nativeElement() {
            return inputRef.current;
        },
        get height() {
            return height;
        }
    }));
    const onChange = (event) => {
        const text = event.nativeEvent.text;
        const { onChange } = props;
        setInputCount(text.length);
        onChange && onChange(text);
    };
    const onContentSizeChange_fake = (event) => {
        if (isIOS) {
            const { height: _height } = event.nativeEvent.contentSize;
            setHeight(_height * (rows || 1));
        }
    };
    const onContentSizeChange = (event) => {
        const { autoHeight, onContentSizeChange } = props;
        if (autoHeight) {
            const { height: _height } = event.nativeEvent.contentSize;
            if (_height > height) {
                setHeight(event.nativeEvent.contentSize.height);
            }
        }
        onContentSizeChange && onContentSizeChange(event);
    };
    const onInitialLayout = (e) => {
        if (!isIOS) {
            const { height } = e.nativeEvent.layout;
            setHeight(height);
        }
    };
    const _renderCount = React.useCallback(() => {
        if (count) {
            if (renderCount) {
                return renderCount(inputCount, count);
            }
            else {
                return (<View style={[styles.count, countStyle]}>
            <Text style={[styles.countLeft, countLeftStyle]}>{inputCount}</Text>
            <Text style={[styles.countRight, countRightStyle]}>/{count}</Text>
          </View>);
            }
        }
        else {
            return null;
        }
    }, [
        count,
        inputCount,
        countStyle,
        countLeftStyle,
        countRightStyle,
        renderCount
    ]);
    return (<View style={[styles.container, containerStyle]}>
      <TextInput testID='FakeTextInput' onLayout={onInitialLayout} onContentSizeChange={onContentSizeChange_fake} style={[styles.input, style, { position: 'absolute', top: -999999 }]} multiline numberOfLines={rows || 1}/>
      <TextInput testID='KidTextInput' ref={mergeRefs([inputRef, ref])} editable={_editable} underlineColorAndroid="transparent" style={[styles.input, { height: height }, style]} {...rest} value={fixControlledValue(value)} onChange={onChange} onContentSizeChange={onContentSizeChange} multiline={rows > 1 || autoHeight} numberOfLines={rows} maxLength={count > 0 ? count : undefined}/>
      {_renderCount()}
      {extra ? extra : null}
    </View>);
});
Textarea.defaultProps = {
    onChange: () => { },
    editable: true,
    rows: 4,
    count: 0,
    keyboardType: 'default',
    autoHeight: false,
};
export default Textarea;
export { Textarea };
