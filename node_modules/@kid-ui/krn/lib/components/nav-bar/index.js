import React from 'react';
import { View, TouchableOpacity, Platform, Animated, } from 'react-native';
import { KidIcon } from '../icon';
import { KidButton } from '../button';
import useStyles from './styles';
import { ThemeContext } from '../../theme/context';
const noop = () => { };
// Animated.createAnimatedComponent要求必须是Class组件
class Icon extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        return (<KidIcon {...this.props}/>);
    }
}
const AnimatedKidIcon = Animated.createAnimatedComponent(Icon);
const NavBar = React.memo((props) => {
    var _a, _b;
    const { style, left, renderLeft, title, titleTextStyle, numberOfLines, ellipsizeMode, renderMiddle, right, renderRight, 
    // 渐变相关
    scrollY, isAnimatedGradient = false, maxScrollHeight, startBgc = '#FFF', endBgc = '#222226', startTextColor = '#222', endTextColor = '#E6E6E6', startIconTintColor = '#222', endIconTintColor = '#E6E6E6', } = props;
    const theme = React.useContext(ThemeContext);
    const styles = useStyles(props, { theme });
    const renderEndsItem = React.useCallback((item, isCapsule, isLastItem, key, index, type) => {
        // 文字
        const { text, iconKid, iconKidConfig, btn, activeOpacity = 1, wrapStyle, style, onPress = noop } = item;
        const textStyle = type == 'left' ? styles.leftTextStyle : styles.rightTextStyle;
        if (text) {
            return (<TouchableOpacity key={key} testID={`NavBar${type}Text${index}`} activeOpacity={activeOpacity} onPress={onPress} style={[wrapStyle]}>
          <Animated.Text style={[
                    textStyle,
                    isAnimatedGradient && scrollY ? {
                        color: scrollY.interpolate({
                            inputRange: [0, maxScrollHeight || 100],
                            outputRange: [startTextColor, endTextColor],
                            extrapolateLeft: 'clamp',
                            extrapolateRight: 'clamp',
                        })
                    } : null,
                    style
                ]}>
            {text}
          </Animated.Text>
        </TouchableOpacity>);
        }
        // 图标
        if ((Platform.OS !== 'web' && iconKid) || (Platform.OS === 'web' && iconKidConfig)) {
            return (<View key={key} style={{ flexDirection: 'row', alignItems: 'center' }}>
          <TouchableOpacity testID={`NavBar${type}Icon${index}`} hitSlop={{ top: 10, bottom: 10 }} activeOpacity={activeOpacity} style={[
                    styles.iconContainerStyle,
                    {
                        marginRight: isLastItem ? 0 : 2,
                        height: isCapsule ? 20 : 40,
                        width: isCapsule ? 20 : 40
                    },
                    wrapStyle
                ]} onPress={onPress}>
            <AnimatedKidIcon kid={iconKid} kidConfig={iconKidConfig} size={isCapsule ? 20 : 24} style={[
                    isAnimatedGradient && scrollY ? {
                        tintColor: scrollY.interpolate({
                            inputRange: [0, maxScrollHeight || 100],
                            outputRange: [startIconTintColor, endIconTintColor],
                            extrapolateLeft: 'clamp',
                            extrapolateRight: 'clamp',
                        })
                    } : null,
                    style
                ]}/>
          </TouchableOpacity>
          {isCapsule && !isLastItem && <View style={styles.capsuleLineStyle}/>}
        </View>);
        }
        // 按钮
        if (btn) {
            return (<View key={key} style={[styles.btnContainerStyle, wrapStyle]}>
          <KidButton kid='style_button_tiny_orange_bg' {...btn} activeOpacity={activeOpacity} onPress={onPress} style={style}/>
        </View>);
        }
    }, [isAnimatedGradient, scrollY]);
    const _renderMiddle = React.useCallback(() => {
        if (!title && !renderMiddle)
            return null;
        if (renderMiddle) {
            return (<View style={styles.middleContainerStyle}>
          {renderMiddle(scrollY)}
        </View>);
        }
        if (title) {
            return (<Animated.Text style={[
                    styles.titleTextStyle,
                    isAnimatedGradient && scrollY ? {
                        color: scrollY.interpolate({
                            inputRange: [0, maxScrollHeight || 100],
                            outputRange: [startTextColor, endTextColor],
                            extrapolateLeft: 'clamp',
                            extrapolateRight: 'clamp',
                        })
                    } : null,
                    titleTextStyle
                ]} numberOfLines={numberOfLines} ellipsizeMode={ellipsizeMode}>
          {title}
        </Animated.Text>);
        }
    }, [title, titleTextStyle, numberOfLines, ellipsizeMode, renderMiddle, scrollY]);
    return (<Animated.View style={[
            styles.containerStyle,
            isAnimatedGradient && scrollY ? {
                backgroundColor: scrollY.interpolate({
                    inputRange: [0, maxScrollHeight || 100],
                    outputRange: [startBgc, endBgc],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                })
            } : null,
            style
        ]}>
      {_renderMiddle()}
      {((left && ((_a = left.config) === null || _a === void 0 ? void 0 : _a.length)) || renderLeft) ? (<View style={[
                styles.leftContainerStyle,
                (left === null || left === void 0 ? void 0 : left.isCapsule) ? styles.capsuleStyle : null,
                left === null || left === void 0 ? void 0 : left.style
            ]}>
            {left && left.config && (left.config.slice(0, 2).map((item, index) => {
                var _a;
                const length = ((_a = left === null || left === void 0 ? void 0 : left.config) === null || _a === void 0 ? void 0 : _a.length) || 0;
                return renderEndsItem(item, (left === null || left === void 0 ? void 0 : left.isCapsule) || false, index === length - 1, `navbar_left_${index}`, index, 'left');
            }))}
            {renderLeft && renderLeft(scrollY)}
          </View>) : null}
      {((right && ((_b = right.config) === null || _b === void 0 ? void 0 : _b.length)) || renderRight) ? (<View style={[
                styles.rightContainerStyle,
                (right === null || right === void 0 ? void 0 : right.isCapsule) ? styles.capsuleStyle : null,
                right === null || right === void 0 ? void 0 : right.style
            ]}>
            {right && right.config && (right.config.slice(0, 2).map((item, index) => {
                var _a;
                const length = ((_a = right === null || right === void 0 ? void 0 : right.config) === null || _a === void 0 ? void 0 : _a.length) || 0;
                return renderEndsItem(item, (right === null || right === void 0 ? void 0 : right.isCapsule) || false, index === length - 1, `navbar_left_${index}`, index, 'right');
            }))}
            {renderRight && renderRight(scrollY)}
          </View>) : null}
    </Animated.View>);
});
export { NavBar };
export default NavBar;
