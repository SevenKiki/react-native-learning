// @ts-nocheck
import { View, StyleSheet, Platform } from 'react-native';
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Draggable } from './draggable';
import LinearGradient from 'react-native-linear-gradient';
export const Slider = function (props) {
    var _a, _b;
    const { start = 0, end = 100, value = 0, minValue, maxValue, onChange = (_e) => { }, step = 1, disabled = false, onDragEnd = (_e) => { }, onDragStart = (_e) => { }, ovalColor = '#fff', maximumTrackTintColor = 'rgba(255,255,255,0.25)', minimumTrackTintColor = '#fff', trackHeight = 4, ovalSize = 16, height = 32, tapToSeek = true, renderHandle = null, renderTrackContent = null, direction = 'x', style, borderRadius = 0, isMaximumTrackLinearGradient = false, maximumTrackLinearGradientConfig = {
        colors: ['white', 'black']
    }, isMinimumTrackLinearGradient = false, minimumTrackLinearGradientConfig = {
        colors: ['white', 'black']
    }, isShowCalibration = false, animated = false, calibrationStyle } = props;
    // 进度条可以滑动的范围: [_minValue, _maxValue];
    const _minValue = React.useMemo(() => Math.max(start, minValue === undefined ? start : minValue), [start, minValue]);
    const _maxValue = React.useMemo(() => Math.min(end, maxValue === undefined ? end : maxValue), [end, maxValue]);
    const [handleSize, setHandleSize] = useState({
        width: ovalSize,
        height: ovalSize,
    });
    const [contentStyle, setContentStyle] = useState({});
    const _onLayout = (e) => {
        var _a, _b;
        const { width, height } = e.nativeEvent.layout;
        if (direction === 'x') {
            setContentStyle({
                width,
                left: (_a = -width + handleSize.width) !== null && _a !== void 0 ? _a : ovalSize,
            });
        }
        else {
            setContentStyle({
                height,
                bottom: (_b = -height + handleSize.height) !== null && _b !== void 0 ? _b : ovalSize,
            });
        }
    };
    function percentToValue(val) {
        return Math.round((val * (end - start)) / _step) * _step;
    }
    const valueToPercent = useCallback((val) => val / (end - start), [end, start]);
    const [position, setposition] = useState(valueToPercent(value));
    const _setposition = (value, cb = false) => {
        if (value >= valueToPercent(_minValue) && value <= valueToPercent(_maxValue)) {
            setposition(value);
            if (cb) {
                const nowValue = percentToValue(value);
                onChange(nowValue);
            }
        }
    };
    const onValueChange = (percent) => {
        _setposition(percent, true);
    };
    useEffect(() => {
        _setposition(valueToPercent(value));
    }, [value, valueToPercent]);
    const onAfterChange = (percent) => {
        onDragEnd(percentToValue(percent));
        // 受控模式恢复组件值
        if (props.value) {
            _setposition(valueToPercent(props.value));
        }
    };
    const flexDirection = direction === 'x' ? 'row' : 'column';
    const isFirstLayout = useRef(true);
    // step
    const _step = React.useMemo(() => {
        return animated ? 1 : step;
    }, [step, animated]);
    // 刻度的个数
    const parts = React.useMemo(() => {
        if (!isShowCalibration && !animated) {
            return undefined;
        }
        if ((end - start) % step !== 0) {
            console.warn('step不能被end - start整除');
            return undefined;
        }
        return (end - start) / step + 1;
    }, [animated, end, start, step]);
    // 刻度
    const renderCalibration = React.useCallback((index, num) => {
        const isSelected = direction === 'x' ? index <= (num - 1) * position : index >= (num - 1) * (1 - position);
        return (<View style={[
                {
                    width: direction === 'x' ? 2 : 8,
                    height: direction === 'y' ? 2 : 8,
                    backgroundColor: isSelected ? minimumTrackTintColor : maximumTrackTintColor
                },
                calibrationStyle
            ]}/>);
    }, [minimumTrackTintColor, maximumTrackTintColor, position, direction, calibrationStyle]);
    // 进度条 下
    const maximumTrackStyle = [
        styles.rectangleL,
        {
            backgroundColor: maximumTrackTintColor,
            height: direction === 'x' ? trackHeight : '100%',
            width: direction === 'x' ? '100%' : trackHeight,
            borderRadius,
        },
    ];
    const renderMaximumTrack = () => {
        if (isMaximumTrackLinearGradient) {
            return (<LinearGradient {...maximumTrackLinearGradientConfig} style={maximumTrackStyle}/>);
        }
        else {
            return (<View style={maximumTrackStyle}/>);
        }
    };
    // 进度条 上
    const minimumTrackStyle = [
        styles.rectangleS,
        {
            backgroundColor: minimumTrackTintColor,
            height: direction === 'x'
                ? trackHeight
                : `${position * 100}%`,
            width: direction === 'x'
                ? `${position * 100}%`
                : trackHeight,
            left: direction === 'x' ? 0 : null,
            bottom: direction === 'x' ? null : 0,
            borderRadius,
            paddingRight: direction === 'x' ? handleSize.width / 2 : 0,
            paddingTop: direction === 'y' ? handleSize.height / 2 : 0,
        },
    ];
    const renderMinimumTrack = () => {
        if (isMinimumTrackLinearGradient) {
            return renderTrackContent ? (<View style={[maximumTrackStyle, { backgroundColor: 'transparent' }]}>
                    <LinearGradient {...minimumTrackLinearGradientConfig} style={minimumTrackStyle}/>
                    <View style={[maximumTrackStyle, { backgroundColor: 'transparent', position: 'absolute' }]}>
                        {renderTrackContent()}
                    </View>
                </View>) : (<LinearGradient {...minimumTrackLinearGradientConfig} style={minimumTrackStyle}/>);
        }
        else {
            return renderTrackContent ? (<View style={[maximumTrackStyle, { backgroundColor: 'transparent' }]}>
                    <View style={minimumTrackStyle}/>
                    {renderTrackContent && (<View style={[maximumTrackStyle, { backgroundColor: 'transparent', position: 'absolute' }]}>
                            {renderTrackContent()}
                        </View>)}
                </View>) : (<View style={minimumTrackStyle}/>);
        }
    };
    return (<View onLayout={_onLayout} style={[
            styles.rectangleWrap,
            {
                height: height,
                flexDirection,
                marginTop: direction === 'x' ? 0 : handleSize.height / 2,
                marginRight: direction === 'x' ? handleSize.width / 2 : 0,
                marginBottom: direction === 'x' ? 0 : handleSize.height / 2,
                marginLeft: direction === 'x' ? handleSize.width / 2 : 0,
            },
            style,
        ]}>
            {isShowCalibration && parts && (<View style={[
                maximumTrackStyle,
                {
                    flexDirection,
                    justifyContent: 'space-between',
                    backgroundColor: 'transparent',
                },
                direction === 'x' ? { height: ((_a = StyleSheet.flatten(calibrationStyle)) === null || _a === void 0 ? void 0 : _a.height) || 8 } : { width: ((_b = StyleSheet.flatten(calibrationStyle)) === null || _b === void 0 ? void 0 : _b.width) || 8 }
            ]}>
                    {Array(parts).fill(0).map((_, index) => (renderCalibration(index, parts)))}
                </View>)}
            {renderMaximumTrack()}
            {renderMinimumTrack()}
            <Draggable handleSize={handleSize} step={_step / (end - start)} parts={parts} disabled={disabled} min={valueToPercent(_minValue)} max={valueToPercent(_maxValue)} tapToSeek={tapToSeek} getCenterPosition={(touchInfo, wrapInfo) => {
            if (direction === 'x') {
                return {
                    x: (Platform.OS === 'web' ? touchInfo.locationX : touchInfo.x) - handleSize.width / 2,
                    y: null,
                };
            }
            else {
                return {
                    x: null,
                    y: (Platform.OS === 'web' ? touchInfo.locationY : touchInfo.y) -
                        wrapInfo.height -
                        handleSize.height / 2,
                };
            }
        }} {...{
        [direction === 'x' ? 'positionX' : 'positionY']: position,
    }} getMoveRange={(contentInfo, wrapInfo) => {
            if (direction === 'x') {
                return {
                    left: 0,
                    right: Math.abs(wrapInfo.width - handleSize.width || 0),
                    top: 0,
                    bottom: 0,
                };
            }
            else {
                return {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: Math.abs(wrapInfo.height - handleSize.height || 0),
                };
            }
        }} moveDirection={direction} onDragMove={(e) => {
            onValueChange(e[direction]);
        }} onDragStart={(e) => {
            // TODO:
            onDragStart(percentToValue(e[direction]));
        }} contentStyle={contentStyle} onDragEnd={(e) => {
            onAfterChange(e[direction]);
        }}>
                <View style={direction === 'x'
            ? styles.dragWrapperX
            : styles.dragWrapperY}>
                    <View onLayout={(e) => {
            if (isFirstLayout.current) {
                const _handleSize = {
                    width: e.nativeEvent.layout.width,
                    height: e.nativeEvent.layout.height,
                };
                setHandleSize(_handleSize);
                isFirstLayout.current = false;
            }
        }}>
                        {renderHandle ? (renderHandle()) : (<View style={[
                styles.oval,
                {
                    width: ovalSize,
                    height: ovalSize,
                    borderRadius: ovalSize / 2,
                    backgroundColor: ovalColor,
                },
            ]}/>)}
                    </View>
                </View>
            </Draggable>
        </View>);
};
const styles = StyleSheet.create({
    rectangleWrap: {
        justifyContent: 'center',
        alignItems: 'center',
    },
    rectangleL: {
        width: '100%',
        position: 'absolute',
    },
    dragWrapperX: {
        width: '100%',
        height: '100%',
        justifyContent: 'flex-end',
        alignItems: 'center',
        flexDirection: 'row',
    },
    dragWrapperY: {
        width: '100%',
        height: '100%',
        flexDirection: 'column-reverse',
        justifyContent: 'flex-end',
        alignItems: 'center',
    },
    rectangleS: {
        position: 'absolute',
    },
    oval: {
        right: 0,
    },
});
