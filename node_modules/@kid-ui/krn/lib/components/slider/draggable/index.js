var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// @ts-nocheck
import React, { useRef, useEffect, useMemo, useState, useContext } from 'react';
import { Animated, StyleSheet, NativeModules } from 'react-native';
import RootTagContext from 'react-native/Libraries/ReactNative/RootTagContext.js';
import { PanGestureHandler, State, GestureHandlerRootView } from 'react-native-gesture-handler';
const stepFn = (step, num) => Math.round(num / step) * step;
const interpolate = (value, max, min = 0, step) => {
    let val;
    if (!min) {
        min = 0;
    }
    if (value < min) {
        val = 0;
    }
    else if (value > max) {
        val = 1;
    }
    else {
        val = stepFn(step, value / (max - min));
    }
    return val;
};
export const Draggable = (props) => {
    const { disabled = false, min, max, children, step, style, moveDirection = 'both', positionX, positionY, getMoveRange, handleSize, contentStyle, parts = undefined, } = props;
    const rootTag = useContext(RootTagContext);
    let slideBackStatus;
    const content = useRef(props);
    content.current = props;
    const drag = useRef(false);
    const pan = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const wrapSize = useRef(null);
    const contentSize = useRef(null);
    const [moveRange, setMoveRange] = useState(null);
    const wrapRef = useRef(null);
    // 吸附效果打开时，需要分段
    const percents = React.useMemo(() => {
        if (parts !== undefined) {
            return Array(parts).fill(1).map((_, index) => index * (1 / (parts - 1)));
        }
        return [];
    }, [parts]);
    const onLayout = (e) => {
        // wrapSize.current = e.nativeEvent.layout;
        const { width, height } = e.nativeEvent.layout;
        // 因为用e.nativeEvent
        wrapSize.current = { left: 0, top: 0, width, height };
        if (contentSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    const onContentLayout = (e) => {
        contentSize.current = e.nativeEvent.layout;
        if (wrapSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (moveRange.right - moveRange.left) * positionX,
                y: pan.y._value,
            });
        }
    }, [positionX, pan, moveRange]);
    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: pan.x._value,
                y: -(moveRange.bottom - moveRange.top) * positionY,
            });
        }
    }, [positionY, pan, moveRange]);
    useEffect(() => {
        const animationId = pan.addListener(() => {
            const position = getNowPosition.current();
            content.current.onDragMove(position);
        });
        return () => {
            pan.removeListener(animationId);
        };
    }, []);
    // PanResponder中要用，直接写函数是闭包
    const getNowPosition = useRef(null);
    getNowPosition.current = () => {
        if (!moveRange) {
            return {
                x: 0,
                y: 0,
            };
        }
        return {
            x: interpolate(pan.x.__getValue(), moveRange.right - moveRange.left, 0, content.current.step),
            y: interpolate(-pan.y.__getValue(), moveRange.bottom - moveRange.top, 0, content.current.step),
        };
    };
    const pans = {};
    if (moveDirection === 'both' || moveDirection === 'x') {
        pans.dx = pan.x;
    }
    if (moveDirection === 'both' || moveDirection === 'y') {
        pans.dy = pan.y;
    }
    // 补偿逻辑
    useEffect(() => {
        if ((moveDirection === 'x' || moveDirection === 'both') && parts !== undefined && !drag.current) {
            if (!percents.includes(positionX)) {
                autoTo(positionX);
            }
        }
    }, [positionX, moveDirection]);
    useEffect(() => {
        if ((moveDirection === 'y' || moveDirection === 'both') && parts !== undefined && !drag.current) {
            if (!percents.includes(positionY)) {
                autoTo(positionY);
            }
        }
    }, [positionY, moveDirection]);
    const autoTo = (percent) => {
        if (!moveRange)
            return;
        const { right, left, top, bottom } = moveRange;
        let direction = undefined;
        percents.forEach((_, idx) => {
            if (percent > percents[idx] && percent < percents[idx + 1]) {
                const middle = (percents[idx] + percents[idx + 1]) / 2;
                if (percent < middle) {
                    direction = (moveDirection === 'x' ? (right - left) : -(top + bottom)) * percents[idx];
                }
                else {
                    direction = (moveDirection === 'x' ? (right - left) : -(top + bottom)) * percents[idx + 1];
                }
                return;
            }
        });
        if (direction !== undefined) {
            pan.setOffset({ x: 0, y: 0 });
            pan.setValue({
                x: moveDirection === 'x' ? direction : 0,
                y: moveDirection === 'y' ? direction : 0,
            });
        }
    };
    const _onGestureEvent = Animated.event([
        {
            nativeEvent: {
                translationX: pan.x,
                translationY: pan.y,
            },
        },
    ], {
        useNativeDriver: false
    });
    const _onHandlerStateChange = ({ nativeEvent }) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (nativeEvent.state === State.BEGAN) {
            drag.current = true;
            if (!content.current.tapToSeek) {
                pan.setOffset({
                    x: pan.x._value,
                    y: pan.y._value,
                });
                pan.setValue({ x: 0, y: 0 });
            }
            else {
                const centerPosition = content.current.getCenterPosition(nativeEvent, wrapSize.current);
                pan.setOffset({
                    x: (_a = centerPosition.x) !== null && _a !== void 0 ? _a : pan.x._value,
                    y: (_b = centerPosition.y) !== null && _b !== void 0 ? _b : pan.y._value,
                });
            }
            content.current.onDragStart(getNowPosition.current());
            if (content.current.tapToSeek) {
                pan.setValue({ x: 0, y: 0 });
                content.current.onDragMove(getNowPosition.current());
            }
            try {
                // drag 开始时获取滑动返回状态,并禁用滑动返回
                slideBackStatus = yield ((_d = (_c = NativeModules.KRNBasic) === null || _c === void 0 ? void 0 : _c.getSlideBack) === null || _d === void 0 ? void 0 : _d.call(_c, rootTag));
                (_f = (_e = NativeModules.KRNBasic) === null || _e === void 0 ? void 0 : _e.setSlideBack) === null || _f === void 0 ? void 0 : _f.call(_e, {
                    enabled: false,
                    rootTag: rootTag,
                });
            }
            catch (error) { }
        }
        if (nativeEvent.state === State.END || nativeEvent.state === State.FAILED || nativeEvent.state === State.CANCELLED) {
            // 当slider设置了animated为true时，吸附效果
            if (parts !== undefined) {
                const { x, y } = getNowPosition.current();
                const percent = moveDirection === 'x' ? x : y;
                autoTo(percent);
            }
            pan.flattenOffset(); // 将pan中的offset合并到base值（(pan.x as any)._value），将offset重置为0，pan最终的输出值（base+offset）不变.
            if (pan.x._value > wrapSize.current.width) {
                pan.x.setValue(wrapSize.current.width);
            }
            else if (pan.x._value < 0) {
                pan.x.setValue(0);
            }
            if (pan.y._value < -wrapSize.current.height) {
                pan.y.setValue(-wrapSize.current.height);
            }
            else if (pan.y._value > 0) {
                pan.y.setValue(0);
            }
            drag.current = false; // 内部控制状态，拖动结束时才接收外部传入的状态
            content.current.onDragEnd(getNowPosition.current());
            try {
                // 拖动结束时，把 SlideBackStatus 还原
                (_h = (_g = NativeModules.KRNBasic) === null || _g === void 0 ? void 0 : _g.setSlideBack) === null || _h === void 0 ? void 0 : _h.call(_g, {
                    enabled: slideBackStatus,
                    rootTag: rootTag,
                });
            }
            catch (error) { }
        }
    });
    const transform = useMemo(() => {
        if (!wrapSize.current || !contentSize.current || !moveRange) {
            return [];
        }
        const { top, bottom, right, left } = moveRange;
        const result = [];
        if (moveDirection === 'both' || moveDirection === 'x') {
            result.push({
                translateX: pan.x.interpolate({
                    inputRange: [(right - left) * min, (right - left) * max],
                    outputRange: [
                        (right - left) * min - handleSize.width / 2,
                        (right - left) * max + handleSize.width / 2
                    ],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        if (moveDirection === 'both' || moveDirection === 'y') {
            result.push({
                translateY: pan.y.interpolate({
                    inputRange: [-(top + bottom) * max, (top + bottom) * min,],
                    outputRange: [
                        -(top + bottom) * max - handleSize.height / 2,
                        (top + bottom) * min + handleSize.height / 2
                    ],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step)
                }),
            });
        }
        return result;
    }, [moveDirection, pan, step, moveRange]);
    return (<GestureHandlerRootView onLayout={onLayout} ref={wrapRef} style={[styles.wrap, style]}>
            <PanGestureHandler enabled={!disabled} onGestureEvent={_onGestureEvent} onHandlerStateChange={_onHandlerStateChange} activeOffsetX={moveDirection === 'x' ? [-10, 10] : undefined} failOffsetY={moveDirection === 'x' ? [-10, 10] : undefined} activeOffsetY={moveDirection === 'y' ? [-10, 10] : undefined} failOffsetX={moveDirection === 'y' ? [-10, 10] : undefined}>
                <Animated.View style={[styles.dragAble]}>
                    <Animated.View onLayout={onContentLayout} style={[
            {
                transform
            },
            contentStyle,
        ]}>
                        {children}
                    </Animated.View>
                </Animated.View>
            </PanGestureHandler>
        </GestureHandlerRootView>);
};
const styles = StyleSheet.create({
    wrap: {
        height: '100%',
        width: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    dragAble: {
        position: 'absolute',
        zIndex: 2,
        height: '100%',
        width: '100%',
    },
});
