var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// @ts-nocheck
import React, { useRef, useEffect, useMemo, useState } from 'react';
import { Animated, View, PanResponder, StyleSheet, } from 'react-native';
const stepFn = (step, num) => Math.round(num / step) * step;
const interpolate = (value, max, min = 0, step) => {
    let val;
    if (!min) {
        min = 0;
    }
    if (value < min) {
        val = 0;
    }
    else if (value > max) {
        val = 1;
    }
    else {
        val = stepFn(step, value / (max - min));
    }
    return val;
};
export const Draggable = (props) => {
    const { disabled = false, min, max, children, step, style, moveDirection = 'both', positionX, positionY, getMoveRange, contentStyle, } = props;
    const content = useRef(props);
    content.current = props;
    const drag = useRef(false);
    const pan = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const wrapSize = useRef(null);
    const contentSize = useRef(null);
    const [moveRange, setMoveRange] = useState(null);
    const wrapRef = useRef(null);
    const onLayout = (e) => {
        // wrapSize.current = e.nativeEvent.layout;
        const { width, height } = e.nativeEvent.layout;
        // 因为用e.nativeEvent
        wrapSize.current = { left: 0, top: 0, width, height };
        if (contentSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    const onContentLayout = (e) => {
        contentSize.current = e.nativeEvent.layout;
        if (wrapSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (moveRange.right - moveRange.left) * positionX,
                y: pan.y._value,
            });
        }
    }, [positionX, pan, moveRange]);
    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: pan.x._value,
                y: -(moveRange.bottom - moveRange.top) * positionY,
            });
        }
    }, [positionY, pan, moveRange]);
    // PanResponder中要用，直接写函数是闭包
    const getNowPosition = useRef(null);
    getNowPosition.current = () => {
        if (!moveRange) {
            return {
                x: 0,
                y: 0,
            };
        }
        return {
            x: interpolate(pan.x.__getValue(), moveRange.right - moveRange.left, 0, content.current.step),
            y: interpolate(-pan.y.__getValue(), moveRange.bottom - moveRange.top, 0, content.current.step),
        };
    };
    const pans = {};
    if (moveDirection === 'both' || moveDirection === 'x') {
        pans.dx = pan.x;
    }
    if (moveDirection === 'both' || moveDirection === 'y') {
        pans.dy = pan.y;
    }
    // 手势控制对象，与animateValue配合，实时更新当前translate的距离
    const panResponder = useMemo(() => {
        return PanResponder.create({
            onStartShouldSetPanResponder: () => !disabled,
            onMoveShouldSetPanResponder: () => !disabled,
            onPanResponderGrant: (e) => __awaiter(void 0, void 0, void 0, function* () {
                var _a, _b;
                drag.current = true;
                if (!content.current.tapToSeek) {
                    pan.setOffset({
                        x: pan.x._value,
                        y: pan.y._value,
                    });
                }
                else {
                    const centerPosition = content.current.getCenterPosition(e.nativeEvent, wrapSize.current);
                    pan.setOffset({
                        x: (_a = centerPosition.x) !== null && _a !== void 0 ? _a : pan.x._value,
                        y: (_b = centerPosition.y) !== null && _b !== void 0 ? _b : pan.y._value,
                    });
                }
                content.current.onDragStart(getNowPosition.current());
                if (content.current.tapToSeek) {
                    pan.setValue({ x: 0, y: 0 });
                    content.current.onDragMove(getNowPosition.current());
                }
            }),
            onPanResponderMove: Animated.event([null, pans], {
                useNativeDriver: false,
                listener: () => {
                    content.current.onDragMove(getNowPosition.current());
                },
            }),
            onPanResponderRelease: () => {
                pan.flattenOffset(); // 将pan中的offset合并到base值（(pan.x as any)._value），将offset重置为0，pan最终的输出值（base+offset）不变.
                if (pan.x._value > wrapSize.current.width) {
                    pan.x.setValue(wrapSize.current.width);
                }
                else if (pan.x._value < 0) {
                    pan.x.setValue(0);
                }
                if (pan.y._value < -wrapSize.current.height) {
                    pan.y.setValue(-wrapSize.current.height);
                }
                else if (pan.y._value > 0) {
                    pan.y.setValue(0);
                }
                drag.current = false; // 内部控制状态，拖动结束时才接收外部传入的状态
                content.current.onDragEnd(getNowPosition.current());
            },
            onPanResponderTerminationRequest: () => false,
        });
    }, [
        disabled,
        pan
    ]);
    const transform = useMemo(() => {
        if (!wrapSize.current || !contentSize.current) {
            return [];
        }
        const { top, bottom, right, left } = moveRange;
        const result = [];
        if (moveDirection === 'both' || moveDirection === 'x') {
            result.push({
                translateX: pan.x.interpolate({
                    inputRange: [(right - left) * min, (right - left) * max],
                    outputRange: [(right - left) * min, (right - left) * max],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        if (moveDirection === 'both' || moveDirection === 'y') {
            result.push({
                translateY: pan.y.interpolate({
                    inputRange: [-(top + bottom) * max, (top + bottom) * min],
                    outputRange: [-(top + bottom) * max, (top + bottom) * min],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        return result;
    }, [moveDirection, pan, step, moveRange]);
    return (<View onLayout={onLayout} ref={wrapRef} style={[styles.wrap, style]}>
            <Animated.View onLayout={onContentLayout} style={[
            {
                transform,
            },
            contentStyle,
        ]}>
                {children}
            </Animated.View>
            <View style={[styles.dragAble]} {...panResponder.panHandlers}/>
        </View>);
};
const styles = StyleSheet.create({
    wrap: {
        height: '100%',
        width: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    dragAble: {
        position: 'absolute',
        zIndex: 2,
        height: '100%',
        width: '100%',
    },
});
