import * as React from 'react';
import { Animated, StyleSheet, View, UIManager, } from 'react-native';
import TabBarItem from './TabBarItem';
import TabBarIndicator from './TabBarIndicator';
import debounce from 'lodash.debounce';
import { throttle } from '../../utils';
export default class TabBar extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            opacity: 0,
            tabWidth: 0,
            tabWidths: {},
            itemWidth: undefined,
            showIndicator: false,
        };
        this.layout = null;
        this.contentLayout = null;
        this.centerPointArr = [];
        this.debounceJump = debounce((path) => {
            this.props.jumpTo(path);
        }, this.props.controlDuration);
        this.throttleJump = throttle((path) => {
            this.props.jumpTo(path);
        }, this.props.controlDuration);
        this.jump = (path) => {
            if (this.props.controlType === 'debounce') {
                this.debounceJump(path);
            }
            else if (this.props.controlType === 'throttle') {
                this.throttleJump(path);
            }
            else {
                this.props.jumpTo(path);
            }
        };
        // to store the layout.width of each tab
        // when all onLayout's are fired, this would be set in state
        this.measuredTabWidths = {};
        this.measuredTabsPos = [];
        this.tabBarScrollTime = null;
        this.itemLayoutTime = null;
        this.scrollX = 0;
        this.scrollAmount = new Animated.Value(0);
        this.scrollViewRef = React.createRef();
        this.getScrollAmount = (index) => {
            if (!this.layout || !this.contentLayout) {
                return;
            }
            if (this.layout.width >= this.contentLayout.width) {
                return;
            }
            if (!this.centerPointArr.length) {
                return;
            }
            const indexInt = index | 0;
            const percent = index - indexInt;
            let centerPosition = this.centerPointArr[indexInt];
            if (this.centerPointArr[indexInt + 1] && percent) {
                centerPosition +=
                    percent * (this.centerPointArr[indexInt + 1] - centerPosition);
            }
            const halfWidth = this.layout.width / 2;
            if (centerPosition < halfWidth) {
                return 0;
            }
            else if (this.contentLayout.width - centerPosition < halfWidth) {
                return this.contentLayout.width - this.layout.width;
            }
            else {
                return centerPosition - halfWidth;
            }
        };
        this.resetScroll = (index) => {
            var _a;
            if (this.props.scrollEnabled) {
                (_a = this.scrollViewRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo({
                    x: this.getScrollAmount(index),
                    animated: !this.props.openPageAnimate, // 关闭 openPageAnimate 时，需要开启动画，否则 tabBar Indiacator 会闪烁
                });
            }
        };
        this.handleLayout = (e) => {
            var _a;
            const { height, width } = e.nativeEvent.layout;
            // ios有时width为0
            if (width) {
                this.layout = { height, width };
                this.checkReady();
            }
            else {
                // @ts-expect-error
                UIManager.measure((_a = e.nativeEvent) === null || _a === void 0 ? void 0 : _a.target, (x, y, width, height) => {
                    this.layout = { height, width };
                    this.checkReady();
                });
            }
        };
        this.onContentSizeChange = (width, height) => {
            this.contentLayout = { height, width };
            this.checkReady();
        };
        this.debounceJump = this.debounceJump.bind(this);
        this.throttleJump = this.throttleJump.bind(this);
        this.jump = this.jump.bind(this);
        this.onMomentumScrollBegin = this.onMomentumScrollBegin.bind(this);
        this.onTabBarScroll = this.onTabBarScroll.bind(this);
        this.handleMeasuredTabsPos = this.handleMeasuredTabsPos.bind(this);
        this.getInScenceRoutes = this.getInScenceRoutes.bind(this);
    }
    componentDidUpdate(prevProps, preState) {
        const { navigationState, controlType } = this.props;
        if (prevProps.navigationState.routes.length !==
            navigationState.routes.length ||
            prevProps.navigationState.index !== navigationState.index) {
            this.resetScroll(navigationState.index);
        }
    }
    onItemLayout(e, route, index) {
        var _a, _b;
        const width = e.nativeEvent.layout.width;
        let start = 0, end = width;
        if (index > 0 && ((_a = this.measuredTabsPos[index - 1]) === null || _a === void 0 ? void 0 : _a.start) && ((_b = this.measuredTabsPos[index - 1]) === null || _b === void 0 ? void 0 : _b.end)) {
            start = this.measuredTabsPos[index - 1].end;
            end = start + width;
        }
        this.measuredTabsPos[index] = { start, end };
        clearTimeout(this.itemLayoutTime);
        this.itemLayoutTime = null;
        this.itemLayoutTime = setTimeout(() => {
            var _a;
            if (this.measuredTabsPos.every(pos => pos.start === 0)) {
                const { onTabBarItemsLayoutChange } = this.props;
                this.handleMeasuredTabsPos();
                const inScenceRoute = [];
                this.getInScenceRoutes(inScenceRoute, this.scrollX, (_a = this.layout) === null || _a === void 0 ? void 0 : _a.width);
                onTabBarItemsLayoutChange && onTabBarItemsLayoutChange(inScenceRoute);
            }
        }, 100);
        // 如果固定高度，不需要用事件的高度
        if (this.state.itemWidth) {
            return;
        }
        this.measuredTabWidths[route.key] = width;
        if (!this.state.showIndicator) {
            this.checkReady();
        }
    }
    onMomentumScrollBegin() {
        clearTimeout(this.tabBarScrollTime);
        this.tabBarScrollTime = null;
    }
    handleMeasuredTabsPos() {
        const _measuredTabsPos = [];
        this.measuredTabsPos.forEach((pos, index) => {
            if (index) {
                let { start, end } = pos;
                const { start: _start, end: _end } = _measuredTabsPos[index - 1];
                start = _end;
                end = _end + end;
                _measuredTabsPos.push({ start, end });
            }
            else {
                _measuredTabsPos.push(pos);
            }
        });
        this.measuredTabsPos = _measuredTabsPos;
    }
    getInScenceRoutes(inScenceRoute, x, width) {
        const { shownPercent = 0.5 } = this.props;
        const percent = Math.min(1, Math.max(0, shownPercent));
        let idx = -1;
        this.measuredTabsPos.forEach((pos, index) => {
            if (pos.end > x && pos.start < x + width) {
                if (idx < 0) {
                    if ((pos.end - x) / (pos.end - pos.start) >= percent) {
                        inScenceRoute.push(this.props.navigationState.routes[index]);
                    }
                }
                else {
                    inScenceRoute.push(this.props.navigationState.routes[index]);
                }
                idx = index;
            }
        });
        if (this.measuredTabsPos[idx]) {
            const { start, end } = this.measuredTabsPos[idx];
            if ((x + width - start) / (end - start) < percent) {
                inScenceRoute.pop();
            }
        }
    }
    onTabBarScroll(e) {
        const { onTabBarItemsLayoutChange } = this.props;
        const { width } = e.nativeEvent.layoutMeasurement;
        const { x } = e.nativeEvent.contentOffset;
        const inScenceRoute = [];
        this.getInScenceRoutes(inScenceRoute, x, width);
        this.tabBarScrollTime = setTimeout(() => {
            onTabBarItemsLayoutChange && onTabBarItemsLayoutChange(inScenceRoute);
        }, 50);
    }
    componentDidMount() {
        // @ts-expect-error
        this.props.position.addListener(({ value }) => {
            this.resetScroll(value);
        });
    }
    componentWillUnmount() {
        clearTimeout(this.tabBarScrollTime);
        this.tabBarScrollTime = null;
        clearTimeout(this.itemLayoutTime);
        this.itemLayoutTime = null;
    }
    checkReady() {
        if (!this.contentLayout || !this.layout) {
            return;
        }
        const { navigationState: { routes }, } = this.props;
        if (this.props.autoCenter) {
            if (this.layout.width > this.contentLayout.width) {
                this.contentLayout = null;
                const itemWidth = this.layout.width / routes.length;
                this.setState({
                    itemWidth,
                }, () => {
                    this.checkReady();
                });
                return;
            }
        }
        if (!this.state.itemWidth &&
            routes.some((route) => {
                return !this.measuredTabWidths[route.key];
            })) {
            return;
        }
        if (this.state.itemWidth) {
            const measuredTabWidths = {};
            routes.forEach((route) => {
                measuredTabWidths[route.key] = this.state.itemWidth;
            });
            this.measuredTabWidths = measuredTabWidths;
        }
        this.setState({
            opacity: 1,
            showIndicator: true,
            tabWidth: this.layout.width,
            tabWidths: this.measuredTabWidths,
        }, () => {
            // @ts-expect-error
            this.resetScroll(this.props.position.__getValue());
        });
        let sumHeight = 0;
        const paddingSize = 14;
        const measuredTabWidths = this.measuredTabWidths;
        this.centerPointArr = routes.reduce((acc, _, i) => {
            const lastSum = sumHeight;
            sumHeight += measuredTabWidths[_.key];
            let widthFix = 0;
            if (i === 0) {
                widthFix = -paddingSize;
            }
            else if (i === routes.length - 1) {
                widthFix = paddingSize;
            }
            return [
                ...acc,
                lastSum + (measuredTabWidths[_.key] + widthFix) / 2,
            ];
        }, []);
    }
    render() {
        const { position, navigationState, jumpTo, scrollEnabled, bounces, getAccessibilityLabel, getAccessible, dividerColor, getLabelText, getTestID, 
        // 控制分割线是否展示
        renderBadge = () => (<View style={{ width: 1, height: '50%', backgroundColor: dividerColor }}></View>), renderIcon, openPageAnimate, renderLabel, renderTabBarItem, activeColor, inactiveColor, pressColor, pressOpacity, onTabPress, onTabLongPress, tabItemStyle, labelStyle, indicatorStyle, indicatorWidth, enableIndicatorAnimate, showBottomShadow, tabItemTextStyle, tabItemActiveTextStyle, tabItemActiveStyleMode, tabItemActiveStyle, lastTabItemStyle, firstTabItemStyle, 
        // contentContainerStyle,
        tabBarContainerStyle, tabBarScrollViewStyle, tabBarScrollViewContentStyle, style, } = this.props;
        const { tabWidths, tabWidth, showIndicator, itemWidth, opacity } = this.state;
        const { routes } = navigationState;
        let tabWidthsReady = true;
        routes.forEach(item => {
            if (!tabWidths[item.key]) {
                tabWidthsReady = false;
            }
        });
        return (<View style={[styles.tabBar, showBottomShadow ? styles.tabShadow : {}, { opacity }, style, tabBarContainerStyle]}>
                <Animated.ScrollView 
        //@ts-expect-error
        style={tabBarScrollViewStyle} onLayout={this.handleLayout} onContentSizeChange={this.onContentSizeChange} horizontal accessibilityRole="tablist" keyboardShouldPersistTaps="handled" scrollEnabled={scrollEnabled} bounces={bounces} alwaysBounceHorizontal={false} scrollsToTop={false} showsHorizontalScrollIndicator={false} automaticallyAdjustContentInsets={false} overScrollMode="never" contentContainerStyle={[styles.tabContent, tabBarScrollViewContentStyle]} scrollEventThrottle={16} onScroll={Animated.event([
                {
                    nativeEvent: {
                        contentOffset: { x: this.scrollAmount },
                    },
                },
            ], {
                useNativeDriver: true,
                listener: (e) => {
                    if (!this.scrollX) {
                        this.scrollX = e.nativeEvent.contentOffset.x;
                    }
                }
            })} onScrollEndDrag={this.onTabBarScroll} onMomentumScrollBegin={this.onMomentumScrollBegin} onMomentumScrollEnd={this.onTabBarScroll} ref={this.scrollViewRef}>
                    <View pointerEvents="none" style={styles.indicator}>
                        {showIndicator && tabWidthsReady &&
                this.props.renderIndicator({
                    position,
                    // @ts-expect-error
                    layout: null,
                    // fixPadding: !itemWidth,
                    navigationState,
                    jumpTo,
                    tabWidths,
                    tabWidth,
                    style: indicatorStyle,
                    indicatorWidth: indicatorWidth,
                    enableIndicatorAnimate: enableIndicatorAnimate
                })}
                    </View>
                    {routes.map((route, index) => {
                const isLastItem = index === (routes.length - 1);
                const isFirstItem = index === 0;
                const props = {
                    isLastItem,
                    isFirstItem,
                    key: route.key,
                    position,
                    route: route,
                    itemWidth,
                    navigationState: navigationState,
                    getAccessibilityLabel: getAccessibilityLabel,
                    getAccessible: getAccessible,
                    getLabelText: getLabelText,
                    getTestID: getTestID,
                    renderBadge: renderBadge,
                    renderIcon: renderIcon,
                    openPageAnimate: openPageAnimate,
                    onLayout: (e) => this.onItemLayout(e, route, index),
                    renderLabel: renderLabel,
                    activeColor: activeColor,
                    inactiveColor: inactiveColor,
                    pressColor: pressColor,
                    pressOpacity: pressOpacity,
                    onPress: () => {
                        const event = {
                            route,
                            defaultPrevented: false,
                            preventDefault: () => {
                                event.defaultPrevented = true;
                            },
                        };
                        onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);
                        if (event.defaultPrevented) {
                            return;
                        }
                        this.jump(route.key);
                    },
                    onLongPress: () => onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({ route }),
                    labelStyle: labelStyle,
                    style: tabItemStyle,
                    tabItemActiveStyle: tabItemActiveStyle,
                    lastTabItemStyle: lastTabItemStyle,
                    firstTabItemStyle: firstTabItemStyle,
                    tabItemTextStyle: tabItemTextStyle,
                    tabItemActiveTextStyle: tabItemActiveTextStyle,
                    tabItemActiveStyleMode,
                };
                return renderTabBarItem ? (renderTabBarItem(props)) : (<TabBarItem {...props}/>);
            })}
                </Animated.ScrollView>
            </View>);
    }
}
TabBar.defaultProps = {
    autoCenter: true,
    getLabelText: ({ route }) => route.title,
    getAccessible: ({ route }) => typeof route.accessible !== 'undefined' ? route.accessible : true,
    getAccessibilityLabel: ({ route }) => typeof route.accessibilityLabel === 'string'
        ? route.accessibilityLabel
        : typeof route.title === 'string'
            ? route.title
            : undefined,
    getTestID: ({ route }) => route.testID,
    renderIndicator: (props) => (<TabBarIndicator {...props}/>),
    controlType: 'normal',
    controlDuration: 0
};
const styles = StyleSheet.create({
    tabBar: {
        backgroundColor: '#0b0b0b',
        zIndex: 1,
        flexGrow: 0,
    },
    tabShadow: {
        elevation: 4,
        shadowColor: 'black',
        shadowOpacity: 0.1,
        shadowRadius: StyleSheet.hairlineWidth,
        shadowOffset: {
            height: StyleSheet.hairlineWidth,
            width: 0,
        },
    },
    tabContent: {
        flexDirection: 'row',
        flexWrap: 'nowrap',
    },
    indicator: {
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        top: 0,
    },
});
