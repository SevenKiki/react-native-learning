import * as React from 'react';
import { Animated, StyleSheet, View, TouchableWithoutFeedback, } from 'react-native';
const DEFAULT_ACTIVE_COLOR = 'rgba(255, 255, 255, 1)';
const DEFAULT_INACTIVE_COLOR = 'rgba(255, 255, 255, 0.4)';
export default class TabBarItem extends React.Component {
    constructor() {
        super(...arguments);
        this.getActiveOpacity = (position, routes, tabIndex) => {
            if (routes.length > 1) {
                const inputRange = routes.map((_, i) => i);
                return position.interpolate({
                    inputRange,
                    outputRange: inputRange.map((i) => (i === tabIndex ? 1 : 0)),
                });
            }
            else {
                return 1;
            }
        };
        this.getInactiveOpacity = (position, routes, tabIndex) => {
            if (routes.length > 1) {
                const inputRange = routes.map((_, i) => i);
                return position.interpolate({
                    inputRange,
                    outputRange: inputRange.map((i) => i === tabIndex ? 0 : 1),
                });
            }
            else {
                return 0;
            }
        };
    }
    render() {
        const { isLastItem, isFirstItem, route, position, navigationState, renderLabel: renderLabelCustom, renderIcon, renderBadge, getLabelText, getAccessibilityLabel, getAccessible, activeColor: activeColorCustom, inactiveColor: inactiveColorCustom, labelStyle, itemWidth, style, onLayout, onPress, onLongPress, tabItemTextStyle, tabItemActiveTextStyle, tabItemActiveStyleMode, tabItemActiveStyle, lastTabItemStyle, firstTabItemStyle, openPageAnimate } = this.props;
        const tabIndex = navigationState.routes.indexOf(route);
        const isFocused = navigationState.index === tabIndex;
        const labelColorFromStyle = StyleSheet.flatten(labelStyle || {}).color;
        const activeColor = activeColorCustom !== undefined
            ? activeColorCustom
            : typeof labelColorFromStyle === 'string'
                ? labelColorFromStyle
                : DEFAULT_ACTIVE_COLOR;
        const inactiveColor = inactiveColorCustom !== undefined
            ? inactiveColorCustom
            : typeof labelColorFromStyle === 'string'
                ? labelColorFromStyle
                : DEFAULT_INACTIVE_COLOR;
        const activeOpacity = this.getActiveOpacity(position, navigationState.routes, tabIndex);
        const inactiveOpacity = this.getInactiveOpacity(position, navigationState.routes, tabIndex);
        let icon = null;
        let label = null;
        if (renderIcon) {
            const activeIcon = renderIcon({
                route,
                focused: true,
                color: activeColor,
            });
            const inactiveIcon = renderIcon({
                route,
                focused: false,
                color: inactiveColor,
            });
            if (inactiveIcon != null && activeIcon != null) {
                icon = (<View style={styles.icon}>
                        <Animated.View style={{ opacity: inactiveOpacity }}>
                            {inactiveIcon}
                        </Animated.View>
                        <Animated.View style={[
                        StyleSheet.absoluteFill,
                        { opacity: activeOpacity },
                    ]}>
                            {activeIcon}
                        </Animated.View>
                    </View>);
            }
        }
        const renderLabel = renderLabelCustom !== undefined
            ? renderLabelCustom
            : ({ route, color, focused }) => {
                const labelText = getLabelText({ route });
                if (typeof labelText === 'string') {
                    return (<Animated.Text numberOfLines={1} style={[
                            styles.label,
                            icon ? { marginTop: 0 } : null,
                            labelStyle,
                            { color },
                            tabItemTextStyle,
                            focused ? tabItemActiveTextStyle : null
                        ]}>
                                  {labelText}
                              </Animated.Text>);
                }
                return labelText;
            };
        if (renderLabel) {
            const activeLabel = renderLabel({
                route,
                focused: true,
                color: activeColor,
            });
            const inactiveLabel = renderLabel({
                route,
                focused: false,
                color: inactiveColor,
            });
            if (openPageAnimate) {
                label = (<View>
                        <Animated.View style={[tabItemActiveStyleMode === 'enlarge' ? StyleSheet.absoluteFill : {}, { opacity: inactiveOpacity }]}>
                            {inactiveLabel}
                        </Animated.View>
                        <Animated.View style={[
                        tabItemActiveStyleMode !== 'enlarge' ? StyleSheet.absoluteFill : {},
                        { opacity: activeOpacity },
                    ]}>
                            {activeLabel}
                        </Animated.View>
                    </View>);
            }
            else {
                label = (<View>
                        {isFocused ? activeLabel : inactiveLabel}
                    </View>);
            }
        }
        const tabItemStyle = StyleSheet.flatten(style);
        // const isWidthSet = tabStyle?.width !== undefined;
        const tabContainerStyle = null;
        const scene = { route };
        let accessibilityLabel = getAccessibilityLabel(scene);
        accessibilityLabel =
            typeof accessibilityLabel !== 'undefined'
                ? accessibilityLabel
                : getLabelText(scene);
        const badge = renderBadge ? renderBadge(scene) : null;
        let itemStyle = {};
        if (itemWidth) {
            itemStyle.width = itemWidth;
            itemStyle.justifyContent = 'center';
        }
        else {
            // if (tabIndex === 0) {
            //     itemStyle.paddingLeft = 0;
            // } else if (tabIndex === navigationState.routes.length - 1) {
            //     itemStyle.paddingRight = 0;
            // }
        }
        return (<TouchableWithoutFeedback accessible={getAccessible(scene)} accessibilityLabel={accessibilityLabel} accessibilityRole="tab" accessibilityState={{ selected: isFocused }} 
        // @ts-ignore: this is to support older React Native versions
        accessibilityStates={isFocused ? ['selected'] : []} onLayout={onLayout} onPress={onPress} onLongPress={onLongPress} style={[styles.pressable, tabContainerStyle]}>
                <View style={{ flex: 1 }}>
                    <Animated.View style={[styles.item, itemStyle, tabItemStyle, isLastItem ? lastTabItemStyle : null, isFirstItem ? firstTabItemStyle : null, { opacity: inactiveOpacity },]}>
                        {icon}
                        {label}
                        {(badge != null && !isLastItem) ? (<View style={styles.badge}>{badge}</View>) : null}
                    </Animated.View>
                    <Animated.View style={[styles.item, itemStyle, tabItemStyle, isLastItem ? lastTabItemStyle : null, isFirstItem ? firstTabItemStyle : null, tabItemActiveStyle, StyleSheet.absoluteFill, { opacity: activeOpacity },]}>
                        {icon}
                        {label}
                        {(badge != null && !isLastItem) ? (<View style={styles.badge}>{badge}</View>) : null}
                    </Animated.View>
                </View>
            </TouchableWithoutFeedback>);
    }
}
const styles = StyleSheet.create({
    label: {
        backgroundColor: 'transparent',
        textTransform: 'uppercase',
        textAlign: 'center',
    },
    icon: {
        margin: 2,
    },
    item: {
        padding: 14,
        justifyContent: 'center'
    },
    badge: {
        position: 'absolute',
        top: 0,
        bottom: 0,
        right: 0,
        display: 'flex',
        justifyContent: 'center',
    },
    pressable: {
        // The label is not pressable on Windows
        // Adding backgroundColor: 'transparent' seems to fix it
        backgroundColor: 'transparent'
    },
});
