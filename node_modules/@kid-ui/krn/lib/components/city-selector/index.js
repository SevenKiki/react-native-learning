import { KidLetterIndexes } from '../letter-indexes';
import React, { useRef, useMemo, useEffect, useState, useCallback, forwardRef, useImperativeHandle } from 'react';
import { View, SectionList, Modal, TouchableWithoutFeedback, Text, Animated, UIManager, Platform, LayoutAnimation } from 'react-native';
import getStyles, { canShowLetter, maxHeight, noLetterMaxHeight } from './style';
import SectionListHeader, { headerHeight } from './city-selector-header';
import SectionListContent, { itemHeight, itemMarginBottom, itemWrapperMarginTop, itemWrapperMarginBottom } from './city-selector-item';
import { ShowWithData, windowHeight, UIUtils } from './utils';
import { rem } from '../../utils';
import { useKidColor } from '../../theme/useKidColor';
if (Platform.OS === 'android') {
    if (UIManager.setLayoutAnimationEnabledExperimental) {
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
}
const maxLetterCount = 26;
// 根据屏幕剩余高度计算出需要设置的initialNumToRender，需要在渲染前需要计算出
const getInitialNumToRender = () => {
    const sectionItemHeight = itemHeight + itemMarginBottom;
    const singleItemHeight = headerHeight + sectionItemHeight + itemWrapperMarginTop + itemWrapperMarginBottom;
    const maxSingleItemCount = Math.ceil(noLetterMaxHeight / singleItemHeight);
    // renderItem + renderSectionHeader + renderSectionFooter
    return maxSingleItemCount * 3;
};
const initialNumToRender = getInitialNumToRender();
// console.log('当前InitialNumToRender:', initialNumToRender)
export const CitySelector = forwardRef((props, ref) => {
    const { animationTime = 300, position = 'bottom' } = props;
    const section = useRef(null);
    const [letterShow, setLetterShow] = useState(false);
    const [innerVisible, setInnerVisible] = useState(false);
    useImperativeHandle(ref, () => ({
        close: (cb) => {
            slideOutFromBottom(() => {
                cb && cb();
            });
        }
    }));
    const slideInAnimateValue = useRef(new Animated.Value(1)).current;
    const [contentHeight, setContentHeight] = useState(maxHeight); // 首屏渲染，在获取到正确的宽高之前，先把弹窗内容移到屏幕外，防止闪烁
    const [bottomHeight, setBottomHeight] = useState(0);
    const [topHeight, setTopHeight] = useState(0);
    const stopAnimation = useCallback(() => {
        slideInAnimateValue.stopAnimation();
    }, [slideInAnimateValue]);
    const animateEndCallback = useCallback(() => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setInnerVisible(false);
    }, []);
    useEffect(() => {
        setContentHeight(maxHeight);
    }, [props.data]);
    useEffect(() => {
        setLetterShow(canShowLetter && props.isShowLetter);
    }, [props.isShowLetter]);
    const styles = getStyles(letterShow);
    const slideInFromTop = useCallback(() => {
        // console.log("slideInFromTop")
        stopAnimation();
        Animated.timing(slideInAnimateValue, {
            toValue: 0,
            duration: animationTime,
            useNativeDriver: true,
        }).start();
    }, [slideInAnimateValue, animationTime]);
    const slideOutFromBottom = useCallback((cb) => {
        stopAnimation();
        Animated.timing(slideInAnimateValue, {
            toValue: 1,
            duration: animationTime,
            useNativeDriver: true,
        }).start(() => {
            animateEndCallback();
            cb && cb();
        });
    }, [slideInAnimateValue, animationTime]);
    const filterData = (item, index) => {
        return index < maxLetterCount && item && item.letter && item.cityName && item.cityName.length;
    };
    const realData = useMemo(() => {
        return props.data.filter(filterData).map((item) => ({
            title: item.letter,
            data: [item.cityName],
        }));
    }, [props.data]);
    const letterList = useMemo(() => {
        return props.data.filter(filterData).map((item) => item.letter);
    }, [props.data]);
    useEffect(() => {
        if (props.visible) {
            LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
            setInnerVisible(true);
        }
    }, [props.visible]);
    const _onlayout = (e) => {
        const { height } = e.nativeEvent.layout;
        // console.log("_onlayout height:", height);
        setContentHeight(height);
        if (props.visible) {
            slideInFromTop();
        }
    };
    const sectionItemOnChange = useCallback((item) => {
        slideOutFromBottom(() => {
            props === null || props === void 0 ? void 0 : props.onCityNameChange(item);
        });
    }, [props.onCityNameChange]);
    const onClose = useCallback(() => {
        slideOutFromBottom(() => {
            props === null || props === void 0 ? void 0 : props.onClose(false);
        });
    }, []);
    const backgroundColor = useKidColor('cs_common_background_float_primary');
    return (<ShowWithData data={innerVisible}>
            <Modal transparent={true} visible={true} animationType={'none'} onRequestClose={onClose}>
                {position === 'top' && (<TouchableWithoutFeedback onPress={onClose}>
                        <View style={styles.closeArea}></View>
                    </TouchableWithoutFeedback>)}
                <View style={styles.mask}>
                    {position === 'bottom' && (<TouchableWithoutFeedback onPress={onClose}>
                            <View style={{ flex: 1 }}/>
                        </TouchableWithoutFeedback>)}
                    <Animated.View style={[
            {
                transform: [
                    {
                        translateY: slideInAnimateValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: position === 'bottom' ? [0, windowHeight] : [0, -contentHeight - bottomHeight - topHeight],
                        }),
                    }
                ],
                backgroundColor,
                borderTopLeftRadius: position === 'bottom' ? rem(12) : 0,
                borderTopRightRadius: position === 'bottom' ? rem(12) : 0,
                borderBottomRightRadius: position === 'top' ? rem(12) : 0,
                borderBottomLeftRadius: position === 'top' ? rem(12) : 0,
                paddingBottom: position === 'bottom' ? UIUtils.getBottomBarHeight() : 0,
            }
        ]}>
                        {props.renderTop && (<View style={[
                styles.top,
                props.topStyle
            ]} onLayout={(e) => {
                const { height } = e.nativeEvent.layout;
                setTopHeight(height);
            }}>
                                {props.renderTop()}
                            </View>)}
                        <View style={styles.banner}>
                            <ShowWithData data={realData.length}>
                                <SectionList ref={section} onLayout={_onlayout} bounces={false} style={styles.cityInfo} showsVerticalScrollIndicator={false} sections={realData} initialNumToRender={initialNumToRender} keyExtractor={(item) => item.toString()} contentContainerStyle={styles.SectionListContainer} renderItem={({ item }) => (<SectionListContent item={item} cityName={props.cityName} onChange={sectionItemOnChange}/>)} ListHeaderComponent={props.renderLocationHeader ? props.renderLocationHeader() : (null)} ListFooterComponent={props.renderLocationFooter ? props.renderLocationFooter() : (null)} renderSectionHeader={({ section: { title }, }) => <SectionListHeader title={title}/>}/>
                            </ShowWithData>
                            <ShowWithData data={!realData.length}>
                                <View style={styles.noData}>
                                    <Text>无更多城市</Text>
                                </View>
                            </ShowWithData>
                            <ShowWithData data={letterShow}>
                                <View style={styles.letterSelector}>
                                    <KidLetterIndexes data={letterList} indexNum={0} indexSpace={3} indexHeight={15} indexSelectedRadius={15} onChange={(index) => {
            if (section.current) {
                section.current.scrollToLocation({
                    sectionIndex: index,
                    itemIndex: 0,
                });
            }
        }}/>
                                </View>
                            </ShowWithData>
                        </View>
                        {props.renderBottom && (<View style={[
                styles.bottom,
                props.bottomStyle
            ]} onLayout={(e) => {
                const { height } = e.nativeEvent.layout;
                setBottomHeight(height);
            }}>
                                {props.renderBottom()}
                            </View>)}
                    </Animated.View>
                    {position === 'top' && (<TouchableWithoutFeedback onPress={onClose}>
                            <View style={{ flex: 1 }}/>
                        </TouchableWithoutFeedback>)}
                </View>
            </Modal>
        </ShowWithData>);
});
