var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import { Animated, NativeModules, Platform, View } from 'react-native';
import { useDrag } from './useDragAndDrop';
import { LongPressGestureHandler, PanGestureHandler, State, } from 'react-native-gesture-handler';
import { statusBarHeight } from './utils';
import { setSlideBack } from './utils';
import { RootTagContext } from './context';
import { Portal } from 'react-native-portalize';
const Draggable = (props) => {
    const STATUS_BAR_HEIGHT = typeof props.fullScreen !== 'undefined' ? (props.fullScreen ? 0 : statusBarHeight) : 0;
    const rootTag = useContext(RootTagContext);
    const panRef = useRef(null);
    const [startPoi, setStartPoi] = useState({ x: 0, y: 0 });
    const touchPos = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const [dragging, setDragging] = useState(false);
    const [slideStatus, setSlideStatus] = useState(false);
    const dndHooks = useDrag();
    const checkPoiMatch = useCallback((evt, cb) => {
        dndHooks.forEach((currentContext) => {
            var _a, _b, _c;
            const currentPoi = currentContext.poi;
            const matchXAxis = evt.nativeEvent.absoluteX > currentPoi.x &&
                evt.nativeEvent.absoluteX < currentPoi.x + currentPoi.width;
            const matchYAxis = evt.nativeEvent.absoluteY > currentPoi.y &&
                evt.nativeEvent.absoluteY < currentPoi.y + currentPoi.height;
            if (matchXAxis && matchYAxis) {
                (_a = cb === null || cb === void 0 ? void 0 : cb.matchCb) === null || _a === void 0 ? void 0 : _a.call(cb, currentContext);
            }
            else {
                (_b = cb === null || cb === void 0 ? void 0 : cb.mismatchCb) === null || _b === void 0 ? void 0 : _b.call(cb, currentContext);
            }
            (_c = cb === null || cb === void 0 ? void 0 : cb.alwaysCb) === null || _c === void 0 ? void 0 : _c.call(cb, currentContext);
        });
    }, [dndHooks]);
    const handleLongPressStateChange = useCallback((evt) => __awaiter(void 0, void 0, void 0, function* () {
        if (evt.nativeEvent.state === State.ACTIVE) {
            setStartPoi({ x: evt.nativeEvent.x, y: evt.nativeEvent.y });
            const x = evt.nativeEvent.absoluteX - evt.nativeEvent.x;
            const y = evt.nativeEvent.absoluteY - evt.nativeEvent.y - STATUS_BAR_HEIGHT;
            touchPos.setValue({ x, y });
            setDragging(true);
            dndHooks.forEach((hook) => {
                hook.subjects.startDrag.next(props.data);
            });
        }
        else if (evt.nativeEvent.state === State.END) {
            setDragging(false);
            dndHooks.forEach((hook) => hook.subjects.cancelDrag.next(true));
        }
    }), [dndHooks]);
    const onPanGestureEvent = useCallback((evt) => {
        if (dragging) {
            const { nativeEvent: { absoluteX: x, absoluteY: y }, } = evt;
            touchPos.setValue({
                x: x - startPoi.x,
                y: y - startPoi.y - STATUS_BAR_HEIGHT,
            });
            checkPoiMatch(evt, {
                matchCb: (currentContext) => currentContext.subjects.hoverEnter.next(true),
                mismatchCb: (currentContext) => currentContext.subjects.hoverLeave.next(true),
            });
        }
        return true;
    }, [dragging, dndHooks, checkPoiMatch]);
    const onPanGestureHandlerChange = useCallback((evt) => {
        if (dragging && evt.nativeEvent.state === State.END) {
            setDragging(false);
            checkPoiMatch(evt, {
                matchCb: (currentContext) => currentContext.subjects.drop.next(props.data),
                alwaysCb: (currentContext) => currentContext.subjects.cancelDrag.next(true),
            });
        }
        if (evt.nativeEvent.state === State.CANCELLED) {
            setDragging(false);
            dndHooks.forEach((hook) => hook.subjects.cancelDrag.next(true));
        }
    }, [dragging, checkPoiMatch, dndHooks]);
    const getSlideBackStatus = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        let status;
        try {
            // 主站支持版本：10.0.10
            // 真实存在的bridge，type缺失。
            // TODO: https://team.corp.kuaishou.com/task/T2585750  【bridge双端未对齐，待处理】
            // @ts-ignore
            status = yield NativeModules.KRNBasic.getSlideBack(Platform.OS === 'android' ? { rootTag } : rootTag);
        }
        catch (e) {
            status = props.slideBackStatus;
        }
        setSlideStatus(status);
    }), [props.slideBackStatus]);
    useEffect(() => {
        getSlideBackStatus();
    }, []);
    useEffect(() => {
        var _a;
        (_a = props === null || props === void 0 ? void 0 : props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, dragging);
        const slideBackStatus = dragging ? false : slideStatus;
        setSlideBack(slideBackStatus, rootTag);
    }, [dragging, slideStatus]);
    return (<LongPressGestureHandler minDurationMs={400} maxDist={20} simultaneousHandlers={panRef} onHandlerStateChange={handleLongPressStateChange}>
      <PanGestureHandler activeOffsetX={dragging ? 5 : [-10000, 10000]} activeOffsetY={dragging ? 5 : [-10000, 10000]} ref={panRef} onGestureEvent={onPanGestureEvent} onHandlerStateChange={onPanGestureHandlerChange}>
        <View testID='drag-container'>
          {dragging ? (<View style={props.placeholderStyle}>
              <Portal>
                <Animated.View style={[
                {
                    transform: touchPos.getTranslateTransform(),
                },
            ]}>
                  {props.children}
                </Animated.View>
              </Portal>
            </View>) : (<View>{props.children}</View>)}
        </View>
      </PanGestureHandler>
    </LongPressGestureHandler>);
};
export default Draggable;
