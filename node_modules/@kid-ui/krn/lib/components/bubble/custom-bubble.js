import React from 'react';
import { Dimensions, Platform, Modal, View, TouchableOpacity } from 'react-native';
import { NOOP } from '../../utils';
import { SvgBubble } from './svg-bubble';
import { Shadow } from '@kds/react-native-shadow-2';
const { width: ScreenWidth, height: ScreenHeight } = Dimensions.get('window');
const varStyles = {
    container: (withOverlay, overlayColor) => ({
        backgroundColor: withOverlay
            ? overlayColor
                ? overlayColor
                : 'rgba(250, 250, 250, 0.70)'
            : 'transparent',
        flex: 1,
    }),
};
const CustomBubble = (props) => {
    const { isJustBubble = false } = props;
    const isIOS = Platform.OS === 'ios';
    //坐标
    const calAttribute = {
        bubbleOrigin: { x: 0, y: 0 },
        anchorPoint: { x: 0, y: 0 },
    };
    const childrenRef = React.useRef();
    const [innerFromRect, setInnerFromRect] = React.useState({ x: 0, y: 0, width: 0, height: 0 });
    const _childrenOnLayout = () => {
        childrenRef.current && childrenRef.current.measure((fx, fy, width, height, px, py) => {
            setInnerFromRect({ x: px, y: py, width, height });
        });
    };
    //根据actionType子组件外层包裹触发事件
    const wrapWithAction = (actionType, children) => {
        switch (actionType) {
            case 'press':
                return (<TouchableOpacity ref={childrenRef} onLayout={_childrenOnLayout} onPress={toggleBubble} activeOpacity={1} {...props.toggleWrapperProps}>
                        {children}
                    </TouchableOpacity>);
            case 'longPress':
                return (<TouchableOpacity ref={childrenRef} onLayout={_childrenOnLayout} onLongPress={toggleBubble} activeOpacity={1} {...props.toggleWrapperProps}>
                        {children}
                    </TouchableOpacity>);
            default:
                return (<View ref={childrenRef} onLayout={_childrenOnLayout}>
                        {children}
                    </View>);
        }
    };
    //计算坐标
    const measureContent = (placement) => {
        const options = {
            displayArea: {
                x: 0,
                y: 0,
                width: ScreenWidth,
                height: ScreenHeight,
            },
            fromRect: props.isUseInnerFromRect ? innerFromRect : props.fromRect,
            contentSize: {
                width: props.isFitContentSize ? contentRect.width : Number(props.width || 0),
                height: props.isFitContentSize ? contentRect.height : Number(props.height || 0)
            },
            triangleSize: props.triangleSize,
        };
        switch (placement) {
            case 'top':
                return computeTopGeometry(options);
            case 'bottom':
                return computeBottomGeometry(options);
            case 'left':
                return computeLeftGeometry(options);
            case 'right':
                return computeRightGeometry(options);
            default:
                return computeAutoGeometry(options);
        }
    };
    const computeTopGeometry = ({ displayArea, fromRect, contentSize, triangleSize, }) => {
        const contentX = Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2));
        const contentY = fromRect.y - contentSize.height - triangleSize.height;
        calAttribute.bubbleOrigin = { x: contentX, y: contentY - 1 };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width / 2.0 - contentSize.width / 2,
            y: fromRect.y - contentSize.height - triangleSize.height,
        };
        computeOffset();
    };
    const computeBottomGeometry = ({ displayArea, fromRect, contentSize, triangleSize, }) => {
        const contentX = Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2));
        const contentY = fromRect.y + fromRect.height + triangleSize.height;
        calAttribute.bubbleOrigin = { x: contentX, y: contentY + 1 };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width / 2.0 - contentSize.width / 2,
            y: fromRect.y + fromRect.height,
        };
        computeOffset();
    };
    const computeLeftGeometry = ({ displayArea, fromRect, contentSize, triangleSize, }) => {
        const contentX = fromRect.x - contentSize.width - triangleSize.height;
        const contentY = Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2));
        calAttribute.bubbleOrigin = { x: contentX - 1, y: contentY };
        calAttribute.anchorPoint = {
            x: fromRect.x - contentSize.width - triangleSize.height,
            y: fromRect.y + fromRect.height / 2.0 - contentSize.height / 2,
        };
        computeOffset();
    };
    const computeRightGeometry = ({ displayArea, fromRect, contentSize, triangleSize, }) => {
        const contentX = fromRect.x + fromRect.width + triangleSize.height;
        const contentY = Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + (fromRect.height - contentSize.height) / 2));
        calAttribute.bubbleOrigin = { x: contentX + 1, y: contentY };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width,
            y: fromRect.y + fromRect.height / 2 - contentSize.height / 2,
        };
        computeOffset();
    };
    const computeAutoGeometry = ({ displayArea, contentSize, }) => {
        const placementsToTry = ['left', 'right', 'bottom', 'top'];
        for (let i = 0; i < placementsToTry.length; i++) {
            const placement = placementsToTry[i];
            measureContent(placement);
            if (calAttribute.bubbleOrigin.x >= displayArea.x &&
                calAttribute.bubbleOrigin.x <=
                    displayArea.x + displayArea.width - contentSize.width &&
                calAttribute.bubbleOrigin.y >= displayArea.y &&
                calAttribute.bubbleOrigin.y <=
                    displayArea.y + displayArea.height - contentSize.height) {
                break;
            }
        }
    };
    const computeOffset = () => {
        const oldAnchor = calAttribute.anchorPoint;
        calAttribute.anchorPoint = {
            x: oldAnchor.x + props.bubbleOffsetX,
            y: oldAnchor.y + props.bubbleOffsetY,
        };
        const oldContent = calAttribute.bubbleOrigin;
        calAttribute.bubbleOrigin = {
            x: oldContent.x + props.bubbleOffsetX,
            y: oldContent.y + props.bubbleOffsetY,
        };
    };
    const [contentRect, setContentRect] = React.useState({ width: 0, height: 0 });
    const contentOnLayout = (event) => {
        const { width: _width, height: _height } = event.nativeEvent.layout;
        const width = Number(_width === null || _width === void 0 ? void 0 : _width.toFixed(0));
        const height = Number(_height === null || _height === void 0 ? void 0 : _height.toFixed(0));
        if (Math.abs(width - contentRect.width) > 1 || Math.abs(height - contentRect.height) > 1) {
            setContentRect({ width: width + props.widthToFixFit, height });
        }
    };
    //渲染气泡内容
    const renderContent = () => {
        var _a, _b;
        //计算箭头锚点、气泡原点
        measureContent(props.placement);
        //气泡样式
        const bubbleStyle = getBubbleStyle();
        //内容样式
        const contentStyle = getContentStyle();
        const offset = getShadowOffset();
        return (<View style={bubbleStyle}>
                {((props.isFitContentSize && contentRect.width) || !props.isFitContentSize) && (<Shadow offset={offset} distance={8} radius={6} startColor='rgba(0,0,0,0.05)' {...props.bubbleShadow}>
                        <View style={{ width: props.isFitContentSize ? contentRect.width : Number(props.width || 0), height: props.isFitContentSize ? contentRect.height : Number(props.height || 0) }}/>
                    </Shadow>)}
                <SvgBubble style={{ position: 'absolute' }} placement={props.placement} width={props.isFitContentSize ? contentRect.width : Number(props.width || 0)} height={props.isFitContentSize ? contentRect.height : Number(props.height || 0)} borderRadius={props.bubbleCornerRadius} color={props.backgroundColor} withTriangle={props.withTriangle} triangleWidth={(_a = props.triangleSize) === null || _a === void 0 ? void 0 : _a.width} triangleHeight={(_b = props.triangleSize) === null || _b === void 0 ? void 0 : _b.height} triangleColor={props.triangleColor || props.backgroundColor} offsetX={props.bubbleContentOffsetX}/>
                <View onLayout={contentOnLayout} style={contentStyle}>
                    {props.content}
                </View>
            </View>);
    };
    const getBubbleStyle = () => {
        let offsetX = props.bubbleContentOffsetX;
        const { width: _width, isFitContentSize, triangleSize, bubbleCornerRadius: borderRadius } = props;
        const width = isFitContentSize ? contentRect.width : Number(_width);
        const { width: triangleWidth } = triangleSize;
        if (props.placement === 'top' || props.placement === 'bottom') {
            offsetX = Math.abs(offsetX) > (width - triangleWidth) / 2 - borderRadius ? (offsetX > 0 ? (width - triangleWidth) / 2 - borderRadius : -((width - triangleWidth) / 2 - borderRadius)) : offsetX;
        }
        //构建气泡样式
        const bubbleStyle = {
            position: 'absolute',
            top: calAttribute.anchorPoint.y,
            left: calAttribute.anchorPoint.x + offsetX,
        };
        return bubbleStyle;
    };
    const getContentStyle = () => {
        var _a, _b;
        //构建气泡样式
        const bubbleStyle = {
            position: 'absolute',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 10,
            top: (props.placement === 'bottom' && props.withTriangle) ? (_a = props.triangleSize) === null || _a === void 0 ? void 0 : _a.height : 0,
            left: (props.placement === 'right' && props.withTriangle) ? (_b = props.triangleSize) === null || _b === void 0 ? void 0 : _b.height : 0,
            opacity: ((props.isFitContentSize && contentRect.width) || !props.isFitContentSize) ? 1 : 0
        };
        return [
            bubbleStyle,
            props.isFitContentSize ? {} : { width: props.width, height: props.height },
            props.contentStyle,
            props.bubbleStyle
        ];
    };
    const getShadowOffset = () => {
        switch (props.placement) {
            case 'top':
            case 'left':
                return [0, 0];
            case 'right':
                return [5, 0];
            case 'bottom':
            default:
                return [0, 5];
        }
    };
    //气泡显示/隐藏
    const toggleBubble = () => {
        var _a, _b;
        if (props.isVisible && !isIOS) {
            (_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props);
        }
        (_b = props.onToggle) === null || _b === void 0 ? void 0 : _b.call(props);
    };
    return (isJustBubble ?
        ((props.isVisible && renderContent()) || null)
        :
            (<View>
                {wrapWithAction(props.actionType, props.children)}
                <Modal animationType="fade" visible={props.isVisible} transparent onShow={props.onOpen} onDismiss={props.onClose} onRequestClose={props.onClose}>
                    <TouchableOpacity style={varStyles.container(!!props.withOverlay, props.overlayColor)} onPress={(e) => {
                    props.onClick(e);
                    toggleBubble();
                }} activeOpacity={1}>
                        {renderContent()}
                    </TouchableOpacity>
                </Modal>
            </View>));
};
CustomBubble.defaultProps = {
    isVisible: false,
    fromRect: { x: 0, y: 0, width: 0, height: 0 },
    placement: 'bottom',
    width: 120,
    height: 40,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    bubbleCornerRadius: 4,
    withTriangle: true,
    triangleSize: { width: 13, height: 6 },
    withOverlay: false,
    actionType: 'press',
    onClick: NOOP,
    isFitContentSize: false,
    widthToFixFit: 1
};
export default CustomBubble;
