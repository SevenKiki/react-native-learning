import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Svg, Path, Line } from './svg';
const styles = StyleSheet.create({
    content: {
        position: 'absolute',
        justifyContent: 'center',
        alignItems: 'center'
    }
});
export const SvgBubble = (props) => {
    const { style, width = 120, height = 40, placement = 'bottom', borderRadius = 4, color = 'rgba(0, 0, 0, 0.7)', withTriangle = true, triangleWidth = 13, triangleHeight = 6, triangleColor = 'rgba(0, 0, 0, 0.7)', triangleBorderWidth, triangleBorderColor, offsetX = 0 } = props;
    const svgWidth = React.useMemo(() => {
        if (placement === 'left' || placement === 'right') {
            return withTriangle ? width + triangleWidth : width;
        }
        return width;
    }, [placement, width, withTriangle, triangleWidth]);
    const svgHeight = React.useMemo(() => {
        if (placement === 'top' || placement === 'bottom' || placement === 'auto') {
            return withTriangle ? height + triangleHeight : height;
        }
        return height;
    }, [placement, height, withTriangle, triangleHeight]);
    const _offsetX = React.useMemo(() => {
        if (placement === 'top' || placement === 'bottom') {
            return Math.abs(offsetX) > (width - triangleWidth) / 2 - borderRadius ? (offsetX > 0 ? (width - triangleWidth) / 2 - borderRadius : -((width - triangleWidth) / 2 - borderRadius)) : offsetX;
        }
        else {
            return offsetX;
        }
    }, [offsetX, width, triangleWidth, borderRadius, placement]);
    const pathContent = React.useMemo(() => {
        switch (placement) {
            case 'top':
                return !withTriangle
                    ? `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`
                    : `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${(width + triangleWidth) / 2 - _offsetX} ${height}L${width / 2 - _offsetX} ${height + triangleHeight}L${(width - triangleWidth) / 2 - _offsetX} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`;
            case 'left':
                return !withTriangle
                    ? `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`
                    : `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${(height - triangleWidth) / 2}L${width + triangleHeight} ${height / 2}L${width} ${(height + triangleWidth) / 2}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`;
            case 'right':
                return !withTriangle
                    ? `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`
                    : `M${borderRadius + triangleHeight} 0L${width - borderRadius + triangleHeight} 0A${borderRadius} ${borderRadius} 0 0 1 ${width + triangleHeight} ${borderRadius}L${width + triangleHeight} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius + triangleHeight} ${height}L${borderRadius + triangleHeight} ${height}A${borderRadius} ${borderRadius} 0 0 1 ${triangleHeight} ${height - borderRadius}L${triangleHeight} ${(height + triangleWidth) / 2}L0 ${height / 2}L${triangleHeight} ${(height - triangleWidth) / 2}L${triangleHeight} ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius + triangleHeight} 0Z`;
            case 'bottom':
            default:
                return !withTriangle
                    ? `M${borderRadius} 0L${width - borderRadius} 0A${borderRadius} ${borderRadius} 0 0 1 ${width} ${borderRadius}L${width} ${height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${height}L${borderRadius} ${height}A${borderRadius} ${borderRadius} 0 0 1 0 ${height - borderRadius}L0 ${borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} 0Z`
                    : `M${borderRadius} ${triangleHeight}L${(width - triangleWidth) / 2 - _offsetX} ${triangleHeight}L${width / 2 - _offsetX} 0L${(width + triangleWidth) / 2 - _offsetX} ${triangleHeight}L${width - borderRadius} ${triangleHeight}A${borderRadius} ${borderRadius} 0 0 1 ${width} ${triangleHeight + borderRadius}L${width} ${triangleHeight + height - borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${width - borderRadius} ${triangleHeight + height}L${borderRadius} ${triangleHeight + height}A${borderRadius} ${borderRadius} 0 0 1 0 ${triangleHeight + height - borderRadius}L0 ${triangleHeight + borderRadius}A${borderRadius} ${borderRadius} 0 0 1 ${borderRadius} ${triangleHeight}Z`;
        }
    }, [placement, width, height, borderRadius, withTriangle, triangleWidth, triangleHeight, offsetX]);
    const linePoint = React.useMemo(() => {
        switch (placement) {
            case 'top':
                return [
                    { x1: (width - triangleWidth) / 2 - offsetX, y1: height, x2: width / 2 - offsetX, y2: height + triangleHeight },
                    { x1: (width + triangleWidth) / 2 - offsetX, y1: height, x2: width / 2 - offsetX, y2: height + triangleHeight },
                ];
            case 'left':
                return [
                    { x1: width, y1: (height - triangleWidth) / 2, x2: width + triangleHeight, y2: height / 2 },
                    { x1: width, y1: (height + triangleWidth) / 2, x2: width + triangleHeight, y2: height / 2 },
                ];
            case 'right':
                return [
                    { x1: triangleHeight, y1: (height - triangleWidth) / 2, x2: 0, y2: height / 2 },
                    { x1: triangleHeight, y1: (height + triangleWidth) / 2, x2: 0, y2: height / 2 },
                ];
            case 'bottom':
            default:
                return [
                    { x1: (width - triangleWidth) / 2 - offsetX, y1: height, x2: width / 2 - offsetX, y2: height + triangleHeight },
                    { x1: (width + triangleWidth) / 2 - offsetX, y1: height, x2: width / 2 - offsetX, y2: height + triangleHeight },
                ];
        }
    }, [placement, width, height, triangleWidth, triangleHeight, offsetX]);
    return (<View style={style}>
        <Svg width={svgWidth} height={svgHeight} viewBox={`0 0 ${svgWidth} ${svgHeight}`}>
          <Path d={pathContent} fill={color}/>
          {withTriangle && <Line x1={linePoint[0].x1} y1={linePoint[0].y1} x2={linePoint[0].x2} y2={linePoint[0].y2} stroke={triangleBorderColor} strokeWidth={triangleBorderWidth}/>}
          {withTriangle && <Line x1={linePoint[1].x1} y1={linePoint[1].y1} x2={linePoint[1].x2} y2={linePoint[1].y2} stroke={triangleBorderColor} strokeWidth={triangleBorderWidth}/>}
        </Svg>
    </View>);
};
