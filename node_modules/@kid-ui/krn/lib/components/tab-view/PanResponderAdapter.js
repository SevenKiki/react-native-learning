var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Animated, PanResponder, Keyboard, StyleSheet, I18nManager, View, } from 'react-native';
import useAnimatedValue from './utils';
const DEAD_ZONE = 12;
const DefaultTransitionSpec = {
    timing: Animated.spring,
    stiffness: 1000,
    damping: 500,
    mass: 3,
    overshootClamping: true,
};
export default function PanResponderAdapter({ layout, keyboardDismissMode = 'auto', swipeEnabled = true, navigationState, onIndexChange, onSwipeStart, onSwipeEnd, onSwipe, children, style, }) {
    const { routes, index } = navigationState;
    const panX = useAnimatedValue(0);
    const layoutWValue = useAnimatedValue(-layout.width || -1);
    layoutWValue.setValue(-layout.width || -1);
    const position = React.useRef(Animated.divide(panX, layoutWValue)).current;
    const listenersRef = React.useRef([]);
    const navigationStateRef = React.useRef(navigationState);
    const layoutRef = React.useRef(layout);
    const onIndexChangeRef = React.useRef(onIndexChange);
    const currentIndexRef = React.useRef(index);
    const pendingIndexRef = React.useRef();
    const swipeVelocityThreshold = 0.15;
    const swipeDistanceThreshold = layout.width / 1.75;
    const jumpToIndex = React.useCallback((index) => {
        const offset = -index * layoutRef.current.width;
        onIndexChangeRef.current(index);
        const { timing } = DefaultTransitionSpec, transitionConfig = __rest(DefaultTransitionSpec, ["timing"]);
        Animated.parallel([
            timing(panX, Object.assign(Object.assign({}, transitionConfig), { toValue: offset, useNativeDriver: false })),
        ]).start(({ finished }) => {
            if (finished) {
                // onIndexChangeRef.current(index);
                pendingIndexRef.current = undefined;
            }
        });
        pendingIndexRef.current = index;
    }, [panX]);
    React.useEffect(() => {
        navigationStateRef.current = navigationState;
        layoutRef.current = layout;
        onIndexChangeRef.current = onIndexChange;
    });
    React.useEffect(() => {
        const offset = -navigationStateRef.current.index * layout.width;
        panX.setValue(offset);
    }, [layout.width, panX]);
    React.useEffect(() => {
        if (keyboardDismissMode === 'auto') {
            Keyboard.dismiss();
        }
        if (layout.width && currentIndexRef.current !== index) {
            currentIndexRef.current = index;
            jumpToIndex(index);
        }
    }, [jumpToIndex, keyboardDismissMode, layout.width, index]);
    const isMovingHorizontally = (_, gestureState) => {
        return (Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&
            Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2));
    };
    const canMoveScreen = (event, gestureState) => {
        if (swipeEnabled === false) {
            return false;
        }
        const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;
        return (isMovingHorizontally(event, gestureState) &&
            ((diffX >= DEAD_ZONE && currentIndexRef.current > 0) ||
                (diffX <= -DEAD_ZONE &&
                    currentIndexRef.current < routes.length - 1)));
    };
    const startGesture = () => {
        onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();
        if (keyboardDismissMode === 'on-drag') {
            Keyboard.dismiss();
        }
        panX.stopAnimation();
        // @ts-expect-error: _value is private, but docs use it as well
        panX.setOffset(panX._value);
    };
    const respondToGesture = (_, gestureState) => {
        const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;
        if (
        // swiping left
        (diffX > 0 && index <= 0) ||
            // swiping right
            (diffX < 0 && index >= routes.length - 1)) {
            return;
        }
        if (layout.width) {
            // @ts-expect-error: _offset is private, but docs use it as well
            const position = (panX._offset + diffX) / -layout.width;
            const next = position > index ? Math.ceil(position) : Math.floor(position);
            if (next !== index) {
                listenersRef.current.forEach((listener) => listener(next));
            }
        }
        panX.setValue(diffX);
    };
    const finishGesture = (_, gestureState) => {
        panX.flattenOffset();
        onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();
        const currentIndex = typeof pendingIndexRef.current === 'number'
            ? pendingIndexRef.current
            : currentIndexRef.current;
        let nextIndex = currentIndex;
        if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&
            Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&
            (Math.abs(gestureState.dx) > swipeDistanceThreshold ||
                Math.abs(gestureState.vx) > swipeVelocityThreshold)) {
            nextIndex = Math.round(Math.min(Math.max(0, I18nManager.isRTL
                ? currentIndex +
                    gestureState.dx / Math.abs(gestureState.dx)
                : currentIndex -
                    gestureState.dx / Math.abs(gestureState.dx)), routes.length - 1));
            currentIndexRef.current = nextIndex;
        }
        if (!isFinite(nextIndex)) {
            nextIndex = currentIndex;
        }
        jumpToIndex(nextIndex);
        if (nextIndex !== currentIndex) {
            onSwipe === null || onSwipe === void 0 ? void 0 : onSwipe(nextIndex);
        }
    };
    // TODO: use the listeners
    const addEnterListener = React.useCallback((listener) => {
        listenersRef.current.push(listener);
        return () => {
            const index = listenersRef.current.indexOf(listener);
            if (index > -1) {
                listenersRef.current.splice(index, 1);
            }
        };
    }, []);
    const jumpTo = React.useCallback((key) => {
        const index = navigationStateRef.current.routes.findIndex((route) => route.key === key);
        jumpToIndex(index);
    }, [jumpToIndex]);
    const panResponder = PanResponder.create({
        onMoveShouldSetPanResponder: canMoveScreen,
        onMoveShouldSetPanResponderCapture: canMoveScreen,
        onPanResponderGrant: startGesture,
        onPanResponderMove: respondToGesture,
        onPanResponderTerminate: finishGesture,
        onPanResponderRelease: finishGesture,
        onPanResponderTerminationRequest: () => true,
    });
    const maxTranslate = layout.width * (routes.length - 1);
    const translateX = Animated.multiply(panX.interpolate({
        inputRange: [-maxTranslate, 0],
        outputRange: [-maxTranslate, 0],
        extrapolate: 'clamp',
    }), I18nManager.isRTL ? -1 : 1);
    return children({
        position,
        addEnterListener,
        jumpTo,
        render: (children) => (<Animated.View style={[
                styles.sheet,
                layout.width
                    ? {
                        width: routes.length * layout.width,
                        transform: [{ translateX }],
                    }
                    : null,
                style,
            ]} {...panResponder.panHandlers}>
                {React.Children.map(children, (child, i) => {
                const route = routes[i];
                const focused = i === index;
                return (<View key={route.key} style={layout.width
                        ? { width: layout.width }
                        : focused
                            ? StyleSheet.absoluteFill
                            : null}>
                            {focused || layout.width ? child : null}
                        </View>);
            })}
            </Animated.View>),
    });
}
const styles = StyleSheet.create({
    sheet: {
        flex: 1,
        flexDirection: 'row',
        alignItems: 'stretch',
    },
});
