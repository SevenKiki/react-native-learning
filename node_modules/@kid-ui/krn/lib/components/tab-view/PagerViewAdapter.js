var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Animated, Keyboard, StyleSheet, Platform } from 'react-native';
import ViewPager from '@kds/react-native-pager-view';
import useAnimatedValue from './utils';
const IS_IOS = Platform.OS === 'ios';
const AnimatedViewPager = Animated.createAnimatedComponent(ViewPager);
export default function PagerViewAdapter(_a) {
    var { keyboardDismissMode = 'auto', swipeEnabled = true, enterOnce, openPageAnimate, navigationState, onIndexChange, onSwipeStart, onSwipeEnd, children, overdrag = true, style, onSwipe } = _a, rest = __rest(_a, ["keyboardDismissMode", "swipeEnabled", "enterOnce", "openPageAnimate", "navigationState", "onIndexChange", "onSwipeStart", "onSwipeEnd", "children", "overdrag", "style", "onSwipe"]);
    const { index } = navigationState;
    const listenersRef = React.useRef([]);
    const pagerRef = React.useRef();
    const indexRef = React.useRef(0);
    const navigationStateRef = React.useRef(navigationState);
    const indexChangeType = React.useRef('swipe');
    const position = useAnimatedValue(index);
    const offset = useAnimatedValue(0);
    // when swiping the next scene distance is always 1,
    // but when pressing a tab can be greater
    const [jumpingTo, setJumpingTo] = React.useState([0, 1]);
    const setIndexJump = React.useRef(false); // 区分主动ios setIndex 跳转和点击/滑动跳转
    React.useEffect(() => {
        navigationStateRef.current = navigationState;
    });
    const jumpTo = React.useCallback((key) => {
        var _a, _b;
        const index = navigationStateRef.current.routes.findIndex((route) => route.key === key);
        indexChangeType.current = 'jump';
        if (IS_IOS) {
            //iOS 上 setIndexJump 为 true 会影响拖拽，需要复位
            setIndexJump.current = false;
            setJumpingTo([indexRef.current, index]);
        }
        ;
        if (openPageAnimate) {
            (_a = pagerRef.current) === null || _a === void 0 ? void 0 : _a.setPage(index);
        }
        else {
            (_b = pagerRef.current) === null || _b === void 0 ? void 0 : _b.setPageWithoutAnimation(index);
            position.setValue(index);
        }
    }, [openPageAnimate]);
    React.useEffect(() => {
        var _a, _b;
        if (keyboardDismissMode === 'auto') {
            Keyboard.dismiss();
        }
        if (indexRef.current !== index) {
            if (IS_IOS) {
                setIndexJump.current = true;
                setJumpingTo([indexRef.current, index]);
            }
            ;
            if (openPageAnimate) {
                (_a = pagerRef.current) === null || _a === void 0 ? void 0 : _a.setPage(index);
            }
            else {
                (_b = pagerRef.current) === null || _b === void 0 ? void 0 : _b.setPageWithoutAnimation(index);
                position.setValue(index);
            }
        }
    }, [keyboardDismissMode, index, openPageAnimate]);
    const onPageScrollStateChanged = (state) => {
        const { pageScrollState } = state.nativeEvent;
        switch (pageScrollState) {
            case 'idle':
                onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();
                return;
            case 'dragging': {
                //iOS 上 setIndexJump 为 true 会影响拖拽，需要复位
                if (IS_IOS) {
                    setIndexJump.current = false;
                }
                const subscription = offset.addListener(({ value }) => {
                    const next = index +
                        (value > 0.1 ? -1 : 1);
                    if (next !== index) {
                        listenersRef.current.forEach((listener) => listener(next));
                    }
                    offset.removeListener(subscription);
                });
                onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();
                return;
            }
        }
    };
    const addEnterListener = React.useCallback((listener) => {
        listenersRef.current.push(listener);
        return () => {
            const index = listenersRef.current.indexOf(listener);
            if (index > -1) {
                listenersRef.current.splice(index, 1);
            }
        };
    }, []);
    React.useEffect(() => {
        if (IS_IOS && !setIndexJump.current) {
            setJumpingTo([navigationState.index, navigationState.index + 1]);
        }
    }, [navigationState.index]);
    const iosFixInterpolate = jumpingTo[0] < jumpingTo[1]
        ? {
            inputRange: [jumpingTo[0] - 1, jumpingTo[0], jumpingTo[0] + 1],
            outputRange: [jumpingTo[0] - 1, ...jumpingTo]
        }
        : {
            inputRange: [jumpingTo[0] - 1, jumpingTo[0], jumpingTo[0] + 1],
            outputRange: [...jumpingTo.reverse(), jumpingTo[0] + 1]
        };
    const injectedPosition = Animated.add(position, offset);
    return children({
        position: IS_IOS
            ? injectedPosition.interpolate(Object.assign(Object.assign({}, iosFixInterpolate), { extrapolate: 'clamp' }))
            : injectedPosition,
        addEnterListener,
        jumpTo,
        render: (children) => (<AnimatedViewPager {...rest} 
        // @ts-expect-error
        ref={pagerRef} style={[styles.container, style]} initialPage={index} overdrag={overdrag} keyboardDismissMode={keyboardDismissMode === 'auto'
                ? 'on-drag'
                : keyboardDismissMode} onPageScroll={Animated.event([
                {
                    nativeEvent: {
                        position: position,
                        offset: offset,
                    },
                },
            ], { useNativeDriver: true })} onPageSelected={(e) => {
                if (IS_IOS && setIndexJump.current) {
                    // 防止主动 setIndex 跳转后接着滑动切换起始插值不对
                    setJumpingTo([navigationState.index, navigationState.index + 1]);
                }
                const index = e.nativeEvent.position;
                indexRef.current = index;
                onIndexChange(index);
                if (indexChangeType.current === 'jump') {
                    indexChangeType.current = 'swipe';
                    return;
                }
                if (index !== navigationState.index) {
                    onSwipe === null || onSwipe === void 0 ? void 0 : onSwipe(index);
                }
            }} onPageScrollStateChanged={onPageScrollStateChanged} scrollEnabled={swipeEnabled} enterOnce={enterOnce}>
                {children}
            </AnimatedViewPager>),
    });
}
const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
});
