var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Animated, View, Image, StyleSheet, NativeModules, } from 'react-native';
import React, { useCallback, useContext, useEffect, useMemo, useRef, useState, } from 'react';
import { PanGestureHandler, GestureHandlerRootView, State, } from 'react-native-gesture-handler';
//@ts-ignore
import RootTagContext from 'react-native/Libraries/ReactNative/RootTagContext.js';
const styles = StyleSheet.create({
    wrap: {
        justifyContent: 'center',
        alignItems: 'center',
    },
    container: {
        flexDirection: 'row',
        alignItems: 'center',
    },
});
const FULL_STAR = require('./rating_star_bar_full.png');
const LEFT_HALF_STAR = require('./rating_star_bar_left_half.png');
// Default Values
const DEFAULT_SPACING = 1;
const DEFAULT_ACTIVE_COLOR = '#FFC338';
const DEFAULT_INACTIVE_COLOR = '#C8C7C8';
const DEFAULT_STAR_SIZE = 15;
function useProp(value, defaultValue) {
    const [prop, setProp] = useState(value !== null && value !== void 0 ? value : defaultValue);
    useEffect(() => {
        setProp((prev) => value !== null && value !== void 0 ? value : prev);
    }, [value]);
    return prop;
}
/**
 * 评分星星view，支持滑动。
 */
export function RatingStarView(props) {
    const { style, totalCount, initCount, activeColor: pActiveColor, inactiveColor: pInactiveColor, enableTouch: pEnableTouch, starSize: pStarSize, spacing: pSpacing, onSwipeRating, } = props;
    // handleProps
    const [fullStarCount, setFullStarCount] = useState(initCount);
    const activeColor = useProp(pActiveColor, DEFAULT_ACTIVE_COLOR);
    const inactiveColor = useProp(pInactiveColor, DEFAULT_INACTIVE_COLOR);
    const enableTouch = useProp(pEnableTouch, true);
    const starSize = useProp(pStarSize, DEFAULT_STAR_SIZE);
    const spacing = useProp(pSpacing, DEFAULT_SPACING);
    const halfIndex = fullStarCount % 1 !== 0 ? Math.ceil(fullStarCount) : -1; // 半个的位置
    // touch anim
    const startX = useRef(0); // 容器rect 左侧X
    const endX = useRef(0); // 容器rect 右侧x
    const gestureMoveX = useMemo(() => {
        return new Animated.Value(0);
    }, []);
    const singleSize = useMemo(() => {
        return starSize + spacing;
    }, [spacing, starSize]);
    const rootTag = useContext(RootTagContext);
    const slideBackStatus = useRef();
    useEffect(() => {
        gestureMoveX.addListener(({ value }) => {
            const tapX = value - startX.current;
            // 允许多滑半个，避免最后一个填不满
            if (tapX < 0 || tapX > endX.current + singleSize / 2) {
                return;
            }
            let fullNum = Math.floor(tapX / singleSize);
            const remainRatio = (tapX - fullNum * singleSize) / singleSize;
            // 不到半个算半个，超过半个算1个
            if (remainRatio < 0.5) {
                fullNum += 0.5;
            }
            else {
                fullNum += 1;
            }
            fullNum = Math.min(fullNum, totalCount);
            onSwipeRating && onSwipeRating(fullNum);
            setFullStarCount(fullNum);
        });
    }, [gestureMoveX, onSwipeRating, singleSize, totalCount]);
    const onLayout = useCallback((e) => {
        startX.current = e.nativeEvent.layout.x;
        endX.current = e.nativeEvent.layout.width;
    }, []);
    const starViews = useMemo(() => {
        const viewList = [];
        const fullBoundary = halfIndex === -1 ? fullStarCount : fullStarCount - 1; // 黄色渲染到半个前一个
        for (let i = 0; i < totalCount; i++) {
            const tint = i < fullBoundary ? activeColor : inactiveColor;
            const margin = i === totalCount - 1 ? 0 : spacing;
            viewList.push(<Image key={`${i}`} style={{
                    width: starSize,
                    height: starSize,
                    marginRight: margin,
                    tintColor: tint,
                }} source={FULL_STAR}/>);
        }
        return viewList;
    }, [
        activeColor,
        fullStarCount,
        halfIndex,
        inactiveColor,
        spacing,
        starSize,
        totalCount,
    ]);
    const halfView = useMemo(() => {
        if (halfIndex === -1) {
            return null;
        }
        const imageStyle = {
            position: 'absolute',
            width: starSize,
            height: starSize,
            left: singleSize * (halfIndex - 1),
            tintColor: activeColor,
        };
        return <Image style={imageStyle} source={LEFT_HALF_STAR}/>;
    }, [activeColor, halfIndex, singleSize, starSize]);
    const onGesture = useMemo(() => {
        return Animated.event([
            {
                nativeEvent: {
                    x: gestureMoveX,
                },
            },
        ], {
            useNativeDriver: false,
        });
    }, [gestureMoveX]);
    const onHandlerStateChange = useCallback(({ nativeEvent }) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f;
        if (nativeEvent.state === State.BEGAN) {
            gestureMoveX.setValue(nativeEvent.x);
            try {
                // drag 开始时获取滑动返回状态,并禁用滑动返回
                slideBackStatus.current =
                    yield ((_b = (_a = NativeModules.KRNBasic) === null || _a === void 0 ? void 0 : _a.getSlideBack) === null || _b === void 0 ? void 0 : _b.call(_a, rootTag));
                (_d = (_c = NativeModules.KRNBasic) === null || _c === void 0 ? void 0 : _c.setSlideBack) === null || _d === void 0 ? void 0 : _d.call(_c, {
                    enabled: false,
                    rootTag: rootTag,
                });
            }
            catch (error) { }
        }
        else if (nativeEvent.state === State.END ||
            nativeEvent.state === State.FAILED ||
            nativeEvent.state === State.CANCELLED) {
            try {
                // 拖动结束时，把 SlideBackStatus 还原
                (_f = (_e = NativeModules.KRNBasic) === null || _e === void 0 ? void 0 : _e.setSlideBack) === null || _f === void 0 ? void 0 : _f.call(_e, {
                    enabled: slideBackStatus.current,
                    rootTag: rootTag,
                });
            }
            catch (error) { }
        }
        return onGesture;
    }), [gestureMoveX, onGesture, rootTag]);
    return (<GestureHandlerRootView style={styles.wrap}>
            <PanGestureHandler enabled={enableTouch} onGestureEvent={onGesture} onHandlerStateChange={onHandlerStateChange}>
                <View testID='ratingViewRoot' style={Object.assign(Object.assign({}, style), styles.container)} onLayout={onLayout}>
                    {starViews.map((view) => view)}
                    {halfView}
                </View>
            </PanGestureHandler>
        </GestureHandlerRootView>);
}
