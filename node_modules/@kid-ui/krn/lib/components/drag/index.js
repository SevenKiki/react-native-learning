import React, { useRef, useEffect, useState, useMemo } from 'react';
import { View, StyleSheet, Dimensions, PanResponder, NativeModules, LayoutAnimation, Platform, UIManager } from 'react-native';
if (Platform.OS === 'android') {
    if (UIManager.setLayoutAnimationEnabledExperimental) {
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
}
const styles = StyleSheet.create({
    wrapper: {
        backgroundColor: 'pink',
        position: 'absolute',
        left: 0,
        top: 0,
    },
    debugBorder: {
        borderWidth: 2,
        position: 'absolute',
        left: 0,
        top: 0,
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
    },
    line: {
        width: 2,
        height: '100%',
        backgroundColor: 'pink'
    }
});
const Drag = (props) => {
    var _a, _b;
    const { safeArea: safeAreaProps = [], initPos = {} } = props;
    const [isClick, setIsClick] = useState(true);
    const [element, setElement] = useState({
        width: 0,
        height: 0
    });
    const [pos, setPos] = useState({
        left: 0,
        top: 0
    });
    const windowWidth = ((_a = props.dragArea) === null || _a === void 0 ? void 0 : _a.width) || Dimensions.get('window').width; //宽度
    const windowHeight = ((_b = props.dragArea) === null || _b === void 0 ? void 0 : _b.height) || Dimensions.get('window').height; //高度
    const dragableView = useRef();
    const [renderOnce, setRenderOnce] = useState(true);
    const minAnimateXY = 0;
    const maxAnimateX = windowWidth - element.width;
    const maxAnimateY = windowHeight - element.height;
    //【重要/不对外暴露】用来区分点击手势/滑动手势的判定范围。 此值越大，识别为点击的比例越大。
    const throttle = 1;
    useEffect(() => {
        // console.log(windowWidth, windowHeight)
        initElementPos();
    }, [maxAnimateX, maxAnimateY, initPos, safeAreaProps]);
    const safeArea = useMemo(() => {
        let safeLeft = 0, safeRight = 0, safeTop = 0, safeBottom = 0;
        switch (safeAreaProps.length) {
            case 0: {
                safeLeft = safeRight = safeTop = safeBottom = 0;
                break;
            }
            case 1: {
                const [left] = safeAreaProps;
                safeLeft = safeRight = safeTop = safeBottom = left;
                break;
            }
            case 2: {
                const [top, left] = safeAreaProps;
                safeTop = safeBottom = top;
                safeLeft = safeRight = left;
                break;
            }
            case 4: {
                const [top, right, bottom, left] = safeAreaProps;
                safeLeft = left;
                safeRight = right;
                safeTop = top;
                safeBottom = bottom;
                break;
            }
            default:
                throw new Error('safeArea参数只支持长度为1/2/4,参考padding/margin');
        }
        return {
            left: safeLeft,
            right: safeRight,
            top: safeTop,
            bottom: safeBottom
        };
    }, [safeAreaProps]);
    const initElementPos = () => {
        const { left: initLeft = 0, top: initTop = 0 } = initPos;
        const left = getRealLeft(initLeft, 'init');
        const top = getRealTop(initTop);
        setPos({ left, top });
        setDragElementPos({ left, top }, 'init');
    };
    try {
        if (Platform.OS === 'ios') {
            NativeModules.Kds.invoke('tool', 'setMiddleSlideBack', JSON.stringify({
                enabled: false,
            }));
        }
        NativeModules.KRNBasic.setSlideBack({
            enabled: false,
            rootTag: 1
        });
    }
    catch (e) {
    }
    const _onPanResponderGrant = (evt, gestureState) => {
        // console.log("_onPanResponderGrant")
        // 默认点击模式，throttle太小可能不触发
        setIsClick(true);
        // ios手势识别有冲突，必须在元素作为手势响应者时，禁止其他外层容器滚动
        props.dragActiveCb && props.dragActiveCb();
    };
    const _onPanResponderMove = (evt, gestureState) => {
        // console.log('_onPanResponderMove', gestureState.dx, gestureState.dy, isClick)
        // 如果累计的移动距离小于throttle 则表示没移动
        if (gestureState.dx < throttle && gestureState.dx > -throttle && gestureState.dy < throttle && gestureState.dy > -throttle) {
            // console.log('点击', gestureState.dx, gestureState.dy, isClick);
            setIsClick(true);
        }
        else {
            setIsClick(false);
            // console.log('滑动', gestureState.dx, gestureState.dy, isClick);
            let left = getRealLeft(pos.left + gestureState.dx, 'move');
            let top = getRealTop(pos.top + gestureState.dy);
            setDragElementPos({ left, top }, 'move');
        }
    };
    const _onPanResponderRelease = (evt, gestureState) => {
        const left = pos.left + gestureState.dx;
        const top = pos.top + gestureState.dy;
        let autoAdsorptionLeft = 0;
        // console.log("_onPanResponderRelease", left, top, gestureState.dx, gestureState.dy, isClick);
        if (isClick) {
            // 点击事件处理
            props.clickCb && props.clickCb();
        }
        else {
            // 重置offset 内部处理了自动吸边逻辑
            autoAdsorptionLeft = setOffset(left, top);
            // 开启自动吸边的时候，需要额外处理
            if (props.isAutoAdsorption) {
                // console.log("pos.left:", pos.left, autoAdsorptionLeft);
                setDragElementPosAnimated({ left: autoAdsorptionLeft });
            }
        }
        // 放开外层容器滚动限制
        props.dragPassiveCb && props.dragPassiveCb();
    };
    // 获取到元素的宽高
    const _onLayout = (e) => {
        if (!renderOnce) {
            return;
        }
        let { height, width } = e.nativeEvent.layout;
        // console.log('_onLayout', height, width)
        setRenderOnce(false);
        setElement({ height: Number(height.toFixed()), width: Number(width.toFixed()) });
    };
    const setDragElementPos = ({ left, top }, type) => {
        var _a;
        // move触发时 && props控制不可拖拽时
        if (!props.isDragAble && type === 'move') {
            return;
        }
        if ((_a = dragableView === null || dragableView === void 0 ? void 0 : dragableView.current) === null || _a === void 0 ? void 0 : _a.setNativeProps) {
            dragableView.current.setNativeProps({ style: { left, top } });
        }
    };
    const setDragElementPosAnimated = ({ left }) => {
        var _a;
        let animateType = 'easeInEaseOut';
        const animationTypes = ['easeInEaseOut', 'linear', 'spring'];
        if (props.autoAdsorptionAnimationType && animationTypes.includes(props.autoAdsorptionAnimationType)) {
            animateType = props.autoAdsorptionAnimationType;
        }
        LayoutAnimation.configureNext(LayoutAnimation.Presets[animateType]);
        if ((_a = dragableView === null || dragableView === void 0 ? void 0 : dragableView.current) === null || _a === void 0 ? void 0 : _a.setNativeProps) {
            dragableView.current.setNativeProps({ style: { left } });
        }
    };
    const getRealLeft = (left, mode) => {
        // 屏幕中心位置横坐标
        const halfWindowWidth = windowWidth / 2;
        // 元素宽度一半
        const halfElementWidth = element.width / 2;
        // 是否是在onPanResponderRelease阶段
        const isSetOffset = typeof mode !== 'undefined' && mode === 'setOffset';
        // 水平安全区域的限制逻辑
        if (left < minAnimateXY + safeArea.left) {
            left = minAnimateXY + safeArea.left;
        }
        if (left > maxAnimateX - safeArea.right) {
            left = maxAnimateX - safeArea.right;
        }
        // 开始 《自动吸边逻辑：isAutoAdsorption》
        // 只有在开启自动吸边 并且 在onPanResponderRelease阶段才处理
        // 在onPanResponderMove为了拖拽的实时性，不处理
        // isSetOffset && console.log(left, halfElementWidth, halfWindowWidth);
        if (props.isAutoAdsorption && isSetOffset && left + halfElementWidth <= halfWindowWidth) {
            left = minAnimateXY + safeArea.left;
        }
        if (props.isAutoAdsorption && isSetOffset && left + halfElementWidth > halfWindowWidth) {
            left = maxAnimateX - safeArea.right;
        }
        // isSetOffset && console.log(left);
        // 结束 《自动吸边逻辑：isAutoAdsorption》
        return left;
    };
    const getRealTop = (top) => {
        // 竖直[树脂？-v-]安全区域的限制逻辑
        if (top < minAnimateXY + safeArea.top) {
            top = minAnimateXY + safeArea.top;
        }
        if (top > maxAnimateY - safeArea.bottom) {
            top = maxAnimateY - safeArea.bottom;
        }
        return top;
    };
    const setOffset = (left, top) => {
        left = getRealLeft(left, 'setOffset');
        setPos({ left, top: getRealTop(top) });
        return left;
    };
    const outerPanResponder = PanResponder.create({
        onStartShouldSetPanResponder: () => true,
        onStartShouldSetPanResponderCapture: () => true,
        onMoveShouldSetPanResponder: () => true,
        onMoveShouldSetPanResponderCapture: () => true,
        onPanResponderGrant: _onPanResponderGrant,
        onPanResponderMove: _onPanResponderMove,
        onPanResponderRelease: _onPanResponderRelease
    });
    const renderDebugELements = () => {
        if (!props.debugMode) {
            return null;
        }
        return (<>
          <View style={[
                styles.debugBorder,
                {
                    width: windowWidth,
                    height: windowHeight,
                    borderColor: 'red',
                }
            ]} pointerEvents={'none'}>
          </View>
          <View style={[
                styles.debugBorder,
                {
                    width: windowWidth - safeArea.left - safeArea.right,
                    height: windowHeight - safeArea.top - safeArea.bottom,
                    marginLeft: safeArea.left,
                    marginTop: safeArea.top,
                    borderColor: 'green',
                }
            ]} pointerEvents={'none'}>
            <View style={styles.line}></View>
          </View>
        </>);
    };
    return (<>
       {renderDebugELements()}
        <View style={[
            styles.wrapper,
            props.containterStyle || {},
            props.debugMode ? {
                borderColor: 'yellow',
                borderWidth: 1
            } : {}
        ]} ref={dragableView} {...outerPanResponder.panHandlers} onLayout={_onLayout}>
            {props.children}
        </View>  
      </>);
};
export default Drag;
export { Drag };
