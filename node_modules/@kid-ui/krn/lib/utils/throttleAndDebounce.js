import debounce from 'lodash.debounce';
//自定义节流函数
export function throttle(func, wait = 0, options) {
    let context, args, timeout, result;
    let previous = 0;
    if (!options)
        options = {};
    let later = function () {
        // 这里控制再次出发时，第一次是否执行，当为双false时，也是这里会出现的问题。
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    const throttled = function () {
        //@ts-ignore
        context = this;
        args = arguments;
        let now = Date.now();
        // 第一次不执行，调整previous的值即可。
        if (!previous && options.leading === false)
            previous = now;
        if (now - previous > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            // 立即执行
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            // 设置一个定时器，只有为空时才会触发，每次执行后都会重新设定一个定时器。
            timeout = setTimeout(later, wait);
        }
        return result;
    };
    throttled.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
        timeout = context = args = null;
    };
    return throttled;
}
/**
 * @description: 创建一个防抖函数，该函数延迟调用 func 直到自上次调用去抖动函数后经过等待delay毫秒。
 * @param {function} func: 需要去抖动的函数
 * @param {number} delay: 等待的时间，单位毫秒
 * @return {*}
 */
export const transformToDebounce = (func, delay) => {
    return debounce(func, delay);
};
/**
 * @description: 创建一个节流函数，每等待delay毫秒最多只调用一次func 。
 * @param {function} func: 需要节流的函数
 * @param {number} delay: 等待的时间，单位毫秒
 * @return {*}
 */
export const transformToThrottle = (func, delay) => {
    return throttle(func, delay);
};
export const transformOnPress = (func, debounceDuration, throttleDuration) => {
    if (!debounceDuration && !throttleDuration) {
        return func;
    }
    else {
        if (debounceDuration) {
            return debounce(func, debounceDuration);
        }
        if (throttleDuration) {
            return throttle(func, throttleDuration);
        }
    }
};
