import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import {Animated, NativeModules, Platform, View, ViewStyle} from 'react-native';
import { IUseDragContext, useDrag } from './useDragAndDrop';
import {
  PanGestureHandlerGestureEvent,
  LongPressGestureHandler,
  PanGestureHandler,
  State,
} from 'react-native-gesture-handler';
import { statusBarHeight } from './utils';
import { setSlideBack } from './utils';
import { RootTagContext } from './context';
import { Portal } from 'react-native-portalize';

export interface IDraggableProps {
  onChange?: (dragging: boolean) => void;
  data?: unknown;
  placeholderStyle?: ViewStyle;
  slideBackStatus?: boolean;
  fullScreen?: boolean;
}

const Draggable: React.FC<IDraggableProps> = (props) => {
  const STATUS_BAR_HEIGHT = typeof props.fullScreen !== 'undefined' ? (props.fullScreen ? 0 : statusBarHeight) : 0;
  const rootTag = useContext(RootTagContext);
  const panRef = useRef(null);
  const [startPoi, setStartPoi] = useState({ x: 0, y: 0 });
  const touchPos = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
  const [dragging, setDragging] = useState(false);
  const [slideStatus, setSlideStatus] = useState(false);
  const dndHooks = useDrag();

  const checkPoiMatch = useCallback(
    (
      evt: PanGestureHandlerGestureEvent,
      cb: {
        matchCb?: (context: IUseDragContext) => void;
        mismatchCb?: (context: IUseDragContext) => void;
        alwaysCb?: (context: IUseDragContext) => void;
      },
    ) => {
      dndHooks.forEach((currentContext) => {
        const currentPoi = currentContext.poi;
        const matchXAxis =
          evt.nativeEvent.absoluteX > currentPoi.x &&
          evt.nativeEvent.absoluteX < currentPoi.x + currentPoi.width;
        const matchYAxis =
          evt.nativeEvent.absoluteY > currentPoi.y &&
          evt.nativeEvent.absoluteY < currentPoi.y + currentPoi.height;
        if (matchXAxis && matchYAxis) {
          cb?.matchCb?.(currentContext);
        } else {
          cb?.mismatchCb?.(currentContext);
        }
        cb?.alwaysCb?.(currentContext);
      });
    },
    [dndHooks],
  );

  const handleLongPressStateChange = useCallback(
    async (evt) => {
      if (evt.nativeEvent.state === State.ACTIVE) {
        setStartPoi({ x: evt.nativeEvent.x, y: evt.nativeEvent.y });
        const x = evt.nativeEvent.absoluteX - evt.nativeEvent.x;
        const y = evt.nativeEvent.absoluteY - evt.nativeEvent.y - STATUS_BAR_HEIGHT;
        touchPos.setValue({ x, y });
        setDragging(true);
        dndHooks.forEach((hook) => {
          hook.subjects.startDrag.next(props.data);
        });
      } else if (evt.nativeEvent.state === State.END) {
        setDragging(false);
        dndHooks.forEach((hook) => hook.subjects.cancelDrag.next(true));
      }
    },
    [dndHooks],
  );

  const onPanGestureEvent = useCallback(
    (evt) => {
      if (dragging) {
        const {
          nativeEvent: { absoluteX: x, absoluteY: y },
        } = evt;
        touchPos.setValue({
          x: x - startPoi.x,
          y: y - startPoi.y - STATUS_BAR_HEIGHT,
        });
        checkPoiMatch(evt, {
          matchCb: (currentContext) => currentContext.subjects.hoverEnter.next(true),
          mismatchCb: (currentContext) => currentContext.subjects.hoverLeave.next(true),
        });
      }
      return true;
    },
    [dragging, dndHooks, checkPoiMatch],
  );

  const onPanGestureHandlerChange = useCallback(
    (evt) => {
      if (dragging && evt.nativeEvent.state === State.END) {
        setDragging(false);
        checkPoiMatch(evt, {
          matchCb: (currentContext) => currentContext.subjects.drop.next(props.data),
          alwaysCb: (currentContext) => currentContext.subjects.cancelDrag.next(true),
        });
      }
      if (evt.nativeEvent.state === State.CANCELLED) {
        setDragging(false);
        dndHooks.forEach((hook) => hook.subjects.cancelDrag.next(true));
      }
    },
    [dragging, checkPoiMatch, dndHooks],
  );


  const getSlideBackStatus = useCallback(async () => {
    let status;
    try {
      // 主站支持版本：10.0.10
      // 真实存在的bridge，type缺失。
      // TODO: https://team.corp.kuaishou.com/task/T2585750  【bridge双端未对齐，待处理】
      // @ts-ignore
      status = await NativeModules.KRNBasic.getSlideBack(Platform.OS === 'android' ? { rootTag } : rootTag);
    } catch (e) {
      status = props.slideBackStatus;
    }
    setSlideStatus(status);
  }, [props.slideBackStatus]);

  useEffect(() => {
    getSlideBackStatus();
  }, []);

  useEffect(() => {
    props?.onChange?.(dragging);
    const slideBackStatus = dragging ? false : slideStatus;
    setSlideBack(slideBackStatus, rootTag);
  }, [dragging, slideStatus]);

  return (
    <LongPressGestureHandler
      minDurationMs={400}
      maxDist={20}
      simultaneousHandlers={panRef}
      onHandlerStateChange={handleLongPressStateChange}
    >
      <PanGestureHandler
        activeOffsetX={dragging ? 5 : [-10000, 10000]}
        activeOffsetY={dragging ? 5 : [-10000, 10000]}
        ref={panRef}
        onGestureEvent={onPanGestureEvent}
        onHandlerStateChange={onPanGestureHandlerChange}
      >
        <View testID='drag-container'>
          {dragging ? (
            <View style={props.placeholderStyle}>
              <Portal>
                <Animated.View
                  style={[
                    {
                      transform: touchPos.getTranslateTransform(),
                    },
                  ]}
                >
                  {props.children}
                </Animated.View>
              </Portal>
            </View>
          ) : (
            <View>{props.children}</View>
          )}
        </View>
      </PanGestureHandler>
    </LongPressGestureHandler>
  );
};

export default Draggable;
