import { KidLetterIndexes } from '../letter-indexes';
import React, { useRef, useMemo, useEffect, useState, useCallback, forwardRef, useImperativeHandle } from 'react';
import {
    View,
    SectionList,
    Modal,
    TouchableWithoutFeedback,
    Text,
    Animated,
    UIManager,
    Platform,
    LayoutAnimation,
    StyleProp,
    ViewStyle
} from 'react-native';
import getStyles, { canShowLetter, maxHeight, noLetterMaxHeight } from './style';
import SectionListHeader, { headerHeight } from './city-selector-header';
import SectionListContent, { itemHeight, itemMarginBottom, itemWrapperMarginTop, itemWrapperMarginBottom } from './city-selector-item';
import { ShowWithData, windowHeight, isIOS, UIUtils } from './utils';
import { rem } from '../../utils';
import { useKidColor } from '../../theme/useKidColor';
if (Platform.OS === 'android') {
    if (UIManager.setLayoutAnimationEnabledExperimental) {
        UIManager.setLayoutAnimationEnabledExperimental(true);
    }
}

export interface citySelecterItemObjectT {
    text: string,
    [key: string]: any;
}
interface citySelecterDataT {
    letter: string;
    cityName: string[] | citySelecterItemObjectT[];
}
interface propsT {
    // 是否可见，业务控制
    visible: boolean;
    // 动画时间，默认300ms
    animationTime?: number;
    // 当前城市名字，回显使用
    cityName: string;
    // 是否显示右侧字母筛选，当打开时：固定选择器高度550，关闭时：最大高度为0.7总高
    isShowLetter: boolean;
    // 数据，必须为citySelecterDataT形式
    data: citySelecterDataT[];
    // 切换选择的城市回调
    onCityNameChange: (cityName: string | citySelecterItemObjectT) => void;
    // 关闭选择器回调
    onClose: (showFlag: boolean) => void;
    // 选择器自定义header
    renderLocationHeader?: () => React.ComponentType<any> | React.ReactElement | null;
    //选择器自定义footer
    renderLocationFooter?: () => React.ComponentType<any> | React.ReactElement | null;
    //选择器位置
    position?: 'top' | 'bottom',
    //自定义顶部
    renderTop?: () => React.ComponentType<any> | React.ReactElement | null;
    //自定义顶部样式
    topStyle?: StyleProp<ViewStyle>
    //自定义底部
    renderBottom?: () => React.ComponentType<any> | React.ReactElement | null;
    //自定义底部样式
    bottomStyle?: StyleProp<ViewStyle>
}
const maxLetterCount: number = 26;

// 根据屏幕剩余高度计算出需要设置的initialNumToRender，需要在渲染前需要计算出
const getInitialNumToRender = () => {
    const sectionItemHeight = itemHeight + itemMarginBottom;
    const singleItemHeight = headerHeight + sectionItemHeight + itemWrapperMarginTop + itemWrapperMarginBottom;
    const maxSingleItemCount = Math.ceil(noLetterMaxHeight / singleItemHeight);
    // renderItem + renderSectionHeader + renderSectionFooter
    return maxSingleItemCount * 3
}
const initialNumToRender = getInitialNumToRender();
// console.log('当前InitialNumToRender:', initialNumToRender)

export const CitySelector = forwardRef((props: propsT, ref: any) => {
    const { animationTime = 300, position = 'bottom' } = props;
    const section: any = useRef(null);
    const [letterShow, setLetterShow] = useState(false);
    const [innerVisible, setInnerVisible] = useState(false);

    useImperativeHandle(ref, () => ({
        close: (cb?: Function) => {
            slideOutFromBottom(() => {
                cb && cb();
            });
        }
    }))

    const slideInAnimateValue = useRef(new Animated.Value(1)).current;
    const [contentHeight, setContentHeight] = useState(maxHeight); // 首屏渲染，在获取到正确的宽高之前，先把弹窗内容移到屏幕外，防止闪烁
    const [bottomHeight, setBottomHeight] = useState(0);
    const [topHeight, setTopHeight] = useState(0);
    const stopAnimation = useCallback(() => {
        slideInAnimateValue.stopAnimation();
    }, [slideInAnimateValue]);

    const animateEndCallback = useCallback(() => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
        setInnerVisible(false);
    }, []);

    useEffect(() => {
        setContentHeight(maxHeight);
    }, [props.data])

    useEffect(() => {
        setLetterShow(canShowLetter && props.isShowLetter);
    }, [props.isShowLetter])

    const styles = getStyles(letterShow);

    const slideInFromTop = useCallback(() => {
        // console.log("slideInFromTop")
        stopAnimation();
        Animated.timing(slideInAnimateValue, {
            toValue: 0,
            duration: animationTime,
            useNativeDriver: true,
        }).start();
    }, [slideInAnimateValue, animationTime]);

    const slideOutFromBottom = useCallback((cb?: Function) => {
        stopAnimation();
        Animated.timing(slideInAnimateValue, {
            toValue: 1,
            duration: animationTime,
            useNativeDriver: true,
        }).start(() => {
            animateEndCallback()
            cb && cb();
        });
    }, [slideInAnimateValue, animationTime])

    const filterData = (item: citySelecterDataT, index: number) => {
        return index < maxLetterCount && item && item.letter && item.cityName && item.cityName.length;
    }

    const realData = useMemo(() => {
        return props.data.filter(filterData).map((item) => ({
            title: item.letter,
            data: [item.cityName],
        }));
    }, [props.data]);

    const letterList = useMemo(() => {
        return props.data.filter(filterData).map((item) => item.letter);
    }, [props.data]);

    useEffect(() => {
        if (props.visible) {
            LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut)
            setInnerVisible(true);
        }
    }, [props.visible])

    const _onlayout = (e: any) => {
        const { height } = e.nativeEvent.layout;
        // console.log("_onlayout height:", height);
        setContentHeight(height);
        if (props.visible) {
            slideInFromTop();
        }
    }

    const sectionItemOnChange = useCallback((item: string | citySelecterItemObjectT) => {
        slideOutFromBottom(() => {
            props?.onCityNameChange!(item);
        });
    }, [props.onCityNameChange])

    const onClose = useCallback(() => {
        slideOutFromBottom(() => {
            props?.onClose!(false);
        });
    }, [])

    const backgroundColor = useKidColor('cs_common_background_float_primary');

    return (
        <ShowWithData data={innerVisible}>
            <Modal
                transparent={true}
                visible={true}
                animationType={'none'}
                onRequestClose={onClose}
            >
                {position === 'top' && (
                    <TouchableWithoutFeedback
                        onPress={onClose}
                    >
                        <View style={styles.closeArea}></View>
                    </TouchableWithoutFeedback>
                )}
                <View style={styles.mask}>
                    {position === 'bottom' && (
                        <TouchableWithoutFeedback onPress={onClose}>
                            <View style={{ flex: 1 }} />
                        </TouchableWithoutFeedback>
                    )}
                    <Animated.View
                        style={[
                            {
                                transform: [
                                    {
                                        translateY: slideInAnimateValue.interpolate({
                                            inputRange: [0, 1],
                                            outputRange: position === 'bottom' ? [0, windowHeight] : [0, -contentHeight-bottomHeight-topHeight],
                                        }),
                                    }
                                ],
                                backgroundColor,
                                borderTopLeftRadius: position === 'bottom' ? rem(12) : 0,
                                borderTopRightRadius: position === 'bottom' ? rem(12) : 0,
                                borderBottomRightRadius: position === 'top' ? rem(12) : 0,
                                borderBottomLeftRadius: position === 'top' ? rem(12) : 0,
                                paddingBottom: position === 'bottom' ? UIUtils.getBottomBarHeight() : 0,
                            }
                        ]}
                    >
                        {props.renderTop && (
                            <View
                                style={[
                                    styles.top,
                                    props.topStyle!
                                ]}
                                onLayout={(e: any) => {
                                    const {height} = e.nativeEvent.layout;
                                    setTopHeight(height);
                                }}
                            >
                                {props.renderTop()}
                            </View>
                        )}
                        <View style={styles.banner}>
                            <ShowWithData data={realData.length}>
                                <SectionList
                                    ref={section}
                                    onLayout={_onlayout}
                                    bounces={false}
                                    style={styles.cityInfo}
                                    showsVerticalScrollIndicator={false}
                                    sections={realData}
                                    initialNumToRender={initialNumToRender}
                                    keyExtractor={(item) => item.toString()}
                                    contentContainerStyle={styles.SectionListContainer}
                                    renderItem={({ item }) => (
                                        <SectionListContent
                                            item={item}
                                            cityName={props.cityName}
                                            onChange={sectionItemOnChange}
                                        />
                                    )}
                                    ListHeaderComponent={props.renderLocationHeader ? props.renderLocationHeader() : (null)}
                                    ListFooterComponent={props.renderLocationFooter ? props.renderLocationFooter() : (null)}
                                    renderSectionHeader={({
                                        section: { title },
                                    }) => <SectionListHeader title={title} />}
                                />
                            </ShowWithData>
                            <ShowWithData data={!realData.length}>
                                <View style={styles.noData}>
                                    <Text>无更多城市</Text>
                                </View>
                            </ShowWithData>
                            <ShowWithData data={letterShow}>
                                <View style={styles.letterSelector}>
                                    <KidLetterIndexes
                                        data={letterList}
                                        indexNum={0}
                                        indexSpace={3}
                                        indexHeight={15}
                                        indexSelectedRadius={15}
                                        onChange={(index) => {
                                            if (section.current) {
                                                section.current.scrollToLocation({
                                                    sectionIndex: index,
                                                    itemIndex: 0,
                                                });
                                            }
                                        }}
                                    />
                                </View>
                            </ShowWithData>
                        </View>
                        {props.renderBottom && (
                            <View
                                style={[
                                    styles.bottom,
                                    props.bottomStyle!
                                ]}
                                onLayout={(e: any) => {
                                    const {height} = e.nativeEvent.layout;
                                    setBottomHeight(height);
                                }}
                            >
                                {props.renderBottom()}
                            </View>
                        )}
                    </Animated.View>
                    {position === 'top' && (
                        <TouchableWithoutFeedback onPress={onClose}>
                            <View style={{ flex: 1 }} />
                        </TouchableWithoutFeedback>
                    )}
                </View>
            </Modal>
        </ShowWithData>
    );
})
