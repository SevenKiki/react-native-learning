import * as React from 'react';
import {
    Animated,
    StyleSheet,
    View,
    ScrollView,
    StyleProp,
    ViewStyle,
    TextStyle,
    LayoutChangeEvent,
    UIManager,
    NativeSyntheticEvent,
    NativeScrollEvent,
} from 'react-native';
import TabBarItem, { Props as TabBarItemProps } from './TabBarItem';
import TabBarIndicator, { Props as IndicatorProps } from './TabBarIndicator';
import type {
    Route,
    Scene,
    SceneRendererProps,
    NavigationState,
    Layout,
    Event,
} from '../tab-view/types';
import debounce from 'lodash.debounce';
import { throttle } from '../../utils';

export type Props<T extends Route> = SceneRendererProps & {
    navigationState: NavigationState<T>;
    scrollEnabled?: boolean;
    bounces?: boolean;
    activeColor?: string;
    inactiveColor?: string;
    pressColor?: string;
    pressOpacity?: number;
    getLabelText: (scene: Scene<T>) => string | undefined;
    getAccessible: (scene: Scene<T>) => boolean | undefined;
    getAccessibilityLabel: (scene: Scene<T>) => string | undefined;
    getTestID: (scene: Scene<T>) => string | undefined;
    renderLabel?: (
        scene: Scene<T> & {
            focused: boolean;
            color: string;
        },
    ) => React.ReactNode;
    renderIcon?: (
        scene: Scene<T> & {
            focused: boolean;
            color: string;
        },
    ) => React.ReactNode;
    renderBadge?: (scene: Scene<T>) => React.ReactNode;
    renderIndicator: (props: IndicatorProps<T>) => React.ReactNode;
    renderTabBarItem?: (
        props: TabBarItemProps<T> & { key: string },
    ) => React.ReactElement;
    onTabPress?: (scene: Scene<T> & Event) => void;
    onTabLongPress?: (scene: Scene<T>) => void;
    onTabBarItemsLayoutChange?: (routes: T[]) => void; // TabBar 可视区范围内的Items发生改变时触发回调，参数routes表示可视区内的TabBar Item所指向的route集合
    shownPercent?: number // TabBar Item在该百分比以上的部分暴露在可视区时，才在onTabBarItemsLayoutChange时上报
    tabItemStyle?: StyleProp<ViewStyle>; // TabBar Item的样式
    tabItemActiveStyle?: StyleProp<ViewStyle>;// TabBar Item选中时的样式
    lastTabItemStyle?: StyleProp<ViewStyle>;// TabBar Item最后一项的样式
    firstTabItemStyle?: StyleProp<ViewStyle>;// TabBar Item第一项的样式
    indicatorStyle?: StyleProp<ViewStyle>; // 指示器的样式
    indicatorWidth?: number;
    enableIndicatorAnimate?: boolean; // 是否开启指示器的动画
    labelStyle?: StyleProp<TextStyle>;
    contentContainerStyle?: StyleProp<ViewStyle>;
    style?: StyleProp<ViewStyle>;
    tabBarContainerStyle?: StyleProp<ViewStyle>; // TabBar 容器的样式
    tabBarScrollViewStyle?: StyleProp<ViewStyle>; // TabBar 容器中 ScrollView 的样式
    tabBarScrollViewContentStyle?: StyleProp<ViewStyle>; // TabBar 容器中 ScrollView 内容区域的样式，设置到 contentContainerStyle 属性
    autoCenter?: boolean; // TabBar Item 项是否按文本宽度自适应,为false时自适应开启
    dividerColor?: string; // TabBar 分割线颜色
    showBottomShadow?: boolean; // TabBar 是否展示底部阴影
    tabItemTextStyle?: StyleProp<TextStyle>; // 设置 tabItem 文字的样式
    tabItemActiveTextStyle?: StyleProp<TextStyle>; // 设置 tabItem active文字的样式
    tabItemActiveStyleMode?: 'enlarge' | 'normal'; // 当前聚焦 tabBarItem 的样式模式，enlarge 表示放大，例如设置了 tabItemActiveTextStyle 使字体变大、加粗等，normal 表示不变或缩小，默认值为 normal
    controlType?: 'normal' | 'debounce' | 'throttle'; //切换tabbar的类型，选择debounce表示防抖，选择throttle表示节流
    controlDuration?: number; //控制防抖或者节流的时长
    openPageAnimate?: boolean; // 是否开启切换动画
};

type State = {
    opacity: number;
    tabWidth: number;
    tabWidths: { [key: string]: number };
    showIndicator: boolean;
    itemWidth: number | undefined;
};

export default class TabBar<T extends Route> extends React.Component<
    Props<T>,
    State
> {
    static defaultProps = {
        autoCenter: true,
        getLabelText: ({ route }: Scene<Route>) => route.title,
        getAccessible: ({ route }: Scene<Route>) =>
            typeof route.accessible !== 'undefined' ? route.accessible : true,
        getAccessibilityLabel: ({ route }: Scene<Route>) =>
            typeof route.accessibilityLabel === 'string'
                ? route.accessibilityLabel
                : typeof route.title === 'string'
                    ? route.title
                    : undefined,
        getTestID: ({ route }: Scene<Route>) => route.testID,
        renderIndicator: (props: IndicatorProps<Route>) => (
            <TabBarIndicator {...props} />
        ),
        controlType: 'normal',
        controlDuration: 0
    };

    state: State = {
        opacity: 0,
        tabWidth: 0,
        tabWidths: {},
        itemWidth: undefined,
        showIndicator: false,
    };

    layout: Layout | null = null;
    contentLayout: Layout | null = null;
    centerPointArr: number[] = [];

    constructor(props: Props<T>) {
        super(props);
        this.debounceJump = this.debounceJump.bind(this);
        this.throttleJump = this.throttleJump.bind(this);
        this.jump = this.jump.bind(this);
        this.onMomentumScrollBegin = this.onMomentumScrollBegin.bind(this);
        this.onTabBarScroll = this.onTabBarScroll.bind(this);
        this.handleMeasuredTabsPos = this.handleMeasuredTabsPos.bind(this);
        this.getInScenceRoutes = this.getInScenceRoutes.bind(this);
    }

    debounceJump: (path: string) => void = debounce((path: string) => {
        this.props.jumpTo(path);
    }, this.props.controlDuration)

    throttleJump: (path: string) => void = throttle((path: string) => {
        this.props.jumpTo(path);
    }, this.props.controlDuration)

    jump: (path: string) => void = (path: string) => {
        if (this.props.controlType === 'debounce') {
            this.debounceJump(path);
        } else if (this.props.controlType === 'throttle') {
            this.throttleJump(path);
        } else {
            this.props.jumpTo(path);
        }
    }

    componentDidUpdate(prevProps: Props<T>, preState: State) {
        const { navigationState, controlType } = this.props;
        if (
            prevProps.navigationState.routes.length !==
            navigationState.routes.length ||
            prevProps.navigationState.index !== navigationState.index
        ) {
            this.resetScroll(navigationState.index);
        }
    }

    // to store the layout.width of each tab
    // when all onLayout's are fired, this would be set in state
    private measuredTabWidths: { [key: string]: number } = {};
    private measuredTabsPos: Array<{ start: number, end: number }> = [];
    private tabBarScrollTime: any = null;
    private itemLayoutTime: any = null;
    private scrollX: number = 0;

    private scrollAmount = new Animated.Value(0);

    private scrollViewRef = React.createRef<ScrollView>();

    onItemLayout(e: any, route: Route, index: number) {
        const width = e.nativeEvent.layout.width;
        let start = 0, end = width;
        if (index > 0 && this.measuredTabsPos[index - 1]?.start && this.measuredTabsPos[index - 1]?.end) {
            start = this.measuredTabsPos[index - 1].end;
            end = start + width;
        }
        this.measuredTabsPos[index] = { start, end };

        clearTimeout(this.itemLayoutTime);
        this.itemLayoutTime = null;
        this.itemLayoutTime = setTimeout(() => {
            if (this.measuredTabsPos.every(pos => pos.start === 0)) {
                const { onTabBarItemsLayoutChange } = this.props;
                this.handleMeasuredTabsPos();
                const inScenceRoute: T[] = [];
                this.getInScenceRoutes(inScenceRoute, this.scrollX, this.layout?.width!);
                onTabBarItemsLayoutChange && onTabBarItemsLayoutChange(inScenceRoute)
            }
        }, 100)


        // 如果固定高度，不需要用事件的高度
        if (this.state.itemWidth) {
            return;
        }
        this.measuredTabWidths[route.key] = width;
        if (!this.state.showIndicator) {
            this.checkReady();
        }
    }

    onMomentumScrollBegin() {
        clearTimeout(this.tabBarScrollTime);
        this.tabBarScrollTime = null;
    }

    handleMeasuredTabsPos() {
        const _measuredTabsPos: Array<{ start: number, end: number }> = []
        this.measuredTabsPos.forEach((pos, index) => {
            if (index) {
                let { start, end } = pos;
                const { start: _start, end: _end } = _measuredTabsPos[index - 1];
                start = _end;
                end = _end + end;
                _measuredTabsPos.push({ start, end });
            } else {
                _measuredTabsPos.push(pos)
            }
        })

        this.measuredTabsPos = _measuredTabsPos;
    }

    getInScenceRoutes(inScenceRoute: T[], x: number, width: number): void {
        const { shownPercent = 0.5 } = this.props;
        const percent = Math.min(1, Math.max(0, shownPercent));
        
        let idx = -1;
        this.measuredTabsPos.forEach((pos, index) => {
            if (pos.end > x && pos.start < x + width) {
                if (idx < 0) {
                    if ((pos.end - x) / (pos.end - pos.start) >= percent) {
                        inScenceRoute.push(this.props.navigationState.routes[index])
                    }
                } else {
                    inScenceRoute.push(this.props.navigationState.routes[index])
                }
                idx = index;
            }
        })
        if (this.measuredTabsPos[idx]) {
            const { start, end } = this.measuredTabsPos[idx];
            if ((x + width - start) / (end - start) < percent) {
                inScenceRoute.pop();
            }
        }
    }

    onTabBarScroll(e: NativeSyntheticEvent<NativeScrollEvent>) {
        const { onTabBarItemsLayoutChange } = this.props;
        const { width } = e.nativeEvent.layoutMeasurement;
        const { x } = e.nativeEvent.contentOffset;
        const inScenceRoute: T[] = [];
        this.getInScenceRoutes(inScenceRoute, x, width);
        this.tabBarScrollTime = setTimeout(() => {
            onTabBarItemsLayoutChange && onTabBarItemsLayoutChange(inScenceRoute)
        }, 50)
    }

    private getScrollAmount = (index: number) => {
        if (!this.layout || !this.contentLayout) {
            return;
        }
        if (this.layout.width >= this.contentLayout.width) {
            return;
        }
        if (!this.centerPointArr.length) {
            return;
        }
        const indexInt = index | 0;
        const percent = index - indexInt;
        let centerPosition = this.centerPointArr[indexInt];
        if (this.centerPointArr[indexInt + 1] && percent) {
            centerPosition +=
                percent * (this.centerPointArr[indexInt + 1] - centerPosition);
        }
        const halfWidth = this.layout.width / 2;
        if (centerPosition < halfWidth) {
            return 0;
        } else if (this.contentLayout.width - centerPosition < halfWidth) {
            return this.contentLayout.width - this.layout.width;
        } else {
            return centerPosition - halfWidth;
        }
    };

    private resetScroll = (index: number) => {
        if (this.props.scrollEnabled) {
            this.scrollViewRef.current?.scrollTo({
                x: this.getScrollAmount(index),
                animated: !this.props.openPageAnimate, // 关闭 openPageAnimate 时，需要开启动画，否则 tabBar Indiacator 会闪烁
            });
        }
    };

    componentDidMount() {
        // @ts-expect-error
        this.props.position.addListener(({ value }) => {
            this.resetScroll(value);
        });
    }

    componentWillUnmount() {
        clearTimeout(this.tabBarScrollTime);
        this.tabBarScrollTime = null;

        clearTimeout(this.itemLayoutTime);
        this.itemLayoutTime = null;
    }

    private handleLayout = (e: LayoutChangeEvent) => {
        const { height, width } = e.nativeEvent.layout;
        // ios有时width为0
        if (width) {
            this.layout = { height, width };
            this.checkReady();
        } else {
            // @ts-expect-error
            UIManager.measure(e.nativeEvent?.target, (x, y, width, height) => {
                this.layout = { height, width };
                this.checkReady();
            });
        }

    };

    private onContentSizeChange = (width: number, height: number) => {
        this.contentLayout = { height, width };
        this.checkReady();
    };

    checkReady() {
        if (!this.contentLayout || !this.layout) {
            return;
        }

        const {
            navigationState: { routes },
        } = this.props;

        if (this.props.autoCenter) {
            if (this.layout.width > this.contentLayout.width) {
                this.contentLayout = null;
                const itemWidth = this.layout.width / routes.length;
                this.setState(
                    {
                        itemWidth,
                    },
                    () => {
                        this.checkReady();
                    },
                );
                return;
            }
        }
        if (
            !this.state.itemWidth &&
            routes.some((route) => {
                return !this.measuredTabWidths[route.key];
            })
        ) {
            return;
        }
        if (this.state.itemWidth) {
            const measuredTabWidths: { [key: string]: number } = {};
            routes.forEach((route) => {
                measuredTabWidths[route.key] = this.state.itemWidth as number;
            });
            this.measuredTabWidths = measuredTabWidths;
        }
        this.setState(
            {
                opacity: 1,
                showIndicator: true,
                tabWidth: this.layout.width,
                tabWidths: this.measuredTabWidths,
            },
            () => {
                // @ts-expect-error
                this.resetScroll(this.props.position.__getValue());
            },
        );
        let sumHeight = 0;
        const paddingSize = 14;
        const measuredTabWidths = this.measuredTabWidths;
        this.centerPointArr = routes.reduce<number[]>((acc, _, i) => {
            const lastSum = sumHeight;
            sumHeight += measuredTabWidths[_.key];
            let widthFix = 0;
            if (i === 0) {
                widthFix = -paddingSize;
            } else if (i === routes.length - 1) {
                widthFix = paddingSize;
            }
            return [
                ...acc,
                lastSum + (measuredTabWidths[_.key] + widthFix) / 2,
            ];
        }, []);
    }

    render() {
        const {
            position,
            navigationState,
            jumpTo,
            scrollEnabled,
            bounces,
            getAccessibilityLabel,
            getAccessible,
            dividerColor,
            getLabelText,
            getTestID,
            // 控制分割线是否展示
            renderBadge = () => (<View style={{ width: 1, height: '50%', backgroundColor: dividerColor }}></View>),
            renderIcon,
            openPageAnimate,
            renderLabel,
            renderTabBarItem,
            activeColor,
            inactiveColor,
            pressColor,
            pressOpacity,
            onTabPress,
            onTabLongPress,
            tabItemStyle,
            labelStyle,
            indicatorStyle,
            indicatorWidth,
            enableIndicatorAnimate,
            showBottomShadow,
            tabItemTextStyle,
            tabItemActiveTextStyle,
            tabItemActiveStyleMode,
            tabItemActiveStyle,
            lastTabItemStyle,
            firstTabItemStyle,
            // contentContainerStyle,
            tabBarContainerStyle,
            tabBarScrollViewStyle,
            tabBarScrollViewContentStyle,
            style,
        } = this.props;
        const { tabWidths, tabWidth, showIndicator, itemWidth, opacity } =
            this.state;
        const { routes } = navigationState;
        let tabWidthsReady = true
        routes.forEach(item => {
            if (!tabWidths[item.key]) {
                tabWidthsReady = false
            }
        })

        return (
            <View style={[styles.tabBar, showBottomShadow ? styles.tabShadow : {}, { opacity }, style, tabBarContainerStyle]}>
                <Animated.ScrollView
                    //@ts-expect-error
                    style={tabBarScrollViewStyle}
                    onLayout={this.handleLayout}
                    onContentSizeChange={this.onContentSizeChange}
                    horizontal
                    accessibilityRole="tablist"
                    keyboardShouldPersistTaps="handled"
                    scrollEnabled={scrollEnabled}
                    bounces={bounces}
                    alwaysBounceHorizontal={false}
                    scrollsToTop={false}
                    showsHorizontalScrollIndicator={false}
                    automaticallyAdjustContentInsets={false}
                    overScrollMode="never"
                    contentContainerStyle={[styles.tabContent, tabBarScrollViewContentStyle]}
                    scrollEventThrottle={16}
                    onScroll={Animated.event(
                        [
                            {
                                nativeEvent: {
                                    contentOffset: { x: this.scrollAmount },
                                },
                            },
                        ],
                        {
                            useNativeDriver: true,
                            listener: (e: NativeSyntheticEvent<NativeScrollEvent>) => {
                                if (!this.scrollX) {
                                    this.scrollX = e.nativeEvent.contentOffset.x;
                                }
                            }
                        },
                    )}
                    onScrollEndDrag={this.onTabBarScroll}
                    onMomentumScrollBegin={this.onMomentumScrollBegin}
                    onMomentumScrollEnd={this.onTabBarScroll}
                    ref={this.scrollViewRef}>
                    <View pointerEvents="none" style={styles.indicator}>
                        {showIndicator && tabWidthsReady &&
                            this.props.renderIndicator({
                                position,
                                // @ts-expect-error
                                layout: null,
                                // fixPadding: !itemWidth,
                                navigationState,
                                jumpTo,
                                tabWidths,
                                tabWidth,
                                style: indicatorStyle,
                                indicatorWidth: indicatorWidth!,
                                enableIndicatorAnimate: enableIndicatorAnimate!
                            })}
                    </View>
                    {routes.map((route: T, index: number) => {
                        const isLastItem = index === (routes.length - 1)
                        const isFirstItem = index === 0
                        const props: TabBarItemProps<T> & { key: string } = {
                            isLastItem,
                            isFirstItem,
                            key: route.key,
                            position,
                            route: route,
                            itemWidth,
                            navigationState: navigationState,
                            getAccessibilityLabel: getAccessibilityLabel,
                            getAccessible: getAccessible,
                            getLabelText: getLabelText,
                            getTestID: getTestID,
                            renderBadge: renderBadge,
                            renderIcon: renderIcon,
                            openPageAnimate: openPageAnimate,
                            onLayout: (e) => this.onItemLayout(e, route, index),
                            renderLabel: renderLabel,
                            activeColor: activeColor,
                            inactiveColor: inactiveColor,
                            pressColor: pressColor,
                            pressOpacity: pressOpacity,
                            onPress: () => {
                                const event: Scene<T> & Event = {
                                    route,
                                    defaultPrevented: false,
                                    preventDefault: () => {
                                        event.defaultPrevented = true;
                                    },
                                };
                                onTabPress?.(event);

                                if (event.defaultPrevented) {
                                    return;
                                }

                                this.jump(route.key);
                            },
                            onLongPress: () => onTabLongPress?.({ route }),
                            labelStyle: labelStyle,
                            style: tabItemStyle,
                            tabItemActiveStyle: tabItemActiveStyle,
                            lastTabItemStyle: lastTabItemStyle,
                            firstTabItemStyle: firstTabItemStyle,
                            tabItemTextStyle: tabItemTextStyle,
                            tabItemActiveTextStyle: tabItemActiveTextStyle,
                            tabItemActiveStyleMode,
                        };

                        return renderTabBarItem ? (
                            renderTabBarItem(props)
                        ) : (
                            <TabBarItem {...props} />
                        );
                    })}
                </Animated.ScrollView>
            </View>

        );
    }
}

const styles = StyleSheet.create({
    tabBar: {
        backgroundColor: '#0b0b0b',
        zIndex: 1,
        flexGrow: 0,
    },
    tabShadow: {
        elevation: 4,
        shadowColor: 'black',
        shadowOpacity: 0.1,
        shadowRadius: StyleSheet.hairlineWidth,
        shadowOffset: {
            height: StyleSheet.hairlineWidth,
            width: 0,
        },
    },
    tabContent: {
        flexDirection: 'row',
        flexWrap: 'nowrap',
    },
    indicator: {
        overflow: 'hidden',
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        top: 0,
    },
});
