import * as React from 'react';
import {
    Animated,
    StyleSheet,
    I18nManager,
    StyleProp,
    ViewStyle
} from 'react-native';

import type {
    Route,
    SceneRendererProps,
    NavigationState,
} from '../tab-view/types';

export type GetTabWidth = (index: number) => number;

export type Props<T extends Route> = SceneRendererProps & {
    navigationState: NavigationState<T>;
    style?: StyleProp<ViewStyle>;
    tabWidths: Record<string, number>;
    tabWidth: number;
    fixPadding: boolean;
    indicatorWidth: number;
    enableIndicatorAnimate: boolean;
};

const paddingSize = 14;
export default class TabBarIndicator<T extends Route> extends React.Component<
    Props<T>
> {
    state={
        translateXWithOutAni: new Animated.Value(0)
    }
    private getTranslateX = (
        position: Animated.AnimatedInterpolation,
        routes: Route[],
        tabWidths : Record<string, number>,
        fixPadding: boolean,
        indicatorWidth: number,
        index: number,
        enableIndicatorAnimate: boolean
    ) => {
        const inputRange = routes.map((_, i) => i);

        let sumHeight = 0;
        // every index contains widths at all previous indices
        const outputRange = routes.reduce<number[]>((acc, _, i) => {
            const lastSum = sumHeight;
            sumHeight += tabWidths[_.key];

            let widthFix = 0;
            if (fixPadding) {
                if (i === 0) {
                    widthFix = -paddingSize;
                } else if (i === routes.length - 1) {
                    widthFix = paddingSize;
                }
            }
            return [
                ...acc,
                lastSum + (tabWidths[_.key] - indicatorWidth + widthFix) / 2,
            ];
        }, []);        

        if (!enableIndicatorAnimate){
            // 指示器不开启动画时返回普通类型的值
            return outputRange[index]
        }
            const translateX = position.interpolate({
                inputRange,
                outputRange,
                extrapolate: 'clamp',
            });
            
            return Animated.multiply(translateX, I18nManager.isRTL ? -1 : 1);
    };
     render() {
        const { position, navigationState, tabWidths, style, fixPadding, indicatorWidth, enableIndicatorAnimate } =
            this.props;
        const { routes, index } = navigationState;

        const transform = [];

        const translateX =
          routes.length > 1
            ? this.getTranslateX(position, routes, tabWidths, fixPadding, indicatorWidth, index , enableIndicatorAnimate)
            : (tabWidths[routes[0].key] - indicatorWidth) / 2;
        transform.push({ translateX });

        if(!enableIndicatorAnimate){
            // 没有动画通过返回的普通类型translateX并设置duration为0
            Animated.timing(
            this.state.translateXWithOutAni,
            {
                toValue: translateX,
                duration: 0,
                useNativeDriver: true
            }       
            ).start();            
        }

        return (
            enableIndicatorAnimate?
            (<Animated.View style={[styles.indicator, { transform }, style]}>
            </Animated.View>) :
            (<Animated.View style={[styles.indicator, { transform:[{translateX:this.state.translateXWithOutAni}] }, style]} />)
        );
    }
}

const styles = StyleSheet.create({
    indicator: {
        position: 'absolute',
        left: 0,
        bottom: 5,
        height: 2,
        borderRadius:1,
    },
});
