import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';
import {
    View,
    Text,
    TouchableOpacity,
    Animated,
    Easing,
    Dimensions,
    Platform,
    StyleSheet,
    LayoutChangeEvent
} from 'react-native';
import { KidIcon } from '../icon/index';
import { NoticeType } from './type';
import { rem } from '../../utils';

export interface NoticeBarProps {
    type?: NoticeType; // 主题样式
    mode?: 'closeable' | 'link' | ''; // 通知栏模式，可选值为 closeable link
    text: string | string[]; // 通告栏内容
    color?: string; // 所有文字和 icon 图标的颜色,样式优先级高于 type
    backgroundColor?: string; // NoticeBar背景的颜色,样式优先级高于 type
    borderRadius?: number; // 圆角展示
    scrollable?: boolean; // 内容超出滚动展示
    wrapable?: boolean; // 是否开启文本换行，只在禁用滚动时候生效
    speed?: number; // 滚动速率(px/s)
    delay?: number; // 动画延迟/停留时间（ms）
    leftIconKid?: string; // 左侧图标名称，等同于Icon组件的kid属性，使用 renderLeftArea 自定义左侧区域时不生效
    renderLeftArea?: () => React.ReactNode; // 自定义左侧区域
    rightAreaText?: string; // 右侧文字，仅在 mode 为 'closeable' | 'link'，且不使用 renderRightArea 自定义右侧区域时生效；mode 为 closeable 时，会替换掉关闭图标，mode 为 link 时，则会添加到链接图标的左侧
    renderRightArea?: () => React.ReactNode; // 自定义右侧区域
    direction?: 'left' | 'right' | 'up' | 'down'; // 滚动方向(当scrollable为true时生效)，水平方向的滚动只支持单条数据，竖直方向支持多条
    onPressRightArea?: () => void; // 点击右侧操作区时触发的回调,使用 renderRightArea 自定义右侧区域时不生效
    onPress?: () => void; // 点击通告栏内容区域时触发的回调
    horizontalSpacing?: number; // 横向滚动，两条之间的距离
}
const notice_bar_size_height = rem(40);

const icon_size = rem(16);
const text_color = {
    default: '#FE3666',
    safe: '#326BFB',
    error: '#FA4E3E',
    warning: '#FF8048',
};
const bg_color = {
    default: '#FFEEF2',
    safe: '#F0F7FF',
    error: '#FFF4F0',
    warning: '#FFF2EC',
};
const RIGHT_ICON = {
    more: 'common_base_next_24',
    close: 'common_base_close_24',
};

const secondToMillisecondConvert = 1000; // 秒转成毫秒，乘以的倍数
const SCREEN_WIDTH = Dimensions.get('window').width;

const NoticeBar: React.FC<NoticeBarProps> = ({
    type = 'default',
    mode = '',
    text,
    direction = 'left',
    delay = 1000,
    scrollable: _scrollable = false,
    speed = 40,
    rightAreaText = '',
    leftIconKid = '',
    backgroundColor = '',
    color = '',
    borderRadius = 0,
    wrapable = false,
    onPressRightArea = () => { },
    onPress = () => { },
    renderLeftArea,
    renderRightArea,
    horizontalSpacing = rem(100)
}) => {
    let verticalTimer = useRef<any>(null); // 垂直滚动的定时器

    const [state, setState] = useState({
        show: true, // 通告栏是否展示

        showHorizontalClone: false, // 是否显示横向滚动的克隆区域
        horizontalDuration: 0, // 横向动画执行时间
        horizontalTextWidth: 0, // 内容区域实际宽度

        verticalDuration: (notice_bar_size_height / speed / 4) * secondToMillisecondConvert, // 纵向动画执行时间
    });

    const translateX = useRef(new Animated.Value(0)).current; // 横向动画平移距离

    const translateY = useRef(new Animated.Value(0)).current; // 纵向动画平移距离

    const textRef = useRef<any>(null); // 横向文字ref，用来获取文字宽度

    const verticalScrollListRef = useRef<Array<string>>([]);

    const [horizontalContent, setHorizontalContent] = useState('');

    const [verticalScrollList, setVerticalScrollList] = useState(verticalScrollListRef.current);

    // 右侧文字
    const rightText = useMemo(() => {
        if (mode) {
            return rightAreaText;
        }
        return '';
    }, [mode, rightAreaText]);

    // 右侧的icon
    const rightIcon = useMemo(() => {
        if (mode === 'closeable') {
            return rightAreaText ? '' : RIGHT_ICON.close;
        }
        return RIGHT_ICON.more;
    }, [mode, rightAreaText]);

    const verticalAnimation = (distance: number) => {
        Animated.timing(translateY, {
            toValue: distance,
            duration: state.verticalDuration,
            useNativeDriver: Platform.OS !== 'web',
        }).start();
    };
    const upAnimation = () => {
        verticalAnimation(-notice_bar_size_height);
        verticalTimer.current = setInterval(() => {
            verticalScrollListRef.current = [
                ...verticalScrollListRef.current.slice(1),
                verticalScrollListRef.current[0],
            ];
            setVerticalScrollList(verticalScrollListRef.current);
            translateY.setValue(0);
            verticalAnimation(-notice_bar_size_height);
        }, state.verticalDuration + delay);
    };

    const downAnimation = () => {
        let initTranslateY = -notice_bar_size_height * (verticalScrollListRef.current.length - 1);
        verticalAnimation(initTranslateY + notice_bar_size_height);
        verticalTimer.current = setInterval(() => {
            const lastItem = verticalScrollListRef.current.pop();
            verticalScrollListRef.current = [lastItem!, ...verticalScrollListRef.current];
            setVerticalScrollList(verticalScrollListRef.current);
            translateY.setValue(initTranslateY);
            verticalAnimation(initTranslateY + notice_bar_size_height);
        }, state.verticalDuration + delay);
    };
    const initVerticalAnimation = () => {
        if (direction === 'up') {
            upAnimation();
        } else {
            // down
            downAnimation();
        }
    };

    const horizontalAnimation = ({
        distance,
        horizontalDuration,
    }: {
        distance: number;
        horizontalDuration: number;
    }) => {
        const { timing, loop } = Animated;
        loop(
            timing(translateX, {
                toValue: -distance,
                duration: horizontalDuration * secondToMillisecondConvert,
                useNativeDriver: Platform.OS !== 'web',
                easing: Easing.linear,
            }),
        ).start();
    };

    const [animatedViewOutterWidth, setAnimatedViewOutterWidth] = useState(0);
    const [innerScrollable, setInnerScrollable] = useState<boolean | undefined>(undefined);
    const scrollable = useMemo(() => _scrollable && innerScrollable, [_scrollable, innerScrollable]);

    const initHorizontalAnimation = () => {
        if (!scrollable) {
            return;
        }
        //@ts-expect-error
        textRef?.current?.measure((x, y, width: number) => {
            const horizontalTextWidth = width;
            const showHorizontalClone = true;

            const distance = horizontalTextWidth + horizontalSpacing;
            const horizontalDuration = distance / +speed;
            setState({
                ...state,
                horizontalTextWidth,
                horizontalDuration,
                showHorizontalClone,
            });
            if (direction === 'left') {
                horizontalAnimation({ distance, horizontalDuration });
            } else {
                // right
                translateX.setValue(-distance);
                horizontalAnimation({ distance: 0, horizontalDuration });
            }
        });
    };

    const init = () => {
        if (direction === 'left' || direction === 'right') {
            setHorizontalContent(Array.isArray(text) ? text[0] : text);
        } else if (direction === 'down') {
            verticalScrollListRef.current = Array.isArray(text) ? [...text].reverse() : [text];
            setVerticalScrollList(verticalScrollListRef.current);
            let initTranslateY = -notice_bar_size_height * (verticalScrollListRef.current.length - 1);
            translateY.setValue(initTranslateY);
        } else {
            //direction up
            verticalScrollListRef.current = Array.isArray(text) ? [...text] : [text];
            setVerticalScrollList(verticalScrollListRef.current);
        }

        setTimeout(() => {
            direction === 'left' || direction === 'right'
                ? initHorizontalAnimation()
                : initVerticalAnimation();
        }, delay);
    };

    const removeTimer = useCallback(() => {
        verticalTimer.current && clearInterval(verticalTimer.current);
    }, []);

    useEffect(() => {
        if (!state.show) {
            removeTimer();
        }
    }, [state.show, removeTimer]);

    const componentWillUnmount = () => {
        // 组件销毁
        removeTimer();
    };

    useEffect(() => {
        if(innerScrollable === undefined && _scrollable &&(direction === 'left' || direction === 'right') ){
            // 左右滑动模式 innerScrollable 初始化完成再init
            return
        }
        init();
        return componentWillUnmount;
    }, [innerScrollable]);

    const onPressContent = () => {
        if (typeof onPress === 'function') {
            onPress();
        }
    };
    const onPressRightBox = () => {
        if (mode === 'closeable') {
            setState({ ...state, show: false });
        }
        if (typeof onPressRightArea === 'function') {
            onPressRightArea();
        }
    };

    const LeftArea = () => {
        return (
            <View style={[styles.leftIcon]}>
                <KidIcon
                    kid={leftIconKid}
                    size={icon_size}
                    style={{ tintColor: color ? color : text_color[type] }}
                />
            </View>
        );
    };

    const RightArea = () => {
        return (
            <TouchableOpacity activeOpacity={1} onPress={onPressRightBox} style={styles.rightLink} testID="notice-bar-right-area">
                {!!rightText && (
                    <Text style={[styles.contentTextStyle, { color: color ? color : text_color[type] }]}>
                        {rightText}
                    </Text>
                )}
                {!!rightIcon && (
                    <KidIcon
                        kid={rightIcon}
                        size={icon_size}
                        style={{ tintColor: color ? color : text_color[type] }}
                    />
                )}
            </TouchableOpacity>
        );
    };

    const HorizontalAnimationWidth = useMemo(() => {
        const _width = state.horizontalTextWidth * 2 + horizontalSpacing;
        return _width > SCREEN_WIDTH ? _width : SCREEN_WIDTH;
    }, [state.horizontalTextWidth, horizontalSpacing]);

    const ContentArea = () => {
        // 横向/纵向不滚动(纵向消息条数小于2，设置了 scrollable 也不能滚动)，包含...和折行两种情况
        if (
            !_scrollable ||
            ((direction === 'up' || direction === 'down') && verticalScrollList.length < 2)
        ) {
            return (
                <TouchableOpacity activeOpacity={1} onPress={onPressContent}>
                    <Text
                        numberOfLines={wrapable ? 0 : 1}
                        style={[styles.contentTextStyle, { color: color ? color : text_color[type] }]}
                    >
                        {horizontalContent || verticalScrollList[0]}
                    </Text>
                </TouchableOpacity>
            );
        }
        // 横向滚动
        if ((direction === 'left' || direction === 'right') && _scrollable) {
            return (
                <TouchableOpacity activeOpacity={1} onPress={onPressContent}>
                    <View>
                        <Animated.View
                            style={[
                                styles.horizontalScrollBox,
                                {
                                    transform: [{ translateX: translateX }],
                                    width: HorizontalAnimationWidth,
                                },
                            ]}
                        >
                            <Text
                                ref={textRef}
                                style={[
                                    styles.contentTextStyle,
                                    { color: color ? color : text_color[type] },
                                    styles.scrollContentTextStyle,
                                ]}
                                onLayout={(e: LayoutChangeEvent) => {
                                    const { width } = e.nativeEvent.layout;
                                    if (width > animatedViewOutterWidth) {
                                        setInnerScrollable(true);
                                    } else {
                                        setInnerScrollable(false);
                                    }
                                }}
                            >
                                {horizontalContent}
                            </Text>
                            {!!state.showHorizontalClone && (
                                // 两个之间的间距
                                <View
                                    style={{
                                        width: horizontalSpacing,
                                    }}
                                />
                            )}
                            {!!state.showHorizontalClone && (
                                <Text
                                    style={[
                                        styles.contentTextStyle,
                                        { color: color ? color : text_color[type] },
                                        styles.scrollContentTextStyle,
                                    ]}
                                >
                                    {horizontalContent}
                                </Text>
                            )}
                        </Animated.View>
                    </View>
                </TouchableOpacity>
            );
        }
        // 纵向滚动
        if ((direction === 'up' || direction === 'down') && verticalScrollList.length > 1) {
            return (
                <TouchableOpacity activeOpacity={1} onPress={onPressContent}>
                    <View style={[styles.verticalScrollBox]}>
                        <Animated.View
                            style={{
                                transform: [{ translateY: translateY }],
                            }}
                        >
                            {verticalScrollList.map((item, index) => (
                                <View style={[styles.verticalScrollItem]} key={index}>
                                    <Text
                                        style={[
                                            styles.contentTextStyle,
                                            { color: color ? color : text_color[type] },
                                            {
                                                lineHeight: notice_bar_size_height,
                                            },
                                        ]}
                                        numberOfLines={1}
                                        ellipsizeMode={'tail'}
                                    >
                                        {item}
                                    </Text>
                                </View>
                            ))}
                        </Animated.View>
                    </View>
                </TouchableOpacity>
            );
        }
    };

    if (!state.show) {
        return null;
    }
    return (
        <View
            style={[
                styles.containerStyle,
                {
                    backgroundColor: backgroundColor ? backgroundColor : bg_color[type],
                    borderRadius: borderRadius,
                },
                wrapable ? styles.containerStyle_wrapable : {},
            ]}
        >
            {renderLeftArea ? renderLeftArea() : !!leftIconKid && LeftArea()}
            <View
                onLayout={
                    (e: LayoutChangeEvent) => {
                        const { width } = e.nativeEvent.layout;
                        setAnimatedViewOutterWidth(width);
                    }
                }
                style={[styles.content]}
            >
                {ContentArea()}
            </View>
            {renderRightArea ? renderRightArea() : !!mode && RightArea()}
        </View>
    );
};

const styles = StyleSheet.create({
    /** 容器样式 */
    containerStyle: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: rem(19),
        height: notice_bar_size_height,
    },
    containerStyle_wrapable: {
        paddingVertical: rem(10),
        height: 'auto',
    },
    /** 文字样式 */
    contentTextStyle: {
        fontSize: rem(14),
        lineHeight: rem(21),
    },
    scrollContentTextStyle: {
        flexShrink: 0,
    },
    /** 左中右部分样式 */
    content: {
        flex: 1,
        overflow: 'hidden',
    },
    horizontalScrollBox: {
        flexDirection: 'row',
        height: notice_bar_size_height,
        alignItems: 'center',
        overflow: 'scroll',
    },
    verticalScrollBox: {
        height: notice_bar_size_height,
    },
    verticalScrollItem: {
        height: notice_bar_size_height,
        justifyContent: 'center',
    },
    // 左侧部分
    rightLink: {
        flexDirection: 'row',
        alignItems: 'center',
        marginLeft: rem(16),
    },
    // 左侧部分
    leftIcon: {
        marginRight: rem(4),
    },
});

export const KidNoticeBar = NoticeBar;
