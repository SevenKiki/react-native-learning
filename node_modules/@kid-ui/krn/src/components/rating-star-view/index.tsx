import {
    Animated,
    ImageStyle,
    LayoutChangeEvent,
    View,
    ViewStyle,
    Image,
    StyleSheet,
    NativeModules,
} from 'react-native';
import React, {
    useCallback,
    useContext,
    useEffect,
    useMemo,
    useRef,
    useState,
} from 'react';
import {
    PanGestureHandler,
    GestureHandlerRootView,
    State,
} from 'react-native-gesture-handler';
//@ts-ignore
import RootTagContext from 'react-native/Libraries/ReactNative/RootTagContext.js';

const styles = StyleSheet.create({
    wrap: {
        justifyContent: 'center',
        alignItems: 'center',
    },
    container: {
        flexDirection: 'row',
        alignItems: 'center',
    },
});

const FULL_STAR = require('./rating_star_bar_full.png');
const LEFT_HALF_STAR = require('./rating_star_bar_left_half.png');

// Default Values
const DEFAULT_SPACING = 1;
const DEFAULT_ACTIVE_COLOR = '#FFC338';
const DEFAULT_INACTIVE_COLOR = '#C8C7C8';
const DEFAULT_STAR_SIZE = 15;

export interface RatingStarViewProps {
    style?: ViewStyle;
    totalCount: number; // 星星总数
    initCount: number; // 初始选中数
    activeColor?: string; // 选中颜色，默认FFC438
    inactiveColor?: string; // 未选中颜色，默认C8C7C8
    enableTouch?: boolean; // 是否支持用户滑动改变，默认开启
    starSize?: number; // 星星大小，默认15
    spacing?: number; // 星星间距，默认1
    onSwipeRating?: (value: number) => void; // 滑动回调，number是以0.5为单位
}

function useProp<T>(value: T, defaultValue: T): T {
    const [prop, setProp] = useState(value ?? defaultValue);
    useEffect(() => {
        setProp((prev) => value ?? prev);
    }, [value]);
    return prop;
}

/**
 * 评分星星view，支持滑动。
 */
export function RatingStarView(props: RatingStarViewProps) {
    const {
        style,
        totalCount,
        initCount,
        activeColor: pActiveColor,
        inactiveColor: pInactiveColor,
        enableTouch: pEnableTouch,
        starSize: pStarSize,
        spacing: pSpacing,
        onSwipeRating,
    } = props;

    // handleProps
    const [fullStarCount, setFullStarCount] = useState(initCount);
    const activeColor = useProp(pActiveColor, DEFAULT_ACTIVE_COLOR);
    const inactiveColor = useProp(pInactiveColor, DEFAULT_INACTIVE_COLOR);
    const enableTouch = useProp(pEnableTouch, true);
    const starSize = useProp(pStarSize, DEFAULT_STAR_SIZE);
    const spacing = useProp(pSpacing, DEFAULT_SPACING);

    const halfIndex = fullStarCount % 1 !== 0 ? Math.ceil(fullStarCount) : -1; // 半个的位置

    // touch anim
    const startX = useRef(0); // 容器rect 左侧X
    const endX = useRef(0); // 容器rect 右侧x
    const gestureMoveX = useMemo(() => {
        return new Animated.Value(0);
    }, []);
    const singleSize = useMemo(() => {
        return starSize! + spacing!;
    }, [spacing, starSize]);

    const rootTag = useContext(RootTagContext);
    const slideBackStatus = useRef();

    useEffect(() => {
        gestureMoveX.addListener(({ value }) => {
            const tapX = value - startX.current;
            // 允许多滑半个，避免最后一个填不满
            if (tapX < 0 || tapX > endX.current + singleSize / 2) {
                return;
            }
            let fullNum = Math.floor(tapX / singleSize);
            const remainRatio = (tapX - fullNum * singleSize) / singleSize;

            // 不到半个算半个，超过半个算1个
            if (remainRatio < 0.5) {
                fullNum += 0.5;
            } else {
                fullNum += 1;
            }
            fullNum = Math.min(fullNum, totalCount);
            onSwipeRating && onSwipeRating(fullNum);
            setFullStarCount(fullNum);
        });
    }, [gestureMoveX, onSwipeRating, singleSize, totalCount]);

    const onLayout = useCallback((e: LayoutChangeEvent) => {
        startX.current = e.nativeEvent.layout.x;
        endX.current = e.nativeEvent.layout.width;
    }, []);

    const starViews = useMemo(() => {
        const viewList = [];
        const fullBoundary =
            halfIndex === -1 ? fullStarCount : fullStarCount - 1; // 黄色渲染到半个前一个
        for (let i = 0; i < totalCount; i++) {
            const tint = i < fullBoundary ? activeColor : inactiveColor;
            const margin = i === totalCount - 1 ? 0 : spacing;
            viewList.push(
                <Image
                    key={`${i}`}
                    style={{
                        width: starSize,
                        height: starSize,
                        marginRight: margin,
                        tintColor: tint,
                    }}
                    source={FULL_STAR}
                />,
            );
        }
        return viewList;
    }, [
        activeColor,
        fullStarCount,
        halfIndex,
        inactiveColor,
        spacing,
        starSize,
        totalCount,
    ]);

    const halfView = useMemo(() => {
        if (halfIndex === -1) {
            return null;
        }
        const imageStyle: ImageStyle = {
            position: 'absolute',
            width: starSize,
            height: starSize,
            left: singleSize * (halfIndex - 1),
            tintColor: activeColor,
        };
        return <Image style={imageStyle} source={LEFT_HALF_STAR} />;
    }, [activeColor, halfIndex, singleSize, starSize]);

    const onGesture = useMemo(() => {
        return Animated.event(
            [
                {
                    nativeEvent: {
                        x: gestureMoveX,
                    },
                },
            ],
            {
                useNativeDriver: false,
            },
        );
    }, [gestureMoveX]);

    const onHandlerStateChange = useCallback(
        async ({ nativeEvent }) => {
            if (nativeEvent.state === State.BEGAN) {
                gestureMoveX.setValue(nativeEvent.x);
                try {
                    // drag 开始时获取滑动返回状态,并禁用滑动返回
                    slideBackStatus.current =
                        await NativeModules.KRNBasic?.getSlideBack?.(rootTag);
                    NativeModules.KRNBasic?.setSlideBack?.({
                        enabled: false, //  true: 打开滑动返回  false ：关闭滑动返回
                        rootTag: rootTag,
                    });
                } catch (error) {}
            } else if (
                nativeEvent.state === State.END ||
                nativeEvent.state === State.FAILED ||
                nativeEvent.state === State.CANCELLED
            ) {
                try {
                    // 拖动结束时，把 SlideBackStatus 还原
                    NativeModules.KRNBasic?.setSlideBack?.({
                        enabled: slideBackStatus.current, //  true: 打开滑动返回  false ：关闭滑动返回
                        rootTag: rootTag,
                    });
                } catch (error) {}
            }
            return onGesture;
        },
        [gestureMoveX, onGesture, rootTag],
    );

    return (
        <GestureHandlerRootView style={styles.wrap}>
            <PanGestureHandler
                enabled={enableTouch}
                onGestureEvent={onGesture}
                onHandlerStateChange={onHandlerStateChange}
            >
                <View
                    testID='ratingViewRoot'
                    style={{
                        ...style,
                        ...styles.container,
                    }}
                    onLayout={onLayout}
                >
                    {starViews.map((view) => view)}
                    {halfView}
                </View>
            </PanGestureHandler>
        </GestureHandlerRootView>
    );
}
