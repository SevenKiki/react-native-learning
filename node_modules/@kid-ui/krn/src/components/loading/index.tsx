// 先放这，之后再迁移
import React, { Component } from 'react';
import { Animated, StyleProp, ViewStyle, Easing, Platform } from 'react-native';
import { Svg, LinearGradient, Path, Stop } from './svg'

const AnimatePath = Animated.createAnimatedComponent(Path);

export enum LoadingType {
    highlight = 'url(#c)', // 渐变高亮色
    light = '#ffffff',
    gray = '#C6C6C6',
}

export enum LoadingSize {
    medium = '40',
    small = '30',
}

interface KsLoadingProps {
    type?: LoadingType | string;
    animated?: boolean;
    percent?: number;
    loopDuration?: number;
    size?: LoadingSize;
    style?: StyleProp<ViewStyle>;
}
export class KidLoading extends Component<KsLoadingProps> {
    offset: Animated.Value;
    animation?: Animated.CompositeAnimation | null;

    constructor(props: KsLoadingProps) {
        super(props);
        this.offset = new Animated.Value(0);
    }
    UNSAFE_componentWillReceiveProps(nextProps: KsLoadingProps) {
        this.onPropsChange(nextProps);
    }
    componentDidMount() {
        this.onPropsChange(this.props);
    }
    onPropsChange(nextProps: KsLoadingProps) {
        const { animated = true, percent = 0, loopDuration = 1000 } = nextProps;
        if (animated) {
            if (this.animation) {
                return;
            }
            this.offset.setValue(0);
            this.animation = Animated.loop(
                Animated.timing(this.offset, {
                    toValue: 320,
                    duration: loopDuration,
                    easing: Easing.linear,
                    useNativeDriver: Platform.OS === 'web' ? false : true,
                }),
            );
            this.animation.start();
        } else {
            if (this.animation) {
                this.animation.stop();
                this.animation = null;
            }
            this.offset.setValue(
                percent > 100 ? 320 : ((100 + percent) / 100) * 160,
            );
        }
    }
    shouldComponentUpdate(nextProps: KsLoadingProps) {
        const changeKeys: (keyof KsLoadingProps)[] = ['type', 'size', 'style'];
        return changeKeys.some((key) => this.props[key] !== nextProps[key]);
    }
    render() {
        const {
            type = LoadingType.gray,
            size = LoadingSize.medium,
            style,
        } = this.props;
        let path = (
            <>
                <LinearGradient id="c">
                    <Stop stopColor="#FF4040" offset="0%" />
                    <Stop stopColor="#FFC900" offset="100%" />
                </LinearGradient>
                <AnimatePath
                    // @ts-ignore
                    strokeDasharray="160"
                    strokeLinecap="round"
                    d="M40 40l8.201-8.201c4.53-4.53 11.873-4.53 16.402 0A11.598 11.598 0 0 1 68 40c0 6.405-5.193 11.598-11.598 11.598a11.598 11.598 0 0 1-8.201-3.397L40 40l-8.201-8.201c-4.53-4.53-11.873-4.53-16.402 0A11.598 11.598 0 0 0 12 40c0 6.405 5.193 11.598 11.598 11.598 3.076 0 6.026-1.222 8.201-3.397L40 40z"
                    stroke={type}
                    strokeWidth="7"
                    fill="none"
                    fillRule="nonzero"
                    strokeDashoffset={this.offset}
                />
            </>
        );
        return (
            <Svg width={size} height={size} viewBox="0 0 80 80" style={style}>
                {path}
            </Svg>
        );
    }
}
