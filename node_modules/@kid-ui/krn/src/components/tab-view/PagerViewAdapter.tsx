import * as React from 'react';
import { Animated, Keyboard, StyleSheet, Platform } from 'react-native';
import ViewPager, {
    PageScrollStateChangedNativeEvent,
} from '@kds/react-native-pager-view';
import useAnimatedValue from './utils';
import type {
    NavigationState,
    Route,
    Listener,
    EventEmitterProps,
    PagerProps,
} from './types';

const IS_IOS = Platform.OS === 'ios';
const AnimatedViewPager = Animated.createAnimatedComponent(ViewPager);

type Props<T extends Route> = PagerProps & {
    onIndexChange: (index: number) => void;
    navigationState: NavigationState<T>;
    overdrag: boolean;
    openPageAnimate: boolean;
    children: (
        props: EventEmitterProps & {
            // Animated value which represents the state of current index
            // It can include fractional digits as it represents the intermediate value
            position: Animated.AnimatedInterpolation;
            // Function to actually render the content of the pager
            // The parent component takes care of rendering
            render: (children: React.ReactNode) => React.ReactNode;
            // Callback to call when switching the tab
            // The tab switch animation is performed even if the index in state is unchanged
            jumpTo: (key: string) => void;
        },
    ) => React.ReactElement;
};

export default function PagerViewAdapter<T extends Route>({
    keyboardDismissMode = 'auto',
    swipeEnabled = true,
    enterOnce,
    openPageAnimate,
    navigationState,
    onIndexChange,
    onSwipeStart,
    onSwipeEnd,
    children,
    overdrag = true,
    style,
    onSwipe,
    ...rest
}: Props<T>) {
    const { index } = navigationState;

    const listenersRef = React.useRef<Listener[]>([]);

    const pagerRef = React.useRef<ViewPager>();
    const indexRef = React.useRef<number>(0);
    const navigationStateRef = React.useRef(navigationState);
    const indexChangeType = React.useRef<'jump' | 'swipe'>('swipe');

    const position = useAnimatedValue(index);
    const offset = useAnimatedValue(0);

    // when swiping the next scene distance is always 1,
    // but when pressing a tab can be greater
    const [jumpingTo, setJumpingTo] = React.useState<[number, number]>([0, 1]);
    const setIndexJump = React.useRef<boolean>(false); // 区分主动ios setIndex 跳转和点击/滑动跳转


    React.useEffect(() => {
        navigationStateRef.current = navigationState;
    });

    const jumpTo = React.useCallback((key: string) => {
        const index = navigationStateRef.current.routes.findIndex(
            (route: { key: string }) => route.key === key,
        );
        indexChangeType.current = 'jump';
        if (IS_IOS) {
            //iOS 上 setIndexJump 为 true 会影响拖拽，需要复位
            setIndexJump.current = false
             setJumpingTo([indexRef.current, index]);
        };
        if(openPageAnimate){
            pagerRef.current?.setPage(index);
        }else{
            pagerRef.current?.setPageWithoutAnimation(index);
            position.setValue(index);
        }
    }, [openPageAnimate]);

    React.useEffect(() => {
        if (keyboardDismissMode === 'auto') {
            Keyboard.dismiss();
        }

        if (indexRef.current !== index) {
            if (IS_IOS) {
                setIndexJump.current = true
                setJumpingTo([indexRef.current, index]);
            };
            if(openPageAnimate){
                pagerRef.current?.setPage(index);
            }else{
                pagerRef.current?.setPageWithoutAnimation(index);
                position.setValue(index);
            }
        }
    }, [keyboardDismissMode, index, openPageAnimate]);

    const onPageScrollStateChanged = (
        state: PageScrollStateChangedNativeEvent,
    ) => {
        const { pageScrollState } = state.nativeEvent;

        switch (pageScrollState) {
            case 'idle':
                onSwipeEnd?.();
                return;
            case 'dragging': {
                //iOS 上 setIndexJump 为 true 会影响拖拽，需要复位
                if (IS_IOS) {
                    setIndexJump.current = false
                }
                const subscription = offset.addListener(({ value }) => {
                    const next =
                        index +
                        (value > 0.1 ? -1 : 1);

                    if (next !== index) {
                        listenersRef.current.forEach((listener) =>
                            listener(next),
                        );
                    }

                    offset.removeListener(subscription);
                });

                onSwipeStart?.();
                return;
            }
        }
    };

    const addEnterListener = React.useCallback((listener: Listener) => {
        listenersRef.current.push(listener);

        return () => {
            const index = listenersRef.current.indexOf(listener);

            if (index > -1) {
                listenersRef.current.splice(index, 1);
            }
        };
    }, []);


    React.useEffect(() => {
        if (IS_IOS && !setIndexJump.current) {
            setJumpingTo([navigationState.index, navigationState.index + 1]);
        }
    }, [navigationState.index]);
        
    const iosFixInterpolate =
        jumpingTo[0] < jumpingTo[1]
              ? {
                  inputRange: [jumpingTo[0] - 1, jumpingTo[0], jumpingTo[0] + 1], // to Right
                  outputRange: [jumpingTo[0] - 1, ...jumpingTo]
                }
              : {
                  inputRange: [jumpingTo[0] - 1, jumpingTo[0], jumpingTo[0] + 1], // to Left
                  outputRange: [...jumpingTo.reverse(), jumpingTo[0] + 1]
                }
              ;
              
    const injectedPosition = Animated.add(position, offset);

    return children({
        position: IS_IOS
     ? injectedPosition.interpolate({
         ...iosFixInterpolate,
          extrapolate: 'clamp'
        })
      : injectedPosition,
        addEnterListener,
        jumpTo,
        render: (children: any) => (
            <AnimatedViewPager
                {...rest}
                // @ts-expect-error
                ref={pagerRef}
                style={[styles.container, style]}
                initialPage={index}
                overdrag={overdrag}
                keyboardDismissMode={
                    keyboardDismissMode === 'auto'
                        ? 'on-drag'
                        : keyboardDismissMode
                }
                onPageScroll={Animated.event(
                    [
                        {
                            nativeEvent: {
                                position: position,
                                offset: offset,
                            },
                        },
                    ],
                    { useNativeDriver: true },
                )}
                onPageSelected={(e: any) => {
                    if(IS_IOS && setIndexJump.current){
                        // 防止主动 setIndex 跳转后接着滑动切换起始插值不对
                        setJumpingTo([navigationState.index, navigationState.index + 1]);
                    }
                    const index = e.nativeEvent.position;
                    indexRef.current = index;
                    onIndexChange(index);
                    if (indexChangeType.current === 'jump') {
                        indexChangeType.current = 'swipe';
                        return;
                    }
                    if (index !== navigationState.index) {
                        onSwipe?.(index);
                    }
                }}
                onPageScrollStateChanged={onPageScrollStateChanged}
                scrollEnabled={swipeEnabled}
                enterOnce={enterOnce}>
                {children}
            </AnimatedViewPager>
        ),
    });
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
});
