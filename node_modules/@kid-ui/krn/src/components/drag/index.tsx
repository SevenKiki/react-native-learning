import React, { useRef, useEffect, useState, useMemo } from 'react';
import { 
  View,
  StyleSheet,
  Dimensions,
  PanResponder,
  NativeModules,
  LayoutAnimation,
  Platform,
  UIManager
} from 'react-native';

if (Platform.OS === 'android') {
  if (UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
  }
}

const styles = StyleSheet.create({
    wrapper: {
      backgroundColor: 'pink',
      position: 'absolute',
      left: 0,
      top: 0,
    },
    debugBorder: {
      borderWidth: 2,
      position: 'absolute',
      left: 0,
      top: 0,
      display: 'flex',
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
    },
    line: {
      width: 2,
      height: '100%',
      backgroundColor: 'pink'
    }
});

interface IposInfo{
  left?: number;
  top?: number;
}

interface IposInfoAll{
  left: number;
  top: number;
  bottom: number;
  right: number;
}

interface IdragArea{
  width?: number,
  height?: number
}

interface Iprops{
    // 是否可拖拽
    isDragAble: boolean;
    // 实际元素
    children: React.ReactElement | React.ReactElement[];
    // 安全区域，类似padding/margin
    safeArea: number[];
    // 是否开启自动吸边
    isAutoAdsorption: boolean;
    // 自动吸边的动画： easeInEaseOut ｜ linear ｜ spring
    autoAdsorptionAnimationType: 'easeInEaseOut' | 'linear' | 'spring';
    // 初始的位置：left&top，相对于安全区域的距离，需要在安全区域内，否则最小为安全区域
    initPos: IposInfo;
    // 开始手势操作
    dragActiveCb: () => void;
    // 手势操作已经成功完成
    dragPassiveCb: () => void;
    // drag内部的手势会被劫持，点击事件需要通过clickCb传递
    clickCb: () => void;
    // 外层包裹的view的style
    containterStyle: any;
    // 可拖拽区域的宽高【一般为外层容器的宽高】
    dragArea: IdragArea;
    // debug模式，辅助颜色标识目前信息
    debugMode: boolean
}

const  Drag = (props: Iprops) => {
    const { safeArea : safeAreaProps = [], initPos = {} } = props;

    const [isClick, setIsClick] = useState(true)

    const [element, setElement] = useState({
      width: 0,
      height: 0
    })

    const [pos, setPos] = useState({
      left: 0,
      top: 0
    })

    const windowWidth = props.dragArea?.width || Dimensions.get('window').width;  //宽度

    const windowHeight = props.dragArea?.height || Dimensions.get('window').height;  //高度

    const dragableView = useRef<any>();

    const [renderOnce, setRenderOnce] = useState(true);

    const minAnimateXY: number = 0;

    const maxAnimateX = windowWidth - element.width;

    const maxAnimateY = windowHeight - element.height;

    //【重要/不对外暴露】用来区分点击手势/滑动手势的判定范围。 此值越大，识别为点击的比例越大。
    const throttle = 1;

    useEffect(() => {
      // console.log(windowWidth, windowHeight)
      initElementPos();
    }, [maxAnimateX, maxAnimateY, initPos, safeAreaProps]);

    const safeArea: IposInfoAll = useMemo(() => {
      let safeLeft = 0, safeRight = 0, safeTop = 0, safeBottom = 0;
      switch (safeAreaProps.length){
        case 0: {
          safeLeft = safeRight = safeTop = safeBottom = 0;
          break;
        }
        case 1: {
          const [ left ] = safeAreaProps;
          safeLeft = safeRight = safeTop = safeBottom = left;
          break;
        }
        case 2: {
          const [ top, left ] = safeAreaProps;
          safeTop = safeBottom = top;
          safeLeft = safeRight = left;
          break;
        }
        case 4: {
          const [ top, right, bottom, left ] = safeAreaProps;
          safeLeft = left;
          safeRight = right;
          safeTop = top;
          safeBottom = bottom;
          break;
        }
        default:
          throw new Error('safeArea参数只支持长度为1/2/4,参考padding/margin');
      }
      return {
        left: safeLeft,
        right: safeRight,
        top: safeTop,
        bottom: safeBottom
      };
    }, [safeAreaProps])

    const initElementPos = (): void => {
      const { left: initLeft = 0, top: initTop = 0 } = initPos;
      const left = getRealLeft(initLeft, 'init');
      const top = getRealTop(initTop);
      setPos({ left, top });
      setDragElementPos({ left, top }, 'init');
    }

    try{
      if(Platform.OS === 'ios'){
        NativeModules.Kds.invoke(
          'tool',
          'setMiddleSlideBack',
          JSON.stringify({
              enabled: false,
          }),
        );
      }
      NativeModules.KRNBasic.setSlideBack({
        enabled: false, //  true: 打开滑动返回  false ：关闭滑动返回
        rootTag: 1
      });
    }catch(e){

    }

    const _onPanResponderGrant = (evt: any, gestureState: any) => {
      // console.log("_onPanResponderGrant")
      // 默认点击模式，throttle太小可能不触发
      setIsClick(true);
      
      // ios手势识别有冲突，必须在元素作为手势响应者时，禁止其他外层容器滚动
      props.dragActiveCb && props.dragActiveCb();
    }

    const _onPanResponderMove = (evt: any, gestureState: any) => {
        // console.log('_onPanResponderMove', gestureState.dx, gestureState.dy, isClick)
       // 如果累计的移动距离小于throttle 则表示没移动
       if (gestureState.dx < throttle && gestureState.dx > -throttle && gestureState.dy < throttle && gestureState.dy > -throttle){
          // console.log('点击', gestureState.dx, gestureState.dy, isClick);
          setIsClick(true);
      }else {
          setIsClick(false);
          // console.log('滑动', gestureState.dx, gestureState.dy, isClick);
          let left = getRealLeft(pos.left + gestureState.dx, 'move');
          let top =  getRealTop(pos.top + gestureState.dy);
          setDragElementPos({ left, top }, 'move');
      }
    }

    const _onPanResponderRelease = (evt: any, gestureState: any) => {
      const left = pos.left + gestureState.dx;
      const top = pos.top + gestureState.dy;
      let autoAdsorptionLeft: number = 0;
      // console.log("_onPanResponderRelease", left, top, gestureState.dx, gestureState.dy, isClick);
      if(isClick){
        // 点击事件处理
        props.clickCb && props.clickCb();
      }else{
        // 重置offset 内部处理了自动吸边逻辑
        autoAdsorptionLeft = setOffset(left, top);
        // 开启自动吸边的时候，需要额外处理
        if(props.isAutoAdsorption){
          // console.log("pos.left:", pos.left, autoAdsorptionLeft);
          setDragElementPosAnimated({ left: autoAdsorptionLeft });
        }
      }
      // 放开外层容器滚动限制
      props.dragPassiveCb && props.dragPassiveCb();
    }

    // 获取到元素的宽高
    const _onLayout = (e: any) => {
      if(!renderOnce){
        return;
      }
      let { height, width } = e.nativeEvent.layout;
      // console.log('_onLayout', height, width)
      setRenderOnce(false);
      setElement({ height: Number(height.toFixed()), width: Number(width.toFixed()) })
    }

    const setDragElementPos = ({ left, top }: { left: number, top: number }, type: string): void => {
      // move触发时 && props控制不可拖拽时
      if(!props.isDragAble && type === 'move'){
        return;
      }
      if(dragableView?.current?.setNativeProps){
        dragableView.current.setNativeProps({ style:{ left, top } })
      }
    }

    const setDragElementPosAnimated = ({ left }: { left: number }): void => {
      let animateType: keyof typeof LayoutAnimation.Presets = 'easeInEaseOut';
      const animationTypes: string[] = ['easeInEaseOut' , 'linear' , 'spring'];
      if(props.autoAdsorptionAnimationType && animationTypes.includes(props.autoAdsorptionAnimationType)){
        animateType = props.autoAdsorptionAnimationType;
      }
      
      LayoutAnimation.configureNext(LayoutAnimation.Presets[animateType]);
      if(dragableView?.current?.setNativeProps){
        dragableView.current.setNativeProps({ style:{ left } })
      } 
    }

    const getRealLeft = (left: number, mode: string) => {
      // 屏幕中心位置横坐标
      const halfWindowWidth = windowWidth / 2;
      // 元素宽度一半
      const halfElementWidth = element.width / 2;
      // 是否是在onPanResponderRelease阶段
      const isSetOffset = typeof mode !== 'undefined' && mode === 'setOffset';
      // 水平安全区域的限制逻辑
      if(left < minAnimateXY + safeArea.left){
        left = minAnimateXY + safeArea.left;
      }
      if(left > maxAnimateX - safeArea.right){
        left = maxAnimateX - safeArea.right;
      }

      // 开始 《自动吸边逻辑：isAutoAdsorption》
      // 只有在开启自动吸边 并且 在onPanResponderRelease阶段才处理
      // 在onPanResponderMove为了拖拽的实时性，不处理
      // isSetOffset && console.log(left, halfElementWidth, halfWindowWidth);
      if(props.isAutoAdsorption && isSetOffset && left + halfElementWidth <= halfWindowWidth){
        left = minAnimateXY + safeArea.left;
      }
      if(props.isAutoAdsorption && isSetOffset && left + halfElementWidth > halfWindowWidth){
        left = maxAnimateX - safeArea.right;
      }
      // isSetOffset && console.log(left);
      // 结束 《自动吸边逻辑：isAutoAdsorption》
      
      return left;
    }

    const getRealTop = (top: number) => {
       // 竖直[树脂？-v-]安全区域的限制逻辑
      if(top < minAnimateXY + safeArea.top){
        top = minAnimateXY + safeArea.top;
      }
      if(top > maxAnimateY - safeArea.bottom){
        top = maxAnimateY - safeArea.bottom;
      }
      return top;
    }

    const setOffset = (left: number, top: number): number => {
      left = getRealLeft(left, 'setOffset');
      setPos({ left, top: getRealTop(top) });
      return left;
    }

    const outerPanResponder = PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onStartShouldSetPanResponderCapture: () => true,
      onMoveShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponderCapture: () => true,
      onPanResponderGrant: _onPanResponderGrant,
      onPanResponderMove: _onPanResponderMove,
      onPanResponderRelease: _onPanResponderRelease
    })

    const renderDebugELements = () => {
      if(!props.debugMode){
        return null;
      }
      return (
        <>
          <View 
            style={[
              styles.debugBorder,
              {
                width: windowWidth,
                height: windowHeight,
                borderColor: 'red',
              }
            ]}
            pointerEvents={'none'}
          >
          </View>
          <View 
            style={[
              styles.debugBorder,
              {
                width: windowWidth - safeArea.left - safeArea.right,
                height: windowHeight - safeArea.top - safeArea.bottom,
                marginLeft: safeArea.left,
                marginTop: safeArea.top,
                borderColor: 'green',
              }
            ]}
            pointerEvents={'none'}
          >
            <View style={styles.line}></View>
          </View>
        </>
      )
    }

    return (
      <>
       {renderDebugELements()}
        <View
            style={[
                styles.wrapper,
                props.containterStyle || {},
                props.debugMode ? {
                  borderColor: 'yellow',
                  borderWidth: 1
                } : {}
            ]}
            ref={dragableView}
            {...outerPanResponder.panHandlers}
            onLayout={_onLayout}
        >
            {props.children}
        </View>  
      </>
      
    )
}

export default Drag;
export { Drag };