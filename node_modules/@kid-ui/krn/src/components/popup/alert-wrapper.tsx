//@ts-nocheck
import {
    Dimensions,
    Animated,
    Keyboard,
    StyleSheet,
    Modal,
    Platform,
    StyleProp,
    TouchableWithoutFeedback,
    ViewStyle,
    LayoutChangeEvent,
    BackHandler
} from 'react-native';
import React, { useRef, useEffect, useState, useCallback } from 'react';
import {
    RootSiblingParent,
    RootSiblingPortal,
} from 'react-native-root-siblings';
import { rem } from '../../utils';

declare module 'react-native' {
    export interface ModalBaseProps {
        statusBarTranslucent?: boolean;
    }
}

let _height = 0, _width = 0, _x = 0, _y = 0;

const { width: windowWidth, height: windowHeight } = Dimensions.get(
    Platform.OS === 'web' ? 'window' : 'screen',
);

const animationIn = (
    val1: Animated.Value,
    val2: Animated.Value,
    time: number,
    callback: () => {},
) => {
    Animated.parallel([
        Animated.timing(val1, {
            toValue: 1,
            duration: time,
            useNativeDriver: false,
        }),
        Animated.timing(val2, {
            toValue: 1,
            duration: time,
            useNativeDriver: false,
        }),
    ]).start(callback);
};
const animationOut = (
    val1: Animated.Value,
    val2: Animated.Value,
    time: number,
    callback = () => { },
) => {
    Animated.parallel([
        Animated.timing(val1, {
            toValue: 0,
            duration: time,
            useNativeDriver: false,
        }),
        Animated.timing(val2, {
            toValue: 0,
            duration: time,
            useNativeDriver: false,
        }),
    ]).start(callback);
};
export interface WrapperComponentProps {
    useModal?: boolean;
    popupStyle?: StyleProp<ViewStyle>;
    visible?: boolean;
    showMask?: boolean;
    maskBgColor?: string;
    maskClosable?: boolean;
    children?: React.ReactNode;
    position?: 'center' | 'right' | 'bottom' | 'left' | 'top';
    top?: number; //在position的基础上设置垂直偏移
    left?: number; //在position的基础上设置水平偏移
    animate?:
    | 'slider'
    | 'fade'
    | 'scale'
    | 'sliderLeft'
    | 'sliderRight'
    | 'sliderTop'
    | 'sliderBottom'
    | 'none';
    animateDuration?: number;
    isControlAnimationIn?: boolean;
    beforeClose?: () => void;
    onAnimateEnd?: () => void;
    borderRadius?: number;
    componentApi?: boolean;
    disableGeastureBack?: boolean;
    onShow?: () => void;
    onDismiss?: () => void;
}

export const WrapperComponent: React.FC<WrapperComponentProps> = function (
    props?: WrapperComponentProps,
) {
    const {
        maskBgColor = 'rgb(111,111,111)',
        componentApi = true,
        useModal = true,
        visible = true,
        showMask = true,
        maskClosable = true,
        position = 'center',
        top = 0,
        left = 0,
        borderRadius = rem(12),
        popupStyle = {},
        beforeClose,
        // TODO: animate 重构成 {type: string; duration: number}
        animate = 'fade',
        animateDuration = animate === 'none' ? 0 : 300,
        isControlAnimationIn = false,
        children,
        onAnimateEnd = () => { },
        disableGeastureBack = false,
        onShow = () => {},
        onDismiss = () => {}
    } = props;
    const [innerVisible, setInnerVisible] = useState(false);

    // 动画部分
    let initSliderH = 1,
        initSliderV = 1,
        initFade = 0,
        animateType = animate;

    switch (animateType) {
        case 'sliderLeft':
            initSliderH = 0;
            break;
        case 'sliderRight':
            initSliderH = 2;
            break;
        case 'sliderTop':
            initSliderV = 2;
            break;
        case 'sliderBottom':
            initSliderV = 0;
            break;
        case 'slider':
            if (position === 'left' || position === 'center') {
                initSliderH = 0;
            } else if (position === 'right') {
                initSliderH = 2;
            }
            if (position === 'bottom') {
                initSliderV = 0;
            } else if (position === 'top') {
                initSliderV = 2;
            }
            if (position === 'center') {
                initFade = 1;
            }
    }

    const initContentFade = animateType === 'fade' ? 0 : 1;
    const initScale = animateType === 'scale' ? 0.8 : 1;
    const sliderV = useRef(new Animated.Value(initSliderV)).current;
    const sliderH = useRef(new Animated.Value(initSliderH)).current;
    const scaleAnim = useRef(new Animated.Value(initScale)).current;
    const fadeAnim = useRef(new Animated.Value(initFade)).current; // mask的透明度
    const contentFadeAnim = useRef(new Animated.Value(initContentFade)).current;

    const [contentH, setContentH] = useState(4000); // 首屏渲染，在获取到正确的宽高之前，先把弹窗内容移到屏幕外，防止闪烁
    const [contentW, setContentW] = useState(4000);
    const [isAnimationInFinished, setIsAnimationInFinished] = useState(false); //进入动画结束的回调
    const animationInCallback = () => {
        setIsAnimationInFinished(true);
    }
    const destroy = useCallback(() => {
        onDismiss();
        onAnimateEnd();
        setInnerVisible(false);
    }, [onAnimateEnd]);
    const stopAnimation = useCallback(() => {
        fadeAnim.stopAnimation();
        sliderV.stopAnimation();
        sliderH.stopAnimation();
        scaleAnim.stopAnimation();
        contentFadeAnim.stopAnimation();
    }, [fadeAnim, sliderV, sliderH, scaleAnim, contentFadeAnim]);
    const sliderIn = (time = animateDuration, animateType = animate) => {
        stopAnimation();
        switch (animateType) {
            case 'slider':
                switch (position) {
                    case 'bottom':
                    case 'top':
                        animationIn(sliderV, fadeAnim, time, animationInCallback);
                        break;
                    default:
                        animationIn(sliderH, fadeAnim, time, animationInCallback);
                }
                break;
            case 'sliderBottom':
            case 'sliderTop':
                animationIn(sliderV, fadeAnim, time, animationInCallback);
                break;
            case 'sliderLeft':
            case 'sliderRight':
                animationIn(sliderH, fadeAnim, time, animationInCallback);
                break;
            case 'scale':
                Animated.parallel([
                    Animated.timing(scaleAnim, {
                        toValue: 1,
                        duration: time,
                        useNativeDriver: false,
                    }),
                    Animated.timing(fadeAnim, {
                        toValue: 1,
                        duration: time,
                        useNativeDriver: false,
                    }),
                    Animated.timing(contentFadeAnim, {
                        toValue: 1,
                        duration: time,
                        useNativeDriver: false,
                    }),
                ]).start(animationInCallback);
                break;
            default:
                animationIn(contentFadeAnim, fadeAnim, time, animationInCallback);
                break;
        }
    };
    const sliderOut = useCallback(
        (time = animateDuration, animateType = animate) => {
            stopAnimation();
            switch (animateType) {
                case 'slider':
                    switch (position) {
                        case 'bottom':
                        case 'top':
                            Animated.parallel([
                                Animated.timing(sliderV, {
                                    toValue: position === 'bottom' ? 0 : 2,
                                    duration: time,
                                    useNativeDriver: false,
                                }),
                                Animated.timing(fadeAnim, {
                                    toValue: 0,
                                    duration: time,
                                    useNativeDriver: false,
                                }),
                            ]).start(destroy);
                            break;
                        default:
                            Animated.parallel([
                                Animated.timing(sliderH, {
                                    toValue: position === 'right' ? 2 : 0,
                                    duration: time,
                                    useNativeDriver: false,
                                }),
                                Animated.timing(fadeAnim, {
                                    toValue: 0,
                                    duration: time,
                                    useNativeDriver: false,
                                }),
                            ]).start(destroy);
                            break;
                    }
                    break;
                case 'sliderLeft':
                    Animated.parallel([
                        Animated.timing(sliderH, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(fadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                    ]).start(destroy);
                    break;
                case 'sliderRight':
                    Animated.parallel([
                        Animated.timing(sliderH, {
                            toValue: 2,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(fadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                    ]).start(destroy);
                    break;
                case 'sliderTop':
                    Animated.parallel([
                        Animated.timing(sliderV, {
                            toValue: 2,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(fadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                    ]).start(destroy);
                    break;
                case 'sliderBottom':
                    Animated.parallel([
                        Animated.timing(sliderV, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(fadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                    ]).start(destroy);
                    break;
                case 'scale':
                    Animated.parallel([
                        Animated.timing(scaleAnim, {
                            toValue: initScale,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(fadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                        Animated.timing(contentFadeAnim, {
                            toValue: 0,
                            duration: time,
                            useNativeDriver: false,
                        }),
                    ]).start(destroy);
                    break;
                default:
                    animationOut(contentFadeAnim, fadeAnim, time, destroy);
                    break;
            }
        },
        [
            initScale,
            animateDuration,
            animate,
            position,
            sliderV,
            sliderH,
            fadeAnim,
            scaleAnim,
            contentFadeAnim,
            stopAnimation,
            destroy,
        ],
    );
    const _onLayout = (e: LayoutChangeEvent) => {
        const { height, width, x, y } = e.nativeEvent.layout;

        const difH = Math.abs(height - _height) > 1;
        const difW = Math.abs(width - _width) > 1;
        const difX = Math.abs(x - _x) > 1;
        const difY = Math.abs(y - _y) > 1;
        [_height, _width, _x, _y] = [height, width, x, y];

        if(!difH && !difW && !difX && !difY && Platform.OS !== 'web') {
            return;
        }
        
        switch (animate) {
            case 'sliderBottom':
                setContentH(windowHeight - y);
                setContentW(width);
                break;
            case 'sliderTop':
                setContentH(y + height);
                setContentW(width);
                break;
            case 'sliderLeft':
                setContentW(x + width);
                setContentH(height);

                break;
            case 'sliderRight':
                setContentW(windowWidth - x);
                setContentH(height);

                break;
            default:
                setContentH(height);
                setContentW(width);
        }
        if (visible) {
            sliderIn();
        }
    };
    const [keyboardUp, setKeyboardUp] = useState(false);

    // 函数及组件渲染部分
    useEffect(() => {
        const _keyboardDidShow = () => {
            setKeyboardUp(true);
        };
        const _keyboardDidHide = () => {
            setKeyboardUp(false);
        };
        Keyboard.addListener('keyboardDidShow', _keyboardDidShow);
        Keyboard.addListener('keyboardDidHide', _keyboardDidHide);

        return () => {
            Keyboard.removeListener('keyboardDidShow', _keyboardDidShow);
            Keyboard.removeListener('keyboardDidHide', _keyboardDidHide);
        };
    }, []);

    useEffect(() => {
        if (props.visible !== false) {
            onShow();
            setInnerVisible(true);
        } else {
            sliderOut();
        }
    }, [props.visible]);

    //弹层出现的时候，禁用滑动返回
    const backHandlerCallback = () => {
        if (props.visible !== false && props.disableGeastureBack === true) {
            if (!beforeClose) {
                !componentApi && sliderOut();
            } else {
                beforeClose();
            }
            return true;
        }
        return false
    }

    useEffect(() => {
        BackHandler.addEventListener('hardwareBackPress', backHandlerCallback);
        return () => {
            BackHandler.removeEventListener('hardwareBackPress', backHandlerCallback);
        };
    }, [props.visible, props.disableGeastureBack]);
    let _left = '50%',
        _top = '50%',
        bottom,
        marginTop = -contentH / 2,
        marginLeft = -contentW / 2;
    switch (position) {
        case 'center':
            marginTop = marginTop + top;
            marginLeft = marginLeft + left;
            break;
        case 'bottom':
            bottom = -top;
            _top = null;
            marginTop = null;
            marginLeft = marginLeft + left;
            break;
        case 'top':
            _top = '0%';
            marginTop = top;
            marginLeft = marginLeft + left;
            break;
        case 'left':
            _left = '0%';
            marginLeft = left;
            marginTop = marginTop + top;
            break;
        case 'right':
            _left = '100%';
            marginLeft = -contentW + left;
            marginTop = marginTop + top;
            break;
    }
    const renderChild = () => {
        return (
            <Animated.View
                onLayout={_onLayout}
                style={[
                    {
                        backgroundColor: '#fff',
                        borderRadius: borderRadius,
                        position: Platform.OS === 'web' ? 'fixed' : 'absolute',
                        top: _top,
                        left: _left,
                        bottom: bottom,
                        marginTop: marginTop,
                        marginLeft: marginLeft,
                        width: 'auto',
                        height: 'auto',
                        opacity: contentFadeAnim,
                        transform: [
                            {
                                translateX: sliderH.interpolate({
                                    inputRange: [0, 1, 2],
                                    outputRange: [-contentW, 0, contentW],
                                }),
                            },
                            {
                                translateY: sliderV.interpolate({
                                    inputRange: [0, 1, 2],
                                    outputRange: [contentH, 0, -contentH],
                                }),
                            },
                            {
                                scale: scaleAnim,
                            },
                        ],
                    },
                    styles.center,
                    popupStyle,
                ]}
            >
                {isControlAnimationIn ? (isAnimationInFinished ? children : null) : children}
            </Animated.View>
        );
    };
    const renderContent = () => {
        return (
            <>
                {showMask && (
                    <TouchableWithoutFeedback
                        onPress={() => {
                            if (keyboardUp) {
                                Keyboard.dismiss();
                            } else if (maskClosable) {
                                if (!beforeClose) {
                                    !componentApi && sliderOut();
                                } else {
                                    beforeClose();
                                }
                            }
                        }}
                    >
                        <Animated.View
                            style={[
                                {
                                    height: '100%',
                                    width: '100%',
                                    backgroundColor: maskBgColor,
                                    opacity: fadeAnim.interpolate({
                                        inputRange: [0, 1],
                                        outputRange: [0, 0.6],
                                    }),
                                },
                                styles.mask,
                            ]}
                        />
                    </TouchableWithoutFeedback>
                )}
                {renderChild()}
            </>
        );
    };
    if (!innerVisible) {
        return null;
    }
    return (
        <>
            {showMask && useModal ? (
                <Modal
                    onRequestClose={() => {
                        if (!beforeClose) {
                            !componentApi && sliderOut();
                        } else {
                            beforeClose();
                        }
                    }}
                    visible={true}
                    transparent={true}
                    statusBarTranslucent={true}
                >
                    <RootSiblingParent inactive={true}>{renderContent()}</RootSiblingParent>
                </Modal>
            ) : componentApi ? (
                <RootSiblingPortal>{renderContent()}</RootSiblingPortal>
            ) : (
                renderContent()
            )}
        </>
    );
};
const styles = StyleSheet.create({
    mask: {
        // @ts-expect-error
        position: Platform.OS === 'web' ? 'fixed' : 'absolute',
    },
    center: {
        alignItems: 'center',
        justifyContent: 'center',
    },
});
