import React from 'react';
import {
    Dimensions,
    Platform,
    Modal,
    View,
    TouchableOpacity,
    GestureResponderEvent,
    StyleProp,
    ViewStyle,
    LayoutChangeEvent
} from 'react-native';
import { NOOP } from '../../utils';
import { SvgBubble } from './svg-bubble';
import { Shadow } from '@kds/react-native-shadow-2';
import type { ShadowProps } from '@kds/react-native-shadow-2';


export type Placement = 'top' | 'bottom' | 'left' | 'right' | 'auto';

interface Rect {
    x: number;
    y: number;
    width: number;
    height: number;
}
export interface CustomBubbleProps {
    isVisible?: boolean;
    //触发视图rect
    fromRect?: { x: number; y: number; width: number; height: number };
    //气泡方向
    placement?: Placement;
    //气泡
    content?: React.ReactNode;
    width?: number | string;
    height?: number | string;
    backgroundColor?: string;
    bubbleOffsetX?: number;
    bubbleOffsetY?: number;
    bubbleStyle?: StyleProp<ViewStyle>
    //调整气泡除三角箭头以外部分的X轴偏移（在bubbleOffsetX的基础上的X轴偏移）
    bubbleContentOffsetX?: number;
    bubbleCornerRadius?: number;
    shadowColor?: string;
    contentStyle?: any;
    //三角箭头
    withTriangle?: boolean;
    triangleSize?: { width: number; height: number };
    triangleColor?: string;
    triangleBorderWidth?: number;
    triangleBorderColor?: string;
    //全屏遮罩
    withOverlay?: boolean;
    overlayColor?: string;
    //触发手势
    actionType?: 'press' | 'longPress' | 'none';
    //事件
    onOpen?: () => void;
    onClose?: () => void;
    onToggle?: () => void;
    onClick?: (e: GestureResponderEvent) => void;
    //触发属性
    toggleWrapperProps?: any;
    //子组件
    children?: React.ReactNode;
    //气泡是否为普通的view
    isJustBubble?: boolean;
    bubbleShadow?: ShadowProps;
    isFitContentSize?: boolean;
    widthToFixFit?: number;
    isUseInnerFromRect?: boolean;
}

const { width: ScreenWidth, height: ScreenHeight } = Dimensions.get('window');

const varStyles = {
    container: (withOverlay: boolean, overlayColor: string) => ({
        backgroundColor: withOverlay
            ? overlayColor
                ? overlayColor
                : 'rgba(250, 250, 250, 0.70)'
            : 'transparent',
        flex: 1,
    }),
};

const CustomBubble: React.FC<CustomBubbleProps> = (props) => {
    const { isJustBubble = false } = props;
    const isIOS = Platform.OS === 'ios';
    //坐标
    const calAttribute = {
        bubbleOrigin: { x: 0, y: 0 },
        anchorPoint: { x: 0, y: 0 },
    };

    const childrenRef = React.useRef<any>();
    const [innerFromRect, setInnerFromRect] = React.useState<Rect>({ x: 0, y: 0, width: 0, height: 0 });

    const _childrenOnLayout = () => {
        childrenRef.current && childrenRef.current.measure((fx: number, fy: number, width: number, height: number, px: number, py: number) => {
            setInnerFromRect({ x: px, y: py, width, height })
        })
    }

    //根据actionType子组件外层包裹触发事件
    const wrapWithAction = (actionType: string, children: React.ReactNode) => {
        switch (actionType) {
            case 'press':
                return (
                    <TouchableOpacity
                        ref={childrenRef}
                        onLayout={_childrenOnLayout}
                        onPress={toggleBubble}
                        activeOpacity={1}
                        {...props.toggleWrapperProps}>
                        {children}
                    </TouchableOpacity>
                );
            case 'longPress':
                return (
                    <TouchableOpacity
                        ref={childrenRef}
                        onLayout={_childrenOnLayout}
                        onLongPress={toggleBubble}
                        activeOpacity={1}
                        {...props.toggleWrapperProps}>
                        {children}
                    </TouchableOpacity>
                );
            default:
                return (
                    <View ref={childrenRef} onLayout={_childrenOnLayout}>
                        {children}
                    </View>
                );
        }
    };

    //计算坐标
    const measureContent = (placement: string) => {
        const options = {
            displayArea: {
                x: 0,
                y: 0,
                width: ScreenWidth,
                height: ScreenHeight,
            },
            fromRect: props.isUseInnerFromRect ? innerFromRect : props.fromRect!,
            contentSize: {
                width: props.isFitContentSize ? contentRect.width : Number(props.width || 0),
                height: props.isFitContentSize ? contentRect.height : Number(props.height || 0)
            },
            triangleSize: props.triangleSize!,
        };
        switch (placement) {
            case 'top':
                return computeTopGeometry(options);
            case 'bottom':
                return computeBottomGeometry(options);
            case 'left':
                return computeLeftGeometry(options);
            case 'right':
                return computeRightGeometry(options);
            default:
                return computeAutoGeometry(options);
        }
    };

    const computeTopGeometry = ({
        displayArea,
        fromRect,
        contentSize,
        triangleSize,
    }: {
        displayArea: Rect;
        fromRect: Rect;
        contentSize: Record<'width' | 'height', number>;
        triangleSize: Record<'width' | 'height', number>;
    }) => {
        const contentX = Math.min(
            displayArea.x + displayArea.width - contentSize.width,
            Math.max(
                displayArea.x,
                fromRect.x + (fromRect.width - contentSize.width) / 2,
            ),
        );
        const contentY = fromRect.y - contentSize.height - triangleSize.height;

        calAttribute.bubbleOrigin = { x: contentX, y: contentY - 1 };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width / 2.0 - contentSize.width / 2,
            y: fromRect.y - contentSize.height - triangleSize.height,
        };
        computeOffset();
    };

    const computeBottomGeometry = ({
        displayArea,
        fromRect,
        contentSize,
        triangleSize,
    }: {
        displayArea: Rect;
        fromRect: Rect;
        contentSize: Record<'width' | 'height', number>;
        triangleSize: Record<'width' | 'height', number>;
    }) => {
        const contentX = Math.min(
            displayArea.x + displayArea.width - contentSize.width,
            Math.max(
                displayArea.x,
                fromRect.x + (fromRect.width - contentSize.width) / 2,
            ),
        );
        const contentY = fromRect.y + fromRect.height + triangleSize.height;

        calAttribute.bubbleOrigin = { x: contentX, y: contentY + 1 };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width / 2.0 - contentSize.width / 2,
            y: fromRect.y + fromRect.height,
        };
        computeOffset();
    };

    const computeLeftGeometry = ({
        displayArea,
        fromRect,
        contentSize,
        triangleSize,
    }: {
        displayArea: Rect;
        fromRect: Rect;
        contentSize: Record<'width' | 'height', number>;
        triangleSize: Record<'width' | 'height', number>;
    }) => {
        const contentX = fromRect.x - contentSize.width - triangleSize.height;
        const contentY = Math.min(
            displayArea.y + displayArea.height - contentSize.height,
            Math.max(
                displayArea.y,
                fromRect.y + (fromRect.height - contentSize.height) / 2,
            ),
        );

        calAttribute.bubbleOrigin = { x: contentX - 1, y: contentY };
        calAttribute.anchorPoint = {
            x: fromRect.x - contentSize.width - triangleSize.height,
            y: fromRect.y + fromRect.height / 2.0 - contentSize.height / 2,
        };
        computeOffset();
    };

    const computeRightGeometry = ({
        displayArea,
        fromRect,
        contentSize,
        triangleSize,
    }: {
        displayArea: Rect;
        fromRect: Rect;
        contentSize: Record<'width' | 'height', number>;
        triangleSize: Record<'width' | 'height', number>;
    }) => {
        const contentX = fromRect.x + fromRect.width + triangleSize.height;
        const contentY = Math.min(
            displayArea.y + displayArea.height - contentSize.height,
            Math.max(
                displayArea.y,
                fromRect.y + (fromRect.height - contentSize.height) / 2,
            ),
        );

        calAttribute.bubbleOrigin = { x: contentX + 1, y: contentY };
        calAttribute.anchorPoint = {
            x: fromRect.x + fromRect.width,
            y: fromRect.y + fromRect.height / 2 - contentSize.height / 2,
        };
        computeOffset();
    };

    const computeAutoGeometry = ({
        displayArea,
        contentSize,
    }: {
        displayArea: Rect;
        fromRect: Rect;
        contentSize: Record<'width' | 'height', number>;
        triangleSize: Record<'width' | 'height', number>;
    }) => {
        const placementsToTry = ['left', 'right', 'bottom', 'top'];

        for (let i = 0; i < placementsToTry.length; i++) {
            const placement = placementsToTry[i];
            measureContent(placement);

            if (
                calAttribute.bubbleOrigin.x >= displayArea.x &&
                calAttribute.bubbleOrigin.x <=
                displayArea.x + displayArea.width - contentSize.width &&
                calAttribute.bubbleOrigin.y >= displayArea.y &&
                calAttribute.bubbleOrigin.y <=
                displayArea.y + displayArea.height - contentSize.height
            ) {
                break;
            }
        }
    };

    const computeOffset = () => {
        const oldAnchor = calAttribute.anchorPoint;
        calAttribute.anchorPoint = {
            x: oldAnchor.x + props.bubbleOffsetX!,
            y: oldAnchor.y + props.bubbleOffsetY!,
        };
        const oldContent = calAttribute.bubbleOrigin;
        calAttribute.bubbleOrigin = {
            x: oldContent.x + props.bubbleOffsetX!,
            y: oldContent.y + props.bubbleOffsetY!,
        };
    };

    const [contentRect, setContentRect] = React.useState({ width: 0, height: 0 });

    const contentOnLayout = (event: LayoutChangeEvent) => {
        const { width: _width, height: _height } = event.nativeEvent.layout;
        const width = Number(_width?.toFixed(0));
        const height = Number(_height?.toFixed(0));
        if (Math.abs(width - contentRect.width) > 1 || Math.abs(height - contentRect.height) > 1) {
            setContentRect({ width: width + props.widthToFixFit!, height })
        }
    }

    //渲染气泡内容
    const renderContent = () => {
        //计算箭头锚点、气泡原点
        measureContent(props.placement!);
        //气泡样式
        const bubbleStyle = getBubbleStyle();
        //内容样式
        const contentStyle = getContentStyle();

        const offset = getShadowOffset();

        return (
            <View style={bubbleStyle}>
                {((props.isFitContentSize && contentRect.width) || !props.isFitContentSize) && (
                    <Shadow offset={offset} distance={8} radius={6} startColor='rgba(0,0,0,0.05)' {...props.bubbleShadow}>
                        <View style={{ width: props.isFitContentSize ? contentRect.width : Number(props.width || 0), height: props.isFitContentSize ? contentRect.height : Number(props.height || 0) }} />
                    </Shadow>
                )}
                <SvgBubble
                    style={{ position: 'absolute' }}
                    placement={props.placement}
                    width={props.isFitContentSize ? contentRect.width : Number(props.width || 0)}
                    height={props.isFitContentSize ? contentRect.height : Number(props.height || 0)}
                    borderRadius={props.bubbleCornerRadius}
                    color={props.backgroundColor}
                    withTriangle={props.withTriangle}
                    triangleWidth={props.triangleSize?.width}
                    triangleHeight={props.triangleSize?.height}
                    triangleColor={props.triangleColor || props.backgroundColor}
                    offsetX={props.bubbleContentOffsetX}
                />
                <View onLayout={contentOnLayout} style={contentStyle}>
                    {props.content}
                </View>
            </View>
        );
    };

    const getBubbleStyle: () => ViewStyle = () => {
        let offsetX = props.bubbleContentOffsetX!;
        const { width: _width, isFitContentSize, triangleSize, bubbleCornerRadius: borderRadius } = props;
        const width = isFitContentSize ? contentRect.width : Number(_width);
        const { width: triangleWidth } = triangleSize!;
        if(props.placement === 'top' || props.placement === 'bottom') {
            offsetX = Math.abs(offsetX) > (width - triangleWidth) / 2 - borderRadius! ? ( offsetX > 0 ? (width - triangleWidth) / 2 - borderRadius! : -((width - triangleWidth) / 2 - borderRadius!)) : offsetX
        }
        
        //构建气泡样式
        const bubbleStyle: ViewStyle = {
            position: 'absolute',
            top: calAttribute.anchorPoint.y,
            left: calAttribute.anchorPoint.x + offsetX,
        };
        return bubbleStyle;
    };

    const getContentStyle: () => StyleProp<ViewStyle> = () => {
        //构建气泡样式
        const bubbleStyle: ViewStyle = {
            position: 'absolute',
            justifyContent: 'center',
            alignItems: 'center',
            padding: 10,
            top: (props.placement === 'bottom' && props.withTriangle) ? props.triangleSize?.height : 0,
            left: (props.placement === 'right' && props.withTriangle) ? props.triangleSize?.height : 0,
            opacity: ((props.isFitContentSize && contentRect.width) || !props.isFitContentSize) ? 1 : 0
        };
        return [
            bubbleStyle,
            props.isFitContentSize ? {} : { width: props.width, height: props.height },
            props.contentStyle,
            props.bubbleStyle
        ];
    };

    const getShadowOffset: () => [x: string | number, y: string | number] = () => {
        switch (props.placement) {
            case 'top':
            case 'left':
                return [0, 0];
            case 'right':
                return [5, 0];
            case 'bottom':
            default:
                return [0, 5];
        }
    }

    //气泡显示/隐藏
    const toggleBubble = () => {
        if (props.isVisible && !isIOS) {
            props.onClose?.();
        }
        props.onToggle?.();
    };

    return (
        isJustBubble ?
            ((props.isVisible && renderContent()) || null)
            :
            (<View>
                {wrapWithAction(props.actionType!, props.children)}
                <Modal
                    animationType="fade"
                    visible={props.isVisible}
                    transparent
                    onShow={props.onOpen}
                    onDismiss={props.onClose}
                    onRequestClose={props.onClose}>
                    <TouchableOpacity
                        style={varStyles.container(
                            !!props.withOverlay,
                            props.overlayColor!,
                        )}
                        onPress={(e) => {
                            props.onClick!(e);
                            toggleBubble();
                        }}
                        activeOpacity={1}>
                        {renderContent()}
                    </TouchableOpacity>
                </Modal>
            </View>)
    );
};

CustomBubble.defaultProps = {
    isVisible: false,
    fromRect: { x: 0, y: 0, width: 0, height: 0 },
    placement: 'bottom',
    width: 120,
    height: 40,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    bubbleCornerRadius: 4,
    withTriangle: true,
    triangleSize: { width: 13, height: 6 },
    withOverlay: false,
    actionType: 'press',
    onClick: NOOP,
    isFitContentSize: false,
    widthToFixFit: 1
};

export default CustomBubble;
