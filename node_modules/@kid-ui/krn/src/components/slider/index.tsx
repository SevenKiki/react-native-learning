// @ts-nocheck
import { View, StyleSheet, ViewStyle, StyleProp, Platform } from 'react-native';
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Draggable } from './draggable';
import LinearGradient from 'react-native-linear-gradient';
import type { LinearGradientProps } from 'react-native-linear-gradient';
export interface SliderProps {
    start?: number;
    end?: number;
    value?: number; // 传入当前进度，普通数字
    minValue?: number; //最小值
    maxValue?: number; //最大值
    onChange?: (value?: number) => void; // 告诉父组件我被拖动到哪个时长
    maximumTrackTintColor?: string;
    minimumTrackTintColor?: string;
    onDragEnd?: (value?: number) => void;
    onDragStart?: (value?: number) => void;
    step?: number;
    disabled?: boolean;
    ovalColor?: string;
    ovalSize?: number;
    height?: number;
    trackHeight?: number;
    direction?: 'x' | 'y';
    style?: StyleProp<ViewStyle>;
    tapToSeek?: boolean;
    renderHandle?: () => React.ReactNode;
    renderTrackContent?: () => React.ReactNode;
    borderRadius?: number;
    isMaximumTrackLinearGradient?: boolean;
    maximumTrackLinearGradientConfig?: LinearGradientProps;
    isMinimumTrackLinearGradient?: boolean;
    minimumTrackLinearGradientConfig?: LinearGradientProps;
    isShowCalibration?: boolean; //是否显示刻度
    animated?: boolean; // 是否有松手动画
    calibrationStyle?: StyleProp<ViewStyle>; // 刻度样式
}
export const Slider: React.FC<SliderProps> = function (props: SliderProps) {
    const {
        start = 0,
        end = 100,
        value = 0,
        minValue,
        maxValue,
        onChange = (_e) => { },
        step = 1,
        disabled = false,
        onDragEnd = (_e) => { },
        onDragStart = (_e) => { },
        ovalColor = '#fff',
        maximumTrackTintColor = 'rgba(255,255,255,0.25)',
        minimumTrackTintColor = '#fff',
        trackHeight = 4,
        ovalSize = 16,
        height = 32,
        tapToSeek = true,
        renderHandle = null,
        renderTrackContent = null,
        direction = 'x',
        style,
        borderRadius = 0,
        isMaximumTrackLinearGradient = false,
        maximumTrackLinearGradientConfig = {
            colors: ['white', 'black']
        },
        isMinimumTrackLinearGradient = false,
        minimumTrackLinearGradientConfig = {
            colors: ['white', 'black']
        },
        isShowCalibration = false,
        animated = false,
        calibrationStyle
    } = props;
    // 进度条可以滑动的范围: [_minValue, _maxValue];
    const _minValue = React.useMemo(() => Math.max(start, minValue === undefined ? start : minValue), [start, minValue]);
    const _maxValue = React.useMemo(() => Math.min(end, maxValue === undefined ? end : maxValue), [end, maxValue]);

    const [handleSize, setHandleSize] = useState({
        width: ovalSize,
        height: ovalSize,
    });

    const [contentStyle, setContentStyle] = useState({});
    const _onLayout = (e) => {
        const { width, height } = e.nativeEvent.layout;
        if (direction === 'x') {
            setContentStyle({
                width,
                left: -width + handleSize.width ?? ovalSize,
            });
        } else {
            setContentStyle({
                height,
                bottom: -height + handleSize.height ?? ovalSize,
            });
        }
    };

    function percentToValue(val: number): number {
        return Math.round((val * (end - start)) / _step) * _step;
    }

    const valueToPercent = useCallback(
        (val: number) => val / (end - start),
        [end, start],
    );

    const [position, setposition] = useState(valueToPercent(value));

    const _setposition = (value: number, cb?: boolean = false) => {
        if (value >= valueToPercent(_minValue) && value <= valueToPercent(_maxValue)) {
            setposition(value);
            if (cb) {
                const nowValue = percentToValue(value);
                onChange(nowValue);
            }
        }
    }

    const onValueChange = (percent) => {
        _setposition(percent, true);
    };
    useEffect(() => {
        _setposition(valueToPercent(value));
    }, [value, valueToPercent]);

    const onAfterChange = (percent) => {
        onDragEnd(percentToValue(percent));
        // 受控模式恢复组件值
        if (props.value) {
            _setposition(valueToPercent(props.value));
        }
    };
    const flexDirection = direction === 'x' ? 'row' : 'column';
    const isFirstLayout = useRef<boolean>(true);

    // step
    const _step = React.useMemo(() => {
        return animated ? 1 : step
    }, [step, animated])

    // 刻度的个数
    const parts = React.useMemo(() => {
        if (!isShowCalibration && !animated) {
            return undefined;
        }

        if ((end - start) % step !== 0) {
            console.warn('step不能被end - start整除');
            return undefined
        }

        return (end - start) / step + 1;
    }, [animated, end, start, step])

    // 刻度
    const renderCalibration = React.useCallback((index: number, num: number): React.ReactNode => {
        const isSelected = direction === 'x' ? index <= (num - 1) * position : index >= (num - 1) * (1 - position);
        return (
            <View
                style={[
                    {
                        width: direction === 'x' ? 2 : 8,
                        height: direction === 'y' ? 2 : 8,
                        backgroundColor: isSelected ? minimumTrackTintColor : maximumTrackTintColor
                    },
                    calibrationStyle
                ]}
            />
        )
    }, [minimumTrackTintColor, maximumTrackTintColor, position, direction, calibrationStyle]);


    // 进度条 下
    const maximumTrackStyle: StyleProp<ViewStyle> = [
        styles.rectangleL,
        {
            backgroundColor: maximumTrackTintColor,
            height: direction === 'x' ? trackHeight : '100%',
            width: direction === 'x' ? '100%' : trackHeight,
            borderRadius,
        },
    ];

    const renderMaximumTrack = () => {
        if (isMaximumTrackLinearGradient) {
            return (
                <LinearGradient {...maximumTrackLinearGradientConfig} style={maximumTrackStyle} />
            )
        } else {
            return (
                <View style={maximumTrackStyle} />
            )
        }
    }

    // 进度条 上
    const minimumTrackStyle: StyleProp<ViewStyle> = [
        styles.rectangleS,
        {
            backgroundColor: minimumTrackTintColor,
            height:
                direction === 'x'
                    ? trackHeight
                    : `${position * 100}%`,
            width:
                direction === 'x'
                    ? `${position * 100}%`
                    : trackHeight,
            left: direction === 'x' ? 0 : null,
            bottom: direction === 'x' ? null : 0,
            borderRadius,
            paddingRight:
                direction === 'x' ? handleSize.width / 2 : 0,
            paddingTop:
                direction === 'y' ? handleSize.height / 2 : 0,
        },
    ];

    const renderMinimumTrack = () => {
        if (isMinimumTrackLinearGradient) {
            return renderTrackContent ? (
                <View style={[maximumTrackStyle, { backgroundColor: 'transparent' }]}>
                    <LinearGradient {...minimumTrackLinearGradientConfig} style={minimumTrackStyle} />
                    <View style={[maximumTrackStyle, { backgroundColor: 'transparent', position: 'absolute' }]}>
                        {renderTrackContent()}
                    </View>
                </View>
            ) : (
                <LinearGradient {...minimumTrackLinearGradientConfig} style={minimumTrackStyle} />
            )
        } else {
            return renderTrackContent ? (
                <View style={[maximumTrackStyle, { backgroundColor: 'transparent' }]}>
                    <View style={minimumTrackStyle} />
                    {renderTrackContent && (
                        <View style={[maximumTrackStyle, { backgroundColor: 'transparent', position: 'absolute' }]}>
                            {renderTrackContent()}
                        </View>
                    )}
                </View>
            ) : (
                <View style={minimumTrackStyle} />
            )
        }
    }

    return (
        <View
            onLayout={_onLayout}
            style={[
                styles.rectangleWrap,
                {
                    height: height,
                    flexDirection,
                    marginTop: direction === 'x' ? 0 : handleSize.height / 2,
                    marginRight: direction === 'x' ? handleSize.width / 2 : 0,
                    marginBottom: direction === 'x' ? 0 : handleSize.height / 2,
                    marginLeft: direction === 'x' ? handleSize.width / 2 : 0,
                },
                style,
            ]}
        >
            {isShowCalibration && parts && (
                <View
                    style={[
                        maximumTrackStyle,
                        {
                            flexDirection,
                            justifyContent: 'space-between',
                            backgroundColor: 'transparent',
                        },
                        direction === 'x' ? { height: StyleSheet.flatten(calibrationStyle!)?.height || 8 } : { width: StyleSheet.flatten(calibrationStyle!)?.width || 8 }
                    ]}>
                    {Array(parts).fill(0).map((_, index) => (
                        renderCalibration(index, parts)
                    ))}
                </View>
            )}
            {renderMaximumTrack()}
            {renderMinimumTrack()}
            <Draggable
                handleSize={handleSize}
                step={_step / (end - start)}
                parts={parts}
                disabled={disabled}
                min={valueToPercent(_minValue)}
                max={valueToPercent(_maxValue)}
                tapToSeek={tapToSeek}
                getCenterPosition={(touchInfo, wrapInfo) => {
                    if (direction === 'x') {
                        return {
                            x: (Platform.OS === 'web' ? touchInfo.locationX : touchInfo.x) - handleSize.width / 2,
                            y: null,
                        };
                    } else {
                        return {
                            x: null,
                            y:
                                (Platform.OS === 'web' ? touchInfo.locationY : touchInfo.y) -
                                wrapInfo.height -
                                handleSize.height / 2,
                        };
                    }
                }}
                {...{
                    [direction === 'x' ? 'positionX' : 'positionY']: position,
                }}
                getMoveRange={(contentInfo, wrapInfo) => {
                    if (direction === 'x') {
                        return {
                            left: 0,
                            right: Math.abs(wrapInfo.width - handleSize.width || 0),
                            top: 0,
                            bottom: 0,
                        };
                    } else {
                        return {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: Math.abs(wrapInfo.height - handleSize.height || 0),
                        };
                    }
                }}
                moveDirection={direction}
                onDragMove={(e) => {
                    onValueChange(e[direction]);
                }}
                onDragStart={(e) => {
                    // TODO:
                    onDragStart(percentToValue(e[direction]));
                }}
                contentStyle={contentStyle}
                onDragEnd={(e) => {
                    onAfterChange(e[direction]);
                }}
            >
                <View
                    style={
                        direction === 'x'
                            ? styles.dragWrapperX
                            : styles.dragWrapperY
                    }
                >
                    <View
                        onLayout={(e) => {
                            if (isFirstLayout.current) {
                                const _handleSize = {
                                    width: e.nativeEvent.layout.width,
                                    height: e.nativeEvent.layout.height,
                                };
                                setHandleSize(_handleSize);
                                isFirstLayout.current = false;
                            }
                        }}
                    >
                        {renderHandle ? (
                            renderHandle()
                        ) : (
                            <View
                                style={[
                                    styles.oval,
                                    {
                                        width: ovalSize,
                                        height: ovalSize,
                                        borderRadius: ovalSize / 2,
                                        backgroundColor: ovalColor,
                                    },
                                ]}
                            />
                        )}
                    </View>
                </View>
            </Draggable>
        </View>
    );
};
const styles = StyleSheet.create({
    rectangleWrap: {
        justifyContent: 'center',
        alignItems: 'center',
    },
    rectangleL: {
        width: '100%',
        position: 'absolute',
    },
    dragWrapperX: {
        width: '100%',
        height: '100%',
        justifyContent: 'flex-end',
        alignItems: 'center',
        flexDirection: 'row',
    },
    dragWrapperY: {
        width: '100%',
        height: '100%',
        flexDirection: 'column-reverse',
        justifyContent: 'flex-end',
        alignItems: 'center',
    },
    rectangleS: {
        position: 'absolute',
    },
    oval: {
        right: 0,
    },
});
