// @ts-nocheck
import React, { useRef, useEffect, useMemo, useState, useContext } from 'react';
import {
    Animated,
    StyleSheet,
    StyleProp,
    ViewStyle,
    NativeModules
} from 'react-native';
import RootTagContext from 'react-native/Libraries/ReactNative/RootTagContext.js';
import {
    PanGestureHandler,
    State,
    GestureHandlerRootView
} from 'react-native-gesture-handler';
export interface DraggableProps {
    children: React.ReactNode;
    min?: number;
    max?: number;
    onDragEnd?: (value: { x: number; y: number }) => void;
    onDragStart?: (value: { x: number; y: number }) => void;
    onDragMove?: (value: { x: number; y: number }) => void;
    disabled?: boolean;
    step: number; // percent
    parts?: number; // 进度条一共分为parts段
    positionX?: number; // percent
    positionY?: number; // percent
    moveDirection: 'x' | 'y' | 'both';
    tapToSeek?: boolean;
    getCenterPosition: (touchInfo, wrapInfo) => { x: number; y: number };
    getMoveRange: (
        contentInfo,
        wrapInfo,
    ) => { left: number; right: number; top: number; bottom: number };
    handleSize: { width: number; height: number };
    style?: StyleProp<ViewStyle>;
    contentStyle?: StyleProp<ViewStyle>;
}
const stepFn = (step, num) => Math.round(num / step) * step;

const interpolate = (
    value: number,
    max: number,
    min: number = 0,
    step: number,
): number => {
    let val;
    if (!min) {
        min = 0;
    }
    if (value < min) {
        val = 0;
    } else if (value > max) {
        val = 1;
    } else {
        val = stepFn(step, value / (max - min));
    }
    return val;
};
export const Draggable = (props: DraggableProps) => {
    const {
        disabled = false,
        min,
        max,
        children,
        step,
        style,
        moveDirection = 'both',
        positionX,
        positionY,
        getMoveRange,
        handleSize,
        contentStyle,
        parts = undefined,
    } = props;
    const rootTag = useContext(RootTagContext);
    let slideBackStatus: Boolean;
    const content = useRef(props);
    content.current = props;
    const drag = useRef(false);
    const pan = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const wrapSize = useRef(null);
    const contentSize = useRef(null);
    const [moveRange, setMoveRange] = useState(null);
    const wrapRef = useRef(null);

    // 吸附效果打开时，需要分段
    const percents = React.useMemo(() => {
        if (parts !== undefined) {
            return Array(parts).fill(1).map((_, index) => index * (1 / (parts - 1)));
        }
        return [];
    }, [parts])

    const onLayout = (e) => {
        // wrapSize.current = e.nativeEvent.layout;
        const { width, height } = e.nativeEvent.layout;
        // 因为用e.nativeEvent
        wrapSize.current = { left: 0, top: 0, width, height };
        if (contentSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    const onContentLayout = (e) => {
        contentSize.current = e.nativeEvent.layout;
        if (wrapSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };

    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (moveRange.right - moveRange.left) * positionX,
                y: (pan.y as any)._value,
            });
        }
    }, [positionX, pan, moveRange]);

    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (pan.x as any)._value,
                y: -(moveRange.bottom - moveRange.top) * positionY,
            });
        }
    }, [positionY, pan, moveRange]);

    useEffect(() => {
        const animationId = pan.addListener(() => {
            const position = getNowPosition.current();
            content.current.onDragMove(position);
        })

        return () => {
            pan.removeListener(animationId);
        }
    }, [])
    // PanResponder中要用，直接写函数是闭包
    const getNowPosition = useRef(null);
    getNowPosition.current = () => {
        if (!moveRange) {
            return {
                x: 0,
                y: 0,
            };
        }
        return {
            x: interpolate(
                (pan.x as any).__getValue(),
                moveRange.right - moveRange.left,
                0,
                content.current.step,
            ),
            y: interpolate(
                -(pan.y as any).__getValue(),
                moveRange.bottom - moveRange.top,
                0,
                content.current.step,
            ),
        };
    };
    const pans: { dx?: Animated.Value; dy?: Animated.Value } = {};
    if (moveDirection === 'both' || moveDirection === 'x') {
        pans.dx = pan.x;
    }
    if (moveDirection === 'both' || moveDirection === 'y') {
        pans.dy = pan.y;
    }

    // 补偿逻辑
    useEffect(() => {
        if ((moveDirection === 'x' || moveDirection === 'both') && parts !== undefined && !drag.current) {
            if (!percents.includes(positionX)) {
                autoTo(positionX);
            }
        }
    }, [positionX, moveDirection])

    useEffect(() => {
        if ((moveDirection === 'y' || moveDirection === 'both') && parts !== undefined && !drag.current) {
            if (!percents.includes(positionY)) {
                autoTo(positionY);
            }
        }
    }, [positionY, moveDirection])

    const autoTo = (percent: number) => {
        if(!moveRange) return;
        const { right, left, top, bottom } = moveRange;
        let direction = undefined;
        percents.forEach((_, idx) => {
            if (percent > percents[idx] && percent < percents[idx + 1]) {
                const middle = (percents[idx] + percents[idx + 1]) / 2;
                if (percent < middle) {
                    direction = (moveDirection === 'x' ? (right - left) : -(top + bottom)) * percents[idx];
                } else {
                    direction = (moveDirection === 'x' ? (right - left) : -(top + bottom)) * percents[idx + 1];
                }
                return
            }
        })

        if (direction !== undefined) {
            pan.setOffset({ x: 0, y: 0 })
            pan.setValue({
                x: moveDirection === 'x' ? direction : 0,
                y: moveDirection === 'y' ? direction : 0,
            })
        }
    }
    const _onGestureEvent = Animated.event(
        [
            {
                nativeEvent: {
                    translationX: pan.x,
                    translationY: pan.y,
                },
            },
        ],
        {
            useNativeDriver: false
        }
    );

    const _onHandlerStateChange = async ({ nativeEvent }) => {
        if (nativeEvent.state === State.BEGAN) {
            drag.current = true;
            if (!content.current.tapToSeek) {
                pan.setOffset({
                    x: (pan.x as any)._value,
                    y: (pan.y as any)._value,
                });
                pan.setValue({x: 0, y: 0})
            } else {
                const centerPosition = content.current.getCenterPosition(
                    nativeEvent,
                    wrapSize.current,
                );
                pan.setOffset({
                    x: centerPosition.x ?? (pan.x as any)._value,
                    y: centerPosition.y ?? (pan.y as any)._value,
                });
            }
            content.current.onDragStart(getNowPosition.current());
            if (content.current.tapToSeek) {
                pan.setValue({ x: 0, y: 0 });
                content.current.onDragMove(getNowPosition.current());
            }

            try {
                // drag 开始时获取滑动返回状态,并禁用滑动返回
                slideBackStatus = await NativeModules.KRNBasic?.getSlideBack?.(
                    rootTag,
                );
                NativeModules.KRNBasic?.setSlideBack?.({
                    enabled: false, //  true: 打开滑动返回  false ：关闭滑动返回
                    rootTag: rootTag,
                });
            } catch (error) { }

        }
        if (nativeEvent.state === State.END || nativeEvent.state === State.FAILED || nativeEvent.state === State.CANCELLED) {
            // 当slider设置了animated为true时，吸附效果
            if (parts !== undefined) {
                const { x, y } = getNowPosition.current();
                const percent = moveDirection === 'x' ? x : y;
                autoTo(percent)
            }

            pan.flattenOffset(); // 将pan中的offset合并到base值（(pan.x as any)._value），将offset重置为0，pan最终的输出值（base+offset）不变.
            if ((pan.x as any)._value > wrapSize.current.width) {
                pan.x.setValue(wrapSize.current.width);
            } else if ((pan.x as any)._value < 0) {
                pan.x.setValue(0);
            }
            if ((pan.y as any)._value < -wrapSize.current.height) {
                pan.y.setValue(-wrapSize.current.height);
            } else if ((pan.y as any)._value > 0) {
                pan.y.setValue(0);
            }
            drag.current = false; // 内部控制状态，拖动结束时才接收外部传入的状态
            content.current.onDragEnd(getNowPosition.current());

            try {
                // 拖动结束时，把 SlideBackStatus 还原
                NativeModules.KRNBasic?.setSlideBack?.({
                    enabled: slideBackStatus, //  true: 打开滑动返回  false ：关闭滑动返回
                    rootTag: rootTag,
                });
            } catch (error) { }

        }
    }

    const transform = useMemo(() => {
        if (!wrapSize.current || !contentSize.current || !moveRange) {
            return [];
        }
        const { top, bottom, right, left } = moveRange;
        const result = [];
        if (moveDirection === 'both' || moveDirection === 'x') {
            result.push({
                translateX: pan.x.interpolate({
                    inputRange: [(right - left) * min, (right - left) * max],
                    outputRange: [
                        (right - left) * min - handleSize.width / 2,
                        (right - left) * max + handleSize.width / 2
                    ],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        if (moveDirection === 'both' || moveDirection === 'y') {
            result.push({
                translateY: pan.y.interpolate({
                    inputRange: [-(top + bottom) * max, (top + bottom) * min,],
                    outputRange: [
                        -(top + bottom) * max - handleSize.height / 2,
                        (top + bottom) * min + handleSize.height / 2
                    ],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step)
                }),
            });
        }
        return result;
    }, [moveDirection, pan, step, moveRange]);

    return (
        <GestureHandlerRootView onLayout={onLayout} ref={wrapRef} style={[styles.wrap, style]}>
            <PanGestureHandler
                enabled={!disabled}
                onGestureEvent={_onGestureEvent}
                onHandlerStateChange={_onHandlerStateChange}
                activeOffsetX={moveDirection === 'x' ? [-10, 10] : undefined}
                failOffsetY={moveDirection === 'x' ? [-10, 10] : undefined}
                activeOffsetY={moveDirection === 'y' ? [-10, 10] : undefined}
                failOffsetX={moveDirection === 'y' ? [-10, 10] : undefined}
            >
                <Animated.View style={[styles.dragAble]}>
                    <Animated.View
                        onLayout={onContentLayout}
                        style={[
                            {
                                transform
                            },
                            contentStyle,
                        ]}
                    >
                        {children}
                    </Animated.View>
                </Animated.View>
            </PanGestureHandler>
        </GestureHandlerRootView>
    );
};
const styles = StyleSheet.create({
    wrap: {
        height: '100%',
        width: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    dragAble: {
        position: 'absolute',
        zIndex: 2,
        height: '100%',
        width: '100%',
    },
});
