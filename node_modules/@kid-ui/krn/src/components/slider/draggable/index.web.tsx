// @ts-nocheck
import React, { useRef, useEffect, useMemo, useState } from 'react';
import {
    Animated,
    View,
    PanResponder,
    StyleSheet,
    StyleProp,
    ViewStyle,
} from 'react-native';

export interface DraggableProps {
    children: React.ReactNode;
    min?: number;
    max?: number;
    onDragEnd?: (value: { x: number; y: number }) => void;
    onDragStart?: (value: { x: number; y: number }) => void;
    onDragMove?: (value: { x: number; y: number }) => void;
    disabled?: boolean;
    step: number; // percent
    positionX?: number; // percent
    positionY?: number; // percent
    moveDirection: 'x' | 'y' | 'both';
    tapToSeek?: boolean;
    getCenterPosition: (touchInfo, wrapInfo) => { x: number; y: number };
    getMoveRange: (
        contentInfo,
        wrapInfo,
    ) => { left: number; right: number; top: number; bottom: number };
    style?: StyleProp<ViewStyle>;
    contentStyle?: StyleProp<ViewStyle>;
}
const stepFn = (step, num) => Math.round(num / step) * step;

const interpolate = (
    value: number,
    max: number,
    min: number = 0,
    step: number,
): number => {
    let val;
    if (!min) {
        min = 0;
    }
    if (value < min) {
        val = 0;
    } else if (value > max) {
        val = 1;
    } else {
        val = stepFn(step, value / (max - min));
    }
    return val;
};
export const Draggable = (props: DraggableProps) => {
    const {
        disabled = false,
        min,
        max,
        children,
        step,
        style,
        moveDirection = 'both',
        positionX,
        positionY,
        getMoveRange,
        contentStyle,
    } = props;

    const content = useRef(props);
    content.current = props;
    const drag = useRef(false);
    const pan = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const wrapSize = useRef(null);
    const contentSize = useRef(null);
    const [moveRange, setMoveRange] = useState(null);
    const wrapRef = useRef(null);
    const onLayout = (e) => {
        // wrapSize.current = e.nativeEvent.layout;
        const { width, height } = e.nativeEvent.layout;
        // 因为用e.nativeEvent
        wrapSize.current = { left: 0, top: 0, width, height };
        if (contentSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    const onContentLayout = (e) => {
        contentSize.current = e.nativeEvent.layout;
        if (wrapSize.current) {
            setMoveRange(getMoveRange(contentSize.current, wrapSize.current));
        }
    };
    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (moveRange.right - moveRange.left) * positionX,
                y: (pan.y as any)._value,
            });
        }
    }, [positionX, pan, moveRange]);

    useEffect(() => {
        if (!drag.current && moveRange) {
            pan.setValue({
                x: (pan.x as any)._value,
                y: -(moveRange.bottom - moveRange.top) * positionY,
            });
        }
    }, [positionY, pan, moveRange]);
    // PanResponder中要用，直接写函数是闭包
    const getNowPosition = useRef(null);
    getNowPosition.current = () => {
        if (!moveRange) {
            return {
                x: 0,
                y: 0,
            };
        }
        return {
            x: interpolate(
                (pan.x as any).__getValue(),
                moveRange.right - moveRange.left,
                0,
                content.current.step,
            ),
            y: interpolate(
                -(pan.y as any).__getValue(),
                moveRange.bottom - moveRange.top,
                0,
                content.current.step,
            ),
        };
    };
    const pans: { dx?: Animated.Value; dy?: Animated.Value } = {};
    if (moveDirection === 'both' || moveDirection === 'x') {
        pans.dx = pan.x;
    }
    if (moveDirection === 'both' || moveDirection === 'y') {
        pans.dy = pan.y;
    }
    // 手势控制对象，与animateValue配合，实时更新当前translate的距离
    const panResponder = useMemo(() => {
        return PanResponder.create({
            onStartShouldSetPanResponder: () => !disabled,
            onMoveShouldSetPanResponder: () => !disabled,
            onPanResponderGrant: async (e) => {
                drag.current = true;
                if (!content.current.tapToSeek) {
                    pan.setOffset({
                        x: (pan.x as any)._value,
                        y: (pan.y as any)._value,
                    });
                } else {
                    const centerPosition = content.current.getCenterPosition(
                        e.nativeEvent,
                        wrapSize.current,
                    );
                    pan.setOffset({
                        x: centerPosition.x ?? (pan.x as any)._value,
                        y: centerPosition.y ?? (pan.y as any)._value,
                    });
                }
                content.current.onDragStart(getNowPosition.current());
                if (content.current.tapToSeek) {
                    pan.setValue({ x: 0, y: 0 });
                    content.current.onDragMove(getNowPosition.current());
                }
            },
            onPanResponderMove: Animated.event([null, pans], {
                useNativeDriver: false,
                listener: () => {
                    content.current.onDragMove(getNowPosition.current());
                },
            }),
            onPanResponderRelease: () => {
                pan.flattenOffset(); // 将pan中的offset合并到base值（(pan.x as any)._value），将offset重置为0，pan最终的输出值（base+offset）不变.
                if ((pan.x as any)._value > wrapSize.current.width) {
                    pan.x.setValue(wrapSize.current.width);
                } else if ((pan.x as any)._value < 0) {
                    pan.x.setValue(0);
                }
                if ((pan.y as any)._value < -wrapSize.current.height) {
                    pan.y.setValue(-wrapSize.current.height);
                } else if ((pan.y as any)._value > 0) {
                    pan.y.setValue(0);
                }
                drag.current = false; // 内部控制状态，拖动结束时才接收外部传入的状态
                content.current.onDragEnd(getNowPosition.current());
            },
            onPanResponderTerminationRequest: () => false,
        })
    }, [
        disabled,
        pan  
    ])
    const transform = useMemo(() => {
        if (!wrapSize.current || !contentSize.current) {
            return [];
        }
        const { top, bottom, right, left } = moveRange;
        const result = [];
        if (moveDirection === 'both' || moveDirection === 'x') {
            result.push({
                translateX: pan.x.interpolate({
                    inputRange: [(right - left) * min, (right - left) * max],
                    outputRange: [(right - left) * min, (right - left) * max],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        if (moveDirection === 'both' || moveDirection === 'y') {
            result.push({
                translateY: pan.y.interpolate({
                    inputRange: [-(top + bottom) * max, (top + bottom) * min],
                    outputRange: [-(top + bottom) * max, (top + bottom) * min],
                    extrapolateLeft: 'clamp',
                    extrapolateRight: 'clamp',
                    easing: stepFn.bind(null, step),
                }),
            });
        }
        return result;
    }, [moveDirection, pan, step, moveRange]);

    return (
        <View onLayout={onLayout} ref={wrapRef} style={[styles.wrap, style]}>
            <Animated.View
                onLayout={onContentLayout}
                style={[
                    {
                        transform,
                    },
                    contentStyle,
                ]}
            >
                {children}
            </Animated.View>
            <View style={[styles.dragAble]} {...panResponder.panHandlers} />
        </View>
    );
};
const styles = StyleSheet.create({
    wrap: {
        height: '100%',
        width: '100%',
        justifyContent: 'center',
        alignItems: 'center',
    },
    dragAble: {
        position: 'absolute',
        zIndex: 2,
        height: '100%',
        width: '100%',
    },
});
