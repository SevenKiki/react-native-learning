import { isFunction } from './validate';

const kPromisifiedSymbol = Symbol();

export type PromisableCallback<E = unknown, T = undefined> = (err: E, data: T) => void;

type PromisifyResult<T extends (...args: any) => void> = Parameters<T> extends [
  ...infer params,
  (err: any, data: infer results) => void,
]
  ? (...args: params) => Promise<results>
  : (...args: any) => Promise<any>;

interface promisifyFunction<T extends (...args: any) => any> extends Function {
  [kPromisifiedSymbol]?: PromisifyResult<T>;
}

export const promisify = <T extends (...args: any) => any>(original: T): PromisifyResult<T> => {
  if (!isFunction(original)) {
    throw new Error('original is not a Function');
  }

  const originalFn = (original as promisifyFunction<T>)[kPromisifiedSymbol];
  if (originalFn && isFunction(originalFn)) {
    return Object.defineProperty(originalFn, kPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true,
    });
  }

  type Params = Parameters<T> extends [...infer params, (err: any, data: any) => void] ? params : never;
  type Return = ReturnType<T>;

  function fn(this: any, ...args: Params): Promise<Return> {
    return new Promise((resolve, reject) => {
      args.push((err: Error, data: Return) => {
        if (err) {
          return reject(err);
        }

        resolve(data);
      });

      Reflect.apply(original, this, args);
    });
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true,
  });
  return Object.defineProperties(fn as PromisifyResult<T>, Object.getOwnPropertyDescriptors(original));
};
